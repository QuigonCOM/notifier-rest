{
  "allowance": [
    "",
    "{}",
    "{return_allowances[owner][spender];}",
    "{returnallowances[_owner][_spender][_id];}"
  ],
  "_contains": [
    "{\\rreturnmap._indexes[key]!=0;\\r}",
    "{}",
    "{returnset._indexes[value]!=0;}",
    "{returnmap._indexes[key]!=0;}"
  ],
  "_verifyCallResult": [
    "{\\rif(success){\\rreturnreturndata;\\r}else{\\rif(returndata.length>0){\\r\\rassembly{\\rletreturndata_size:=mload(returndata)\\rrevert(add(32,returndata),returndata_size)\\r}\\r}else{\\rrevert(errorMessage);\\r}\\r}\\r}",
    "{if(success){returnreturndata;}else{if(returndata.length\\u003e0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{if(success){returnreturndata;}else{//Lookforrevertreasonandbubbleitupifpresentif(returndata.length>0){//Theeasiestwaytobubbletherevertreasonisusingmemoryviaassembly//solhint-disable-next-lineno-inline-assemblyassembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{if(success){returnreturndata;}else{//Lookforrevertreasonandbubbleitupifpresentif(returndata.length>0){//Theeasiestwaytobubbletherevertreasonisusingmemoryviaassemblyassembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{if(success){returnreturndata;}else{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "",
    "{if(success){returnreturndata;}else{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{}"
  ],
  "verifyCallResult": [
    "{if(success){returnreturndata;}else{if(returndata.length\\u003e0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{\\rif(success){\\rreturnreturndata;\\r}else{\\rif(returndata.length\\u003e0){\\r\\rassembly{\\rletreturndata_size:=mload(returndata)\\rrevert(add(32,returndata),returndata_size)\\r}\\r}else{\\rrevert(errorMessage);\\r}\\r}\\r}",
    "{\\rif(success){\\rreturnreturndata;\\r}else{\\rif(returndata.length>0){\\r\\rassembly{\\rletreturndata_size:=mload(returndata)\\rrevert(add(32,returndata),returndata_size)\\r}\\r}else{\\rrevert(errorMessage);\\r}\\r}\\r}",
    "{if(success){returnreturndata;}else{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{if(success){returnreturndata;}else{_revert(returndata,errorMessage);}}",
    "{if(success){returnreturndata;}else{//Lookforrevertreasonandbubbleitupifpresentif(returndata.length>0){//Theeasiestwaytobubbletherevertreasonisusingmemoryviaassembly///@soliditymemory-safe-assemblyassembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{if(success){returnreturndata;}else{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{}",
    "{if(success){returnreturndata;}else{//Lookforrevertreasonandbubbleitupifpresentif(returndata.length>0){//Theeasiestwaytobubbletherevertreasonisusingmemoryviaassemblyassembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}"
  ],
  "_remove": [
    "{\\ruint256keyIndex=map._indexes[key];\\r\\rif(keyIndex!=0){\\ruint256toDeleteIndex=keyIndex-1;\\ruint256lastIndex=map._entries.length-1;\\r\\r\\rMapEntrystoragelastEntry=map._entries[lastIndex];\\r\\rmap._entries[toDeleteIndex]=lastEntry;\\rmap._indexes[lastEntry._key]=toDeleteIndex+1;\\r\\rmap._entries.pop();\\r\\rdeletemap._indexes[key];\\r\\rreturntrue;\\r}else{\\rreturnfalse;\\r}\\r}",
    "{uint256valueIndex=set._indexes[value];if(valueIndex!=0){uint256toDeleteIndex=valueIndex-1;uint256lastIndex=set._values.length-1;bytes32lastvalue=set._values[lastIndex];set._values[toDeleteIndex]=lastvalue;set._indexes[lastvalue]=toDeleteIndex+1;set._values.pop();deleteset._indexes[value];returntrue;}else{returnfalse;}}",
    "{}",
    "{//Wereadandstorethevalue'sindextopreventmultiplereadsfromthesamestorageslotuint256valueIndex=set._indexes[value];if(valueIndex!=0){//Equivalenttocontains(set,value)//Todeleteanelementfromthe_valuesarrayinO(1),weswaptheelementtodeletewiththelastonein//thearray,andthenremovethelastelement(sometimescalledas'swapandpop').//Thismodifiestheorderofthearray,asnotedin{at}.uint256toDeleteIndex=valueIndex-1;uint256lastIndex=set._values.length-1;if(lastIndex!=toDeleteIndex){bytes32lastvalue=set._values[lastIndex];//Movethelastvaluetotheindexwherethevaluetodeleteisset._values[toDeleteIndex]=lastvalue;//Updatetheindexforthemovedvalueset._indexes[lastvalue]=valueIndex;//Replacelastvalue'sindextovalueIndex}//Deletetheslotwherethemovedvaluewasstoredset._values.pop();//Deletetheindexforthedeletedslotdeleteset._indexes[value];returntrue;}else{returnfalse;}}",
    "{uint256keyIndex=map._indexes[key];if(keyIndex!=0){uint256toDeleteIndex=keyIndex-1;uint256lastIndex=map._entries.length-1;MapEntrystoragelastEntry=map._entries[lastIndex];map._entries[toDeleteIndex]=lastEntry;map._indexes[lastEntry._key]=toDeleteIndex+1;map._entries.pop();deletemap._indexes[key];returntrue;}else{returnfalse;}}",
    "{uint256valueIndex=set._indexes[value];if(valueIndex!=0){uint256toDeleteIndex=valueIndex-1;uint256lastIndex=set._values.length-1;if(lastIndex!=toDeleteIndex){bytes32lastValue=set._values[lastIndex];set._values[toDeleteIndex]=lastValue;set._indexes[lastValue]=valueIndex;}set._values.pop();deleteset._indexes[value];returntrue;}else{returnfalse;}}",
    "{//Wereadandstorethekey'sindextopreventmultiplereadsfromthesamestorageslotuint256keyIndex=map._indexes[key];if(keyIndex!=0){//Equivalenttocontains(map,key)//Todeleteakey-valuepairfromthe_entriesarrayinO(1),weswaptheentrytodeletewiththelastone//inthearray,andthenremovethelastentry(sometimescalledas'swapandpop').//Thismodifiestheorderofthearray,asnotedin{at}.uint256toDeleteIndex=keyIndex-1;uint256lastIndex=map._entries.length-1;//Whentheentrytodeleteisthelastone,theswapoperationisunnecessary.However,sincethisoccurs//sorarely,westilldotheswapanywaytoavoidthegascostofaddingan'if'statement.MapEntrystoragelastEntry=map._entries[lastIndex];//Movethelastentrytotheindexwheretheentrytodeleteismap._entries[toDeleteIndex]=lastEntry;//Updatetheindexforthemovedentrymap._indexes[lastEntry._key]=toDeleteIndex+1;//Allindexesare1-based//Deletetheslotwherethemovedentrywasstoredmap._entries.pop();//Deletetheindexforthedeletedslotdeletemap._indexes[key];returntrue;}else{returnfalse;}}",
    "{//Wereadandstorethevalue'sindextopreventmultiplereadsfromthesamestorageslotuint256valueIndex=set._indexes[value];if(valueIndex!=0){//Equivalenttocontains(set,value)//Todeleteanelementfromthe_valuesarrayinO(1),weswaptheelementtodeletewiththelastonein//thearray,andthenremovethelastelement(sometimescalledas'swapandpop').//Thismodifiestheorderofthearray,asnotedin{at}.uint256toDeleteIndex=valueIndex-1;uint256lastIndex=set._values.length-1;//Whenthevaluetodeleteisthelastone,theswapoperationisunnecessary.However,sincethisoccurs//sorarely,westilldotheswapanywaytoavoidthegascostofaddingan'if'statement.bytes32lastvalue=set._values[lastIndex];//Movethelastvaluetotheindexwherethevaluetodeleteisset._values[toDeleteIndex]=lastvalue;//Updatetheindexforthemovedvalueset._indexes[lastvalue]=toDeleteIndex+1;//Allindexesare1-based//Deletetheslotwherethemovedvaluewasstoredset._values.pop();//Deletetheindexforthedeletedslotdeleteset._indexes[value];returntrue;}else{returnfalse;}}"
  ],
  "isNonFungible": ["", "{}", "{return_id\\u0026TYPE_NF_BIT==TYPE_NF_BIT;}"],
  "contains": [
    "{\\rreturn_contains(map._inner,bytes32(key));\\r}",
    "{}",
    "{return_contains(set._inner,bytes32(value));}",
    "{return_contains(map._inner,bytes32(key));}"
  ],
  "getNonFungibleBaseType": ["", "{}", "{return_id\\u0026TYPE_MASK;}"],
  "_removeTokenFromAllTokensEnumeration": [
    "{uint256lastTokenIndex=_allTokens.length-1;uint256tokenIndex=_allTokensIndex[tokenId];uint256lastTokenId=_allTokens[lastTokenIndex];_allTokens[tokenIndex]=lastTokenId;//Movethelasttokentotheslotoftheto-deletetoken_allTokensIndex[lastTokenId]=tokenIndex;//Updatethemovedtoken'sindexdelete_allTokensIndex[tokenId];_allTokens.pop();}",
    "{//Topreventagapinthetokensarray,westorethelasttokenintheindexofthetokentodelete,and//thendeletethelastslot(swapandpop).uint256lastTokenIndex=_allTokens.length-1;uint256tokenIndex=_allTokensIndex[tokenId];//Whenthetokentodeleteisthelasttoken,theswapoperationisunnecessary.However,sincethisoccursso//rarely(whenthelastmintedtokenisburnt)thatwestilldotheswapheretoavoidthegascostofadding//an'if'statement(likein_removeTokenFromOwnerEnumeration)uint256lastTokenId=_allTokens[lastTokenIndex];_allTokens[tokenIndex]=lastTokenId;//Movethelasttokentotheslotoftheto-deletetoken_allTokensIndex[lastTokenId]=tokenIndex;//Updatethemovedtoken'sindex//Thisalsodeletesthecontentsatthelastpositionofthearraydelete_allTokensIndex[tokenId];_allTokens.pop();}",
    "{\\r\\ruint256lastTokenIndex=_allTokens.length-1;\\ruint256tokenIndex=_allTokensIndex[tokenId];\\r\\ruint256lastTokenId=_allTokens[lastTokenIndex];\\r\\r_allTokens[tokenIndex]=lastTokenId;_allTokensIndex[lastTokenId]=tokenIndex;\\rdelete_allTokensIndex[tokenId];\\r_allTokens.pop();\\r}",
    "{}",
    "{uint256lastTokenIndex=_allTokens.length-1;uint256tokenIndex=_allTokensIndex[tokenId];uint256lastTokenId=_allTokens[lastTokenIndex];_allTokens[tokenIndex]=lastTokenId;_allTokensIndex[lastTokenId]=tokenIndex;delete_allTokensIndex[tokenId];_allTokens.pop();}",
    "{uint256lastTokenIndex=_allTokens.length.sub(1);uint256tokenIndex=_allTokensIndex[tokenId];uint256lastTokenId=_allTokens[lastTokenIndex];_allTokens[tokenIndex]=lastTokenId;_allTokensIndex[lastTokenId]=tokenIndex;_allTokens.length--;_allTokensIndex[tokenId]=0;}"
  ],
  "_addTokenToOwnerEnumeration": [
    "{uint256length=BRC721.balanceOf(to);_ownedTokens[to][length]=tokenId;_ownedTokensIndex[tokenId]=length;}",
    "{\\ruint256length=ERC721.balanceOf(to);\\r_ownedTokens[to][length]=tokenId;\\r_ownedTokensIndex[tokenId]=length;\\r}",
    "{uint256length=balanceOf(to);_ownedTokens[to][length]=tokenId;_ownedTokensIndex[tokenId]=length;}",
    "{_ownedTokensIndex[tokenId]=_ownedTokens[to].length;_ownedTokens[to].push(tokenId);}",
    "{}",
    "{uint256length=ERC721.balanceOf(to);_ownedTokens[to][length]=tokenId;_ownedTokensIndex[tokenId]=length;}"
  ],
  "_approve": [
    "{kittyIndexToApproved[_tokenId]=_approved;}",
    "{_tokenApprovals[tokenId]=to;emitApproval(BRC721.ownerOf(tokenId),to,tokenId);}",
    "{\\r_tokenApprovals[tokenId]=to;\\remitApproval(ERC721.ownerOf(tokenId),to,tokenId);\\r}_checkOnERC721Received {\\rif(to.isContract()){\\rtryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){\\rreturnretval==IERC721Receiver.onERC721Received.selector;\\r}catch(bytesmemoryreason){\\rif(reason.length==0){\\rrevert(\"ERC721:transfertononERC721Receiverimplementer\");\\r}else{\\rassembly{\\rrevert(add(32,reason),mload(reason))\\r}\\r}\\r}\\r}else{\\rreturntrue;\\r}\\r}",
    "{addressowner=ownerOf(tokenId);if(approvalCheck&&_msgSenderERC721A()!=owner)if(!isApprovedForAll(owner,_msgSenderERC721A())){_revert(ApprovalCallerNotOwnerNorApproved.selector);}_tokenApprovals[tokenId].value=to;emitApproval(owner,to,tokenId);}",
    "{\\r_tokenApprovals[tokenId]=to;\\remitApproval(ERC721.ownerOf(tokenId),to,tokenId);\\r}",
    "{_tokenApprovals[tokenId]=to;emitApproval(owner,to,tokenId);}",
    "{_tokenApprovals[tokenId]=to;emitApproval(ownerOf(tokenId),to,tokenId);}",
    "{_tokenApprovals[tokenId]=to;emitApproval(ERC721.ownerOf(tokenId),to,tokenId);}",
    "{require(owner!=address(0),\"ERC20:approvefromthezeroaddress\");require(spender!=address(0),\"ERC20:approvetothezeroaddress\");_allowances[owner][spender]=amount;emitApproval(owner,spender,amount);}",
    "{_tokenApprovals[tokenId]=to;emitApproval(ERC721.ownerOf(tokenId),to,tokenId);//internalowner}",
    "{_tokenApprovals[tokenId]=to;emitApproval(CHECKS721.ownerOf(tokenId),to,tokenId);}"
  ],
  "msgSender": [
    "{if(msg.sender==address(this)){bytesmemoryarray=msg.data;uint256index=msg.data.length;assembly{sender:=and(mload(add(array,index)),0xffffffffffffffffffffffffffffffffffffffff)}}else{sender=payable(msg.sender);}returnsender;}",
    "{assembly{sender:=shr(96,calldataload(sub(calldatasize(),20)))}}"
  ],
  "_msgSender": [
    "{returnBaseRelayRecipient._msgSender();}",
    "{\\rreturnpayable(msg.sender);\\r}",
    "{returnERC2771Context._msgSender();}",
    "{\\rreturnmsg.sender;\\r}",
    "{\\rreturnGameRegistryConsumer._msgSender();\\r}",
    "{returnContextMixin.msgSender();}",
    "{returnmsg.sender;}",
    "{returnmsgSender();}",
    "{returnpayable(msg.sender);}",
    "{returnForwarderRegistryContextBase._msgSender();}",
    "{returnGameRegistryConsumer._msgSender();}"
  ],
  "emitPoolAdded": [],
  "emitPoolUpdated": [],
  "PoolAdded": [],
  "PoolUpdated": [],
  "PoolRemoved": [],
  "TransferToNonERC721ReceiverImplementer": [],
  "min": ["{returna<b?a:b;}", "{returnone<two?one:two;}"],
  "div": [
    "{//Solidityonlyautomaticallyassertswhendividingby0require(b>0);uint256c=a/b;//assert(a==b*c+a%b);//Thereisnocaseinwhichthisdoesn'tholdreturnc;}",
    "{require(b>0,errorMessage);returna/b;}",
    "{require(b>0,errorMessage);uint256c=a/b;returnc;}",
    "{require(b>0,\"\");returna/b;}",
    "{require(_divisor>0,\"\");quotient=_dividend/_divisor;}",
    "{unchecked{require(b>0,\"\");returna/b;}}",
    "{require(b>0,\"\");uint256c=a/b;returnc;}"
  ],
  "getDistribution": [
    "{uint256from=Math.max(startTime,_from);uint256to=Math.min(_to,contractDisabledAt==0?endTime:contractDisabledAt);if(from>to)returnuint256(0);from=from.sub(startTime);to=to.sub(startTime);//d(t1,t2)=(t2-t1)*(2*ds-(-m)*(t2+t1))/2returnto.sub(from).mul(startDistribution.mul(2).sub(distributionSlope.mul(from.add(to))))/2;}"
  ],
  "mul": [
    "{if(a==0){return0;}uint256c=a*b;require(c/a==b,\"SafeMath:multiplicationoverflow\");returnc;}",
    "{//Gasoptimization:thisischeaperthanrequiring'a'notbeingzero,butthe//benefitislostif'b'isalsotested.//See:https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522if(a==0){return0;}uint256c=a*b;require(c/a==b);returnc;}",
    "{if(a==0)return0;uint256c=a*b;require(c/a==b,\"SafeMath:multiplicationoverflow\");returnc;}",
    "{if(a==0)return0;uint256c=a*b;require(c/a==b,\"\");returnc;}",
    "{if(_factor1==0){return0;}product=_factor1*_factor2;require(product/_factor1==_factor2,\"\");}",
    "{returna*b;}",
    "{if(a==0){return0;}uint256c=a*b;require(c/a==b,\"\");returnc;}"
  ],
  "at": [
    "{returnuint256(_at(set._inner,index));}",
    "{(bytes32key,bytes32value)=_at(map._inner,index);return(uint256(key),address(uint160(uint256(value))));}"
  ],
  "_at": [
    "{require(map._entries.length>index,\"EnumerableMap:indexoutofbounds\");MapEntrystorageentry=map._entries[index];return(entry._key,entry._value);}",
    "{require(set._values.length>index,\"EnumerableSet:indexoutofbounds\");returnset._values[index];}",
    "{returnuint256(_at(set._inner,index));}",
    "{(bytes32key,bytes32value)=_at(map._inner,index);return(uint256(key),address(uint160(uint256(value))));}",
    "{require(map._entries.length>index,\"\");MapEntrystorageentry=map._entries[index];return(entry._key,entry._value);}",
    "{returnset._values[index];}"
  ],
  "updatePool": [
    "{PoolInfostoragepool=poolInfo[_poolToken];if(block.timestamp<=pool.lastRewardTimestamp){return;}uint256totalShares=pool.totalShares;if(totalShares==0){pool.lastRewardTimestamp=block.timestamp;return;}uint256dist=getDistribution(pool.lastRewardTimestamp,block.timestamp);uint256hsfReward=dist.mul(pool.allocation).div(totalAllocationPoints);uint256poolScaledRewards=hsfReward.div(totalShares);pool.accHsfPerShare=pool.accHsfPerShare.add(poolScaledRewards);pool.lastRewardTimestamp=block.timestamp;}"
  ],
  "massUpdatePools": [
    "{uint256length=pools.length();for(uint256pid=0;pid<length;pid++){updatePool(IERC20(pools.at(pid)));}}"
  ],
  "max": ["{returna>b?a:b;}", "{returna>=b?a:b;}", "{returnone>two?one:two;}"],
  "add": [
    "{uint256c=a+b;require(c>=a);returnc;}",
    "{require(address(rewardManager)!=address(0),\"HF:RewardManagernotsetupyet\");require(_allocation>0,\"HF:Toolowallocation\");massUpdatePools();require(pools.add(address(_lpToken)),\"HF:LPpoolalreadyexists\");uint256lastRewardTimestamp=Math.max(block.timestamp,startTime);totalAllocationPoints=totalAllocationPoints.add(_allocation);poolInfo[_lpToken]=PoolInfo({allocation:_allocation,lastRewardTimestamp:lastRewardTimestamp,accHsfPerShare:0,totalShares:0});emitPoolAdded(_lpToken,_allocation);}",
    "{if(account==address(0)){revertUnauthorized();}elseif(has(role,_type,account)){revertMaxSplaining({reason:string(abi.encodePacked(\"LibRoles:\",Strings.toHexString(uint160(account),20),\"alreadyhasrole\",Strings.toHexString(uint32(_type),4)))});}role.bearer[account][_type]=true;emitRoleChanged(_type,account,true);}",
    "{}",
    "{\\rreturn_add(set._inner,bytes32(value));\\r}",
    "{c=a+b;require(c>=a);returnc;}",
    "{minters[_minter]=true;emitMinterRoleGranted(_minter);}",
    "{require(value<type(uint240).max,\"Outofrange\");uint256amountPos=BalanceAmount.unwrap(b);uint240amount=uint240(amountPos>>16);uint16position=uint16(amountPos&0xffff);amount+=uint240(value);amountPos=(uint256(amount)<<16)|position;returnBalanceAmount.wrap(amountPos);}",
    "",
    "{uintc=a+b;require(c>=a,\"SafeMath:additionoverflow\");returnc;}",
    "{c=a+b;assert(c\\u003e=a);returnc;}",
    "{returna+b;}",
    "{uint256c=a+b;require(c>=a,\"SafeMath:additionoverflow\");returnc;}",
    "{return_add(set._inner,bytes32(value));}",
    "{require(!has(role,account),\"Roles:accountalreadyhasrole\");role.bearer[account]=true;}",
    "{sum=_addend1+_addend2;require(sum>=_addend1,\"\");}",
    "{uint256c=a+b;require(c>=a,\"\");returnc;}"
  ],
  "_exists": [
    "{returntokenId<_currentIndex&&!_ownerships[tokenId].burned;}",
    "{\\rreturn_tokenOwners.contains(tokenId);\\r}",
    "{return_ownerOf(tokenId)!=address(0);}",
    "{return_startTokenId()\\u003c=tokenId\\u0026\\u0026tokenId\\u003c_currentIndex\\u0026\\u0026_packedOwnerships[tokenId]\\u0026_BITMASK_BURNED==0;}",
    "{\\rreturn_owners[tokenId]!=address(0);\\r}",
    "{return_startTokenId()<=tokenId&&tokenId<currentIndex;}",
    "{return_owners[tokenId]!=address(0);}",
    "{addressowner=_tokenOwner[tokenId];returnowner!=address(0);}",
    "{return_startTokenId()<=tokenId&&tokenId<_currentIndex&&_packedOwnerships[tokenId]&_BITMASK_BURNED==0;}",
    "{returntokenId<_owners.length;}",
    "{return_startTokenId()<=tokenId&&tokenId<_currentIndex&&//Ifwithinbounds,_packedOwnerships[tokenId]&_BITMASK_BURNED==0;//andnotburned.}",
    "{return_startTokenId()<=tokenId&&tokenId<_currentIndex&&!_ownerships[tokenId].burned;}",
    "{returntokenId>0&&tokenId<=getNumMinted()&&_tokens[tokenId].owner!=0x0;}",
    "{return_tokenOwners.contains(tokenId);}",
    "{returntokenId<currentIndex;}",
    "{if(_startTokenId()<=tokenId){if(tokenId<_currentIndex){uint256packed;while((packed=_packedOwnerships[tokenId])==0)--tokenId;result=packed&_BITMASK_BURNED==0;}}}"
  ],
  "ownerOf": [
    "{owner=kittyIndexToOwner[_tokenId];require(owner!=address(0));}",
    "{addressowner=_owners[tokenId];if(owner==address(0)){return_admin;}returnowner;}",
    "{addressowner=idToOwner[_tokenId];require(owner!=address(0),\"VENFT:ownerqueryfornonexistenttoken\");returnowner;}",
    "{\\rreturn_tokenOwners.get(tokenId,\"ERC721:ownerqueryfornonexistenttoken\");\\r}",
    "{addressowner=_owners[tokenId];require(owner!=address(0),'ERC721:ownerqueryfornonexistenttoken');returnowner;}",
    "{addressowner=erc721Storage().owners[tokenId];require(owner!=address(0),\"ERC721:ownerqueryfornonexistenttoken\");returnowner;}",
    "{addressowner=_tokenOwner[tokenId];require(owner!=address(0),\"ERC721:ownerqueryfornonexistenttoken\");returnowner;}",
    "{\\raddressowner=_owners[tokenId];\\rrequire(owner!=address(0),\"ERC721:ownerqueryfornonexistenttoken\");\\rreturnowner;\\r}",
    "{require(idToOwner[_tokenId]!=address(0));_owner=idToOwner[_tokenId];}",
    "{return_ownershipOf(tokenId).addr;}",
    "{returnownershipOf(tokenId).addr;}",
    "{return_ownerOf(tokenId)!=address(0);}",
    "{addressowner=_ownerOf(tokenId);require(owner!=address(0),\"ERC721:invalidtokenID\");returnowner;}",
    "{addressowner=_owners[tokenId];require(owner!=address(0),\"ERC721:ownerqueryfornonexistenttoken\");returnowner;}",
    "{require(_exists(tokenId),\"ERC721:ownerqueryfornonexistenttoken\");returnaddress(_tokens[tokenId].owner);}",
    "{addressowner=_owners[tokenId];require(owner!=address(0),\"ERC721:invalidtokenID\");returnowner;}",
    "{require(_exists(tokenId),\"ERC721:ownerqueryfornonexistenttoken\");returnaddress(_tokens[tokenId].owner);}",
    "{returnaddress(uint160(_packedOwnershipOf(tokenId)));}",
    "{require(expiries[tokenId]>now);returnsuper.ownerOf(tokenId);}",
    "{uint256owner=s.owners[tokenId];require(_tokenExists(owner),\"ERC721:non-existingtoken\");return_tokenOwner(owner);}",
    "{return_tokenOwners.get(tokenId,\"ERC721:ownerqueryfornonexistenttoken\");}",
    "{returnnfOwners[_id];}",
    "{return_owners[_id];}",
    "{if(!_exists(tokenId))revertOwnerQueryForNonexistentToken();//Cannotrealisticallyoverflow,sinceweareusinguint256unchecked{for(tokenId;;tokenId++){if(_owners[tokenId]!=address(0)){return_owners[tokenId];}}}revertUnableDetermineTokenOwner();}",
    "{addressowner=_owners[tokenId];require(owner!=address(0),\"\");returnowner;}",
    "{_owner=idToOwner[_tokenId];require(_owner!=address(0),\"\");}",
    "{addressowner=_tokenOwner[tokenId];require(owner!=address(0),\"\");returnowner;}",
    "{addressowner=_ownerOf(tokenId);require(owner!=address(0),\"\");returnowner;}",
    "{addressowner=_ownerOf(tokenId);if(owner==address(0)){revertERC721__InvalidToken();}returnowner;}"
  ],
  "_checkOnERC721Received": [
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revertTransferToNonERC721ReceiverImplementer();}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{\\rif(!to.isContract()){\\rreturntrue;\\r}\\rbytesmemoryreturndata=to.functionCall(abi.encodeWithSelector(\\rIERC721Receiver(to).onERC721Received.selector,\\r_msgSender(),\\rfrom,\\rtokenId,\\r_data\\r),\"ERC721:transfertononERC721Receiverimplementer\");\\rbytes4retval=abi.decode(returndata,(bytes4));\\rreturn(retval==_ERC721_RECEIVED);\\r}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert('ERC721:transfertononERC721Receiverimplementer');}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{\\rif(to.isContract()){\\rtryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){\\rreturnretval==IERC721Receiver.onERC721Received.selector;\\r}catch(bytesmemoryreason){\\rif(reason.length==0){\\rrevert(\"ERC721:transfertononERC721Receiverimplementer\");\\r}else{\\rassembly{\\rrevert(add(32,reason),mload(reason))\\r}\\r}\\r}\\r}else{\\rreturntrue;\\r}\\r}",
    "{\\rif(to.isContract()){\\rtryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){\\rreturnretval==IERC721Receiver(to).onERC721Received.selector;\\r}catch(bytesmemoryreason){\\rif(reason.length==0){\\rrevert(\"ERC721:transfertononERC721Receiverimplementer\");\\r}else{\\rassembly{\\rrevert(add(32,reason),mload(reason))\\r}\\r}\\r}\\r}else{\\rreturntrue;\\r}\\r}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721A:transfertononERC721Receiverimplementer\");}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{///@soliditymemory-safe-assemblyassembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(!to.isContract()){returntrue;}bytes4retval=IERC721Receiver(to).onERC721Received(msg.sender,from,tokenId,_data);return(retval==_ERC721_RECEIVED);}",
    "{if(to.code.length==0)returntrue;tryIERC721Receiver(to).onERC721Received(msg.sender,from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0)revertTransferToNonERC721ReceiverImplementer();assembly{revert(add(32,reason),mload(reason))}}}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{assembly{revert(add(32,reason),mload(reason))}}}}returntrue;}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{//solhint-disable-next-lineno-inline-assemblyassembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(!to.isContract()){returntrue;}bytesmemoryreturndata=to.functionCall(abi.encodeWithSelector(IERC721Receiver(to).onERC721Received.selector,_msgSender(),from,tokenId,_data),\"ERC721:transfertononERC721Receiverimplementer\");bytes4retval=abi.decode(returndata,(bytes4));return(retval==_ERC721_RECEIVED);}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revertERC721__TransferToNonReceiver();}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}"
  ],
  "safeTransferFrom": [
    "{transferFrom(from,to,id);require(to.code.length==0||ERC721TokenReceiver(to).onERC721Received(msg.sender,from,id,data)==ERC721TokenReceiver.onERC721Received.selector,\"UNSAFE_RECIPIENT\");}",
    "{_transfer(from,to,tokenId);if(!_checkOnERC721Received(from,to,tokenId,_data)){revertTransferToNonERC721ReceiverImplementer();}}",
    " {_transfer(from,to,tokenId);if(!_checkOnERC721Received(from,to,tokenId,_data)){revertTransferToNonERC721ReceiverImplementer();}}",
    "{//Pretransferchecks.addressoperator=_msgSender();require(!paused(),\"Error:tokentransferwhilepaused\");_transfer(from,to,operator,id);//Posttransfer:checkIERC721Receiverwithdatainput.require(_checkOnERC721Received(from,to,id,data),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{_mintIfNotExist(tokenId);require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_safeTransfer(from,to,tokenId,_data);}",
    "{safeTransferFrom(_from,_to,_tokenId,'');}",
    "{\\r(boolsuccess,bytesmemorydata)=token.call(abi.encodeWithSelector(0x23b872dd,from,to,value));\\rrequire(success\\u0026\\u0026(data.length==0||abi.decode(data,(bool))),\\u0027TransferHelper:TRANSFER_FROM_FAILED\\u0027);\\r}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),'ERC721:transfercallerisnotownernorapproved');_safeTransfer(from,to,tokenId,_data);}",
    "{\\rrequire(to!=address(this),\"Recipientcannotbetheaddressofthecontract\");\\rsuper.safeTransferFrom(from,to,tokenId,_data);\\rrentedTokensLandlords[tokenId]=address(0);\\r}",
    "{require(from==_msgSender()||isApprovedForAll(from,_msgSender())||isApprovedForPool(id,_msgSender()),\"ERC1155WithTerminusStorage:callerisnotownernorapproved\");_safeTransferFrom(from,to,id,amount,data);}",
    "{require(to!=address(this),\"Recipientcannotbetheaddressofthecontract\");super.safeTransferFrom(from,to,tokenId,_data);rentedTokensLandlords[tokenId]=address(0);}",
    "{transferFrom(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,_data),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{\\rsuper.safeTransferFrom(from,to,tokenId,data);\\r}",
    "{\\rrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");\\r_safeTransfer(from,to,tokenId,_data);\\r}",
    "{_safeTransferFrom(_from,_to,_tokenId,\"\");}",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||getApproved(tokenId)==_msgSender()||isApprovedForAll(prevOwnership.addr,_msgSender()));require(isApprovedOrOwner,\"ERC721A:transfercallerisnotownernorapproved\");require(prevOwnership.addr==from,\"ERC721A:transferfromincorrectowner\");require(to!=address(0),\"ERC721A:transfertothezeroaddress\");_beforeTokenTransfers(from,to,tokenId,1);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId,prevOwnership.addr);_addressData[from].balance-=1;_addressData[to].balance+=1;_ownerships[tokenId]=TokenOwnership(to,uint64(block.timestamp));//IftheownershipslotoftokenId+1isnotexplicitlyset,thatmeansthetransferinitiatorownsit.//SettheslotoftokenId+1explicitlyinstoragetomaintaincorrectnessforownerOf(tokenId+1)calls.uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(_exists(nextTokenId)){_ownerships[nextTokenId]=TokenOwnership(prevOwnership.addr,prevOwnership.startTimestamp);}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{super.safeTransferFrom(from,to,tokenId,data);}",
    "{_transfer(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,_data),\"ERC721A:transfertononERC721Receiverimplementer\");}",
    "{\\rrequire(to!=address(0),\"ERC1155:transfertothezeroaddress\");\\rrequire(\\rfrom==_msgSender()||isApprovedForAll(from,_msgSender()),\\r\"ERC1155:callerisnotownernorapproved\"\\r);\\r\\raddressoperator=_msgSender();\\r\\ruint256fromBalance=_balances[id][from];\\rrequire(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");\\r_balances[id][from]=fromBalance-amount;\\r_balances[id][to]+=amount;\\r\\remitTransferSingle(operator,from,to,id,amount);\\r\\r_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);\\r}",
    "{//bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));(boolsuccess,bytesmemorydata)=token.call(abi.encodeWithSelector(0x23b872dd,from,to,value));require(success&&(data.length==0||abi.decode(data,(bool))),'Transferfailed');}",
    "{_pushBurn(from,nftId,amount);_pushMint(to,nftId,amount);super.safeTransferFrom(from,to,nftId,amount,data);}",
    "{require((msg.sender==_from)||isApprovedForAll(_from,msg.sender),\"INVALID_OPERATOR\");require(_to!=address(0),\"INVALID_RECIPIENT\");if(_id>RING&&_id<=RING+ttlRings){_updateIDUserTotalBalance(_to,RING_INDEX,_amount,Operations.Add);_updateIDUserTotalBalance(_from,RING_INDEX,_amount,Operations.Sub);}if(_id>AMULET&&_id<=AMULET+ttlAmulets){_updateIDUserTotalBalance(_to,AMULET_INDEX,_amount,Operations.Add);_updateIDUserTotalBalance(_from,AMULET_INDEX,_amount,Operations.Sub);}if(_id>FIGHTER&&_id<=FIGHTER+ttlFYakuzas){_updateIDUserTotalBalance(_to,FIGHTER_INDEX,_amount,Operations.Add);//Addamounttorecipient_updateIDUserTotalBalance(_from,FIGHTER_INDEX,_amount,Operations.Sub);//Addamounttorecipient}if(_id>FIGHT_CLUB&&_id<=FIGHT_CLUB+ttlFightClubs){_updateIDUserTotalBalance(_to,FIGHT_CLUB_INDEX,_amount,Operations.Add);//Addamounttorecipient_updateIDUserTotalBalance(_from,FIGHT_CLUB_INDEX,_amount,Operations.Sub);//AddamounttorecipientidToForgeFightClub[_id].owner=_to;}if(_id>FORGE&&_id<=FORGE+ttlForges){_updateIDUserTotalBalance(_to,FORGE_INDEX,_amount,Operations.Add);//Addamounttorecipient_updateIDUserTotalBalance(_from,FORGE_INDEX,_amount,Operations.Sub);//AddamounttorecipientidToForgeFightClub[_id].owner=_to;}_safeTransferFrom(_from,_to,_id,_amount);_callonERC1155Received(_from,_to,_id,_amount,gasleft(),_data);}",
    "{super.safeTransferFrom(from,to,id,amount,data);}",
    "{//bytes4(keccak256(bytes(transferFrom(address,address,uint256))));(boolsuccess,bytesmemorydata)=token.call(abi.encodeWithSelector(0x23b872dd,from,to,value));require(success&&(data.length==0||abi.decode(data,(bool))),Transferfailed);}",
    "{//bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));(boolsuccess,bytesmemorydata)=token.call(abi.encodeWithSelector(0x23b872dd,from,to,value));require(success&&(data.length==0||abi.decode(data,(bool))),\"Transferfailed\");}",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:callerisnotownernorapproved\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);_balances[id][from]=_balances[id][from].sub(amount,\"ERC1155:insufficientbalancefortransfer\");_balances[id][to]=_balances[id][to].add(amount);emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:callerisnotownernorapproved\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");_balances[id][from]=fromBalance-amount;_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{\rrequire(to!=address(0),\"ERC1155:transfertothezeroaddress\");\rrequire(\rfrom==_msgSender()||isApprovedForAll(from,_msgSender()),\r\"ERC1155:callerisnotownernorapproved\"\r);\r\raddressoperator=_msgSender();\r\ruint256fromBalance=_balances[id][from];\rrequire(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");\r_balances[id][from]=fromBalance-amount;\r_balances[id][to]+=amount;\r\remitTransferSingle(operator,from,to,id,amount);\r\r_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);\r}",
    "{\\rrequire(to!=address(0),\"ERC1155:transfertothezeroaddress\");\\rrequire(\\rfrom==_msgSender()||isApprovedForAll(from,_msgSender()),\\r\"ERC1155:callerisnotownernorapproved\"\\r);\\r\\raddressoperator=_msgSender();\\r\\ruint256fromBalance=_balances[id][from];\\rrequire(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");\\r_balances[id][from]=fromBalance-amount;\\r_balances[id][to]+=amount;\\r\\remitTransferSingle(operator,from,to,id,amount);\\r\\r_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);\\r},",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{_transfer(from,to,tokenId);if(to.isContract()&&!_checkContractOnERC721Received(from,to,tokenId,_data)){revertTransferToNonERC721ReceiverImplementer();}}",
    "{require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:callerisnotownernorapproved\");_safeTransferFrom(from,to,id,amount,data);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownernorapproved\");_safeTransfer(from,to,tokenId,data);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownerorapproved\");_safeTransfer(from,to,tokenId,data);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_safeTransfer(from,to,tokenId,_data);}",
    "{transferFrom(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,_data));}",
    "{transferFrom(from,to,tokenId);if(to.code.length!=0)if(!_checkContractOnERC721Received(from,to,tokenId,_data)){revertTransferToNonERC721ReceiverImplementer();}}",
    "{transferFrom(from,to,id);if(!_checkOnERC721Received(from,to,id,data))revertTransferToNonERC721ReceiverImplementer();}",
    "{_callOptionalReturn(token,abi.encodeWithSelector(token.transferFrom.selector,from,to,value));}",
    "{\\rrequire(\\rfrom==_msgSender()||isApprovedForAll(from,_msgSender()),\\r\"ERC1155:callerisnottokenownernorapproved\"\\r);\\r_safeTransferFrom(from,to,id,amount,data);\\r}",
    "{require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:callerisnottokenownerorapproved\");_safeTransferFrom(from,to,id,amount,data);}",
    "{require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:callerisnottokenownernorapproved\");_safeTransferFrom(from,to,id,amount,data);}",
    "{require(_to!=address(0x0),\"cannotsendtozeroaddress\");require(_from==msg.sender||operatorApproval[_from][msg.sender]==true,\"Needoperatorapprovalfor3rdpartytransfers.\");if(isNonFungible(_id)){require(nfOwners[_id]==_from);nfOwners[_id]=_to;uint256baseType=getNonFungibleBaseType(_id);balances[baseType][_from]=balances[baseType][_from].sub(_value);balances[baseType][_to]=balances[baseType][_to].add(_value);}else{balances[_id][_from]=balances[_id][_from].sub(_value);balances[_id][_to]=balances[_id][_to].add(_value);}emitTransferSingle(msg.sender,_from,_to,_id,_value);if(_to.isContract()){_doSafeTransferAcceptanceCheck(msg.sender,_from,_to,_id,_value,_data);}}",
    "{require(_isApprovedOrOwner(_msgSender(),\"\"),\"ERC721:transfercallerisnotownernorapproved\");_safeTransfer(from,to,tokenId,_data);}",
    "{require(_isApprovedOrOwner(_msgSender(),\"\"),\"ERC721:callerisnottokenownernorapproved\");_safeTransfer(from,to,tokenId,data);}",
    "{_callOptionalReturn(tBscen,abi.encodeWithSelector(tBscen.transferFrom.selector,from,to,value));}",
    "{transferFrom(from,to,tokenId);if(to.code.length!=0)if(!_checkContractOnERC721Received(from,to,tokenId,_data)){_revert(TransferToNonERC721ReceiverImplementer.selector);}}",
    "{transferFrom(from,to,tokenId);require(_checkOnERC721Received(from,\"\"),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{require(_isApprovedOrOwner(_msgSender(),\"\"),\"ERC721:callerisnottokenownerorapproved\");_safeTransfer(from,to,tokenId,data);}",
    "{if(!_isApprovedOrOwner(_msgSender(),tokenId)){revertERC721__NotAllowed();}_safeTransfer(from,to,tokenId,data);}"
  ],
  "isApprovedOperatorRole": [
    "",
    "returnhasRole(APPROVED_OPERATOR_ROLE,account);}",
    "{returnhasRole(APPROVED_OPERATOR_ROLE,account);}"
  ],
  "_isApprovedOrOwner": [
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||isApprovedForAll(prevOwnership.addr,_msgSender())||getApproved(tokenId)==_msgSender());returnisApprovedOrOwner;}",
    "{require(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");addressowner=BRC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{addressowner=idToOwner[_tokenId];boolspenderIsOwner=owner==_spender;boolspenderIsApproved=_spender==idToApprovals[_tokenId];boolspenderIsApprovedForAll=(ownerToOperators[owner])[_spender];returnspenderIsOwner||spenderIsApproved||spenderIsApprovedForAll;}",
    "{\\rrequire(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");\\raddressowner=ERC721.ownerOf(tokenId);\\rreturn(spender==owner||getApproved(tokenId)==spender||ERC721.isApprovedForAll(owner,spender));\\r}",
    "{require(_exists(tokenId),'ERC721:operatorqueryfornonexistenttoken');addressowner=ERC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{returnsuper._isApprovedOrOwner(spender,tokenId)||super.isApprovedOperatorRole(spender);}",
    "{\\rrequire(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");\\raddressowner=ERC721.ownerOf(tokenId);\\rreturn(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));\\r}",
    "{\\rrequire(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");\\raddressowner=ERC721.ownerOf(tokenId);\\rreturn(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));\\r}",
    "{addressowner=ERC721.ownerOf(tokenId);return(spender==owner||isApprovedForAll(owner,spender)||getApproved(tokenId)==spender);}",
    "{require(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||ERC721.isApprovedForAll(owner,spender));}",
    "{require(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{addressowner=ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{require(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||isApprovedForAll(owner,spender)||getApproved(tokenId)==spender);}",
    "{require(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");addressowner=ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{\\rreturnsuper._isApprovedOrOwner(spender,tokenId)||super.isApprovedOperatorRole(spender);\\r}",
    "{require(_exists(tokenId),\"\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{require(_exists(tokenId),\"\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||ERC721.isApprovedForAll(owner,spender));}",
    "{require(_exists(tokenId),\"\");addressowner=ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{require(_exists(tokenId),\"\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||isApprovedForAll(owner,spender)||getApproved(tokenId)==spender);}",
    "{addressowner=CHECKS721.ownerOf(tokenId);return(spender==owner||isApprovedForAll(owner,spender)||getApproved(tokenId)==spender);}"
  ],
  "isApprovedForAll": [
    "{return_operatorApprovals[owner][operator];}\n      transferFrom {//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownerorapproved\");_transfer(from,to,tokenId);}",
    "{return_operatorApprovals[owner][operator];}transferFrom {//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownerorapproved\");_transfer(from,to,tokenId);}",
    "{return(ownerToOperators[_owner])[_operator];}",
    "{return_operatorApprovals[owner][operator];}transferFrom {//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),'ERC721:transfercallerisnotownernorapproved');_transfer(from,to,tokenId);}",
    "{returnLibTerminus.terminusStorage().globalOperatorApprovals[account][operator];}",
    "{\\rreturn_operatorApprovals[owner][operator];\\r}",
    "{returnownerToOperators[_owner][_operator];}",
    "{returnoperators[_owner][_operator];}",
    "{\\rreturn_operatorApprovals[account][operator];\\r}",
    "{return_operatorApprovals[account][operator];}",
    "{return_operatorApprovals[owner][operator];}",
    "{returns.operators[owner][operator];}",
    "{returnoperatorApproval[_owner][_operator];}",
    "{returnERC721.isApprovedForAll(account,operator)&&ERC1155.isApprovedForAll(account,operator);}"
  ],
  "getApproved": [
    "{require(exists(tokenId),\"ERC721:approvedqueryfornonexistenttoken\");return_tokenApprovals[tokenId];}",
    "{returnidToApprovals[_tokenId];}",
    "{require(_exists(tokenId),'ERC721:approvedqueryfornonexistenttoken');return_tokenApprovals[tokenId];}",
    "{require(exists(tokenId),\"ERC721:approvedqueryfornonexistenttoken\");returnerc721Storage().tokenApprovals[tokenId];}",
    "{if(!_exists(tokenId))_revert(ApprovalQueryForNonexistentToken.selector);return_tokenApprovals[tokenId].value;}",
    "{\\rrequire(_exists(tokenId),\"ERC721:approvedqueryfornonexistenttoken\");\\r\\rreturn_tokenApprovals[tokenId];\\r}",
    "{returnidToApproval[_tokenId];}",
    "{require(_exists(tokenId),\"ERC721A:approvedqueryfornonexistenttoken\");return_tokenApprovals[tokenId];}",
    "{_requireMinted(tokenId);return_tokenApprovals[tokenId];}",
    "{require(_exists(tokenId),\"ERC721:approvedqueryfornonexistenttoken\");return_tokenApprovals[tokenId];}",
    "{require(_exists(tokenId));return_tokenApprovals[tokenId];}",
    "{if(!_exists(tokenId))revertApprovalQueryForNonexistentToken();return_tokenApprovals[tokenId].value;}",
    "{if(!_exists(tokenId))revertApprovalQueryForNonexistentToken();return_tokenApprovals[tokenId];}",
    "{if(!_exists(tokenId))revertApprovalQueryForNonexistentToken();return_tokenApprovals[tokenId].value;}",
    "{if(!_exists(tokenId))revertApprovalQueryForNonexistentToken();return_tokenApprovals[tokenId];}",
    "{uint256owner=s.owners[tokenId];require(_tokenExists(owner),\"ERC721:non-existingtoken\");if(_tokenHasApproval(owner)){returns.approvals[tokenId];}else{returnaddress(0);}}",
    "{require(_exists(tokenId),\"\");return_tokenApprovals[tokenId];}"
  ],
  "_safeTransfer": [
    "",
    "{_transfer(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,_data),'ERC721:transfertononERC721Receiverimplementer');}",
    "{\\r_transfer(from,to,tokenId);\\rrequire(_checkOnERC721Received(from,to,tokenId,_data),\"ERC721:transfertononERC721Receiverimplementer\");\\r}",
    "{_transfer(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,data),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{_transfer(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,_data),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{addresstokenOwner=idToOwner[_tokenId];require(tokenOwner==_from,\"Incorrectowner.\");require(_to!=address(0));_transfer(_to,_tokenId);if(isContract(_to)){bytes4retval=ERC721TokenReceiver(_to).onERC721Received(msg.sender,_from,_tokenId,_data);require(retval==MAGIC_ON_ERC721_RECEIVED);}}",
    "{_transfer(from,to,tokenId);require(_checkOnERC721Received(from,\"\"),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{_transfer(from,to,tokenId);if(!_checkOnERC721Received(from,to,tokenId,data)){revertERC721__TransferToNonReceiver();}}"
  ],
  "TokenOwnership": [""],
  "_clearApproval": [
    "{//Throwsif`_owner`isnotthecurrentownerassert(idToOwner[_tokenId]==_owner);if(idToApprovals[_tokenId]!=address(0)){//ResetapprovalsidToApprovals[_tokenId]=address(0);}}",
    "{if(idToApproval[_tokenId]!=address(0)){deleteidToApproval[_tokenId];}}",
    "{if(_tokenApprovals[tokenId]!=address(0)){_tokenApprovals[tokenId]=address(0);}}"
  ],
  "_removeNFToken": [
    "{require(idToOwner[_tokenId]==_from,\"Incorrectowner.\");deleteidToOwner[_tokenId];uint256tokenToRemoveIndex=idToOwnerIndex[_tokenId];uint256lastTokenIndex=ownerToIds[_from].length.sub(1);if(lastTokenIndex!=tokenToRemoveIndex){uint256lastToken=ownerToIds[_from][lastTokenIndex];ownerToIds[_from][tokenToRemoveIndex]=lastToken;idToOwnerIndex[lastToken]=tokenToRemoveIndex;}ownerToIds[_from].pop();}",
    "{require(idToOwner[_tokenId]==_from,\"\");deleteidToOwner[_tokenId];uint256tokenToRemoveIndex=idToOwnerIndex[_tokenId];uint256lastTokenIndex=ownerToIds[_from].length-1;if(lastTokenIndex!=tokenToRemoveIndex){uint256lastToken=ownerToIds[_from][lastTokenIndex];ownerToIds[_from][tokenToRemoveIndex]=lastToken;idToOwnerIndex[lastToken]=tokenToRemoveIndex;}ownerToIds[_from].pop();}"
  ],
  "_addNFToken": [
    "{require(idToOwner[_tokenId]==address(0),\"Cannotadd,alreadyowned.\");idToOwner[_tokenId]=_to;ownerToIds[_to].push(_tokenId);idToOwnerIndex[_tokenId]=ownerToIds[_to].length.sub(1);}",
    "{require(idToOwner[_tokenId]==address(0),\"\");idToOwner[_tokenId]=_to;ownerToIds[_to].push(_tokenId);idToOwnerIndex[_tokenId]=ownerToIds[_to].length-1;}"
  ],
  "_afterTokenTransfers": ["{}", ""],
  "_transfer": [
    "{//Sincethenumberofkittensiscappedto2^32wecan'toverflowthisownershipTokenCount[_to]++;//transferownershipkittyIndexToOwner[_tokenId]=_to;//Whencreatingnewkittens_fromis0x0,butwecan'taccountthataddress.if(_from!=address(0)){ownershipTokenCount[_from]--;//oncethekittenistransferredalsoclearsireallowancesdeletesireAllowedToAddress[_tokenId];//clearanypreviouslyapprovedownershipexchangedeletekittyIndexToApproved[_tokenId];}//Emitthetransferevent.Transfer(_from,_to,_tokenId);}",
    "{require(ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);}",
    "{require(_owners[id]==from);require(from==operator||getApproved(id)==operator||isApprovedForAll(from,operator),\"Error:callerisneitherownernorapproved\");_beforeTokenTransfer(from,to,id);//Transfer._balances[from]-=1;_balances[to]+=1;_owners[id]=to;emitTransfer(from,to,id);_tokenApprovals[id]=address(0);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId,1);//CheckthattokenIdwasnottransferredby`_beforeTokenTransfer`hookrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");//Clearapprovalsfromthepreviousownerdelete_tokenApprovals[tokenId];unchecked{//`_balances[from]`cannotoverflowforthesamereasonasdescribedin`_burn`://`from`'sbalanceisthenumberoftokenheld,whichisatleastonebeforethecurrent//transfer.//`_balances[to]`couldoverflowintheconditionsdescribedin`_mint`.Thatwouldrequire//all2**256tokenidstobeminted,whichinpracticeisimpossible._balances[from]-=1;_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId,1);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId,1);//CheckthattokenIdwasnottransferredby_beforeTokenTransferhookrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");//Clearapprovalsfromthepreviousownerdelete_tokenApprovals[tokenId];unchecked{//_balances[from]cannotoverflowforthesamereasonasdescribedin_burn://from'sbalanceisthenumberoftokenheld,whichisatleastonebeforethecurrent//transfer.//_balances[to]couldoverflowintheconditionsdescribedin_mint.Thatwouldrequire//all2**256tokenidstobeminted,whichinpracticeisimpossible._balances[from]-=1;_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId,1);}",
    "{require(BRC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);}",
    "{\\rrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");\\rrequire(to!=address(0),\"ERC721:transfertothezeroaddress\");\\r\\r_beforeTokenTransfer(from,to,tokenId);\\r\\r_approve(address(0),tokenId);\\r\\r_holderTokens[from].remove(tokenId);\\r_holderTokens[to].add(tokenId);\\r\\r_tokenOwners.set(tokenId,to);\\r\\remitTransfer(from,to,tokenId);\\r}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");delete_tokenApprovals[tokenId];_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId);}",
    "{\\rrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");\\rrequire(to!=address(0),\"ERC721:transfertothezeroaddress\");\\r\\r_beforeTokenTransfer(from,to,tokenId);\\r\\r_approve(address(0),tokenId);\\r\\r_balances[from]-=1;\\r_balances[to]+=1;\\r_owners[tokenId]=to;\\r\\remitTransfer(from,to,tokenId);\\r\\r_afterTokenTransfer(from,to,tokenId);\\r}",
    "{require(ERC721.ownerOf(tokenId)==from,'ERC721:transferoftokenthatisnotown');require(to!=address(0),'ERC721:transfertothezeroaddress');_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId,1);//CheckthattokenIdwasnottransferredby_beforeTokenTransferhookrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");//Clearapprovalsfromthepreviousownerdelete_tokenApprovals[tokenId];unchecked{//_balances[from]cannotoverflowforthesamereasonasdescribedin_burn://from'sbalanceisthenumberoftokenheld,whichisatleastonebeforethecurrent//transfer.//_balances[to]couldoverflowintheconditionsdescribedin_mint.Thatwouldrequire//all2**256tokenidstobeminted,whichinpracticeisimpossible._balances[from]-=1;_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId,1);}",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||isApprovedForAll(prevOwnership.addr,_msgSender())||getApproved(tokenId)==_msgSender());if(!isApprovedOrOwner)revertTransferCallerNotOwnerNorApproved();if(prevOwnership.addr!=from)revertTransferFromIncorrectOwner();if(to==address(0))revertTransferToZeroAddress();_beforeTokenTransfers(from,to,tokenId,1);_approve(address(0),tokenId,prevOwnership.addr);unchecked{_addressData[from].balance-=1;_addressData[to].balance+=1;_ownerships[tokenId].addr=to;_ownerships[tokenId].startTimestamp=uint64(block.timestamp);uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(nextTokenId<_currentIndex){_ownerships[nextTokenId].addr=prevOwnership.addr;_ownerships[nextTokenId].startTimestamp=prevOwnership.startTimestamp;}}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);}",
    "{\\rrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");\\rrequire(to!=address(0),\"ERC721:transfertothezeroaddress\");\\r\\r_beforeTokenTransfer(from,to,tokenId);\\r\\r_approve(address(0),tokenId);\\r\\r_balances[from]-=1;\\r_balances[to]+=1;\\r_owners[tokenId]=to;\\r\\remitTransfer(from,to,tokenId);\\r}",
    "{addressfrom=idToOwner[_tokenId];_clearApproval(_tokenId);_removeNFToken(from,_tokenId);_addNFToken(_to,_tokenId);emitTransfer(from,_to,_tokenId);}",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||getApproved(tokenId)==_msgSender()||isApprovedForAll(prevOwnership.addr,_msgSender()));require(isApprovedOrOwner,\"ERC721A:transfercallerisnotownernorapproved\");require(prevOwnership.addr==from,\"ERC721A:transferfromincorrectowner\");require(to!=address(0),\"ERC721A:transfertothezeroaddress\");_beforeTokenTransfers(from,to,tokenId,1);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId,prevOwnership.addr);_addressData[from].balance-=1;_addressData[to].balance+=1;_ownerships[tokenId]=TokenOwnership(to,uint64(block.timestamp));//IftheownershipslotoftokenId+1isnotexplicitlyset,thatmeansthetransferinitiatorownsit.//SettheslotoftokenId+1explicitlyinstoragetomaintaincorrectnessforownerOf(tokenId+1)calls.uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(_exists(nextTokenId)){_ownerships[nextTokenId]=TokenOwnership(prevOwnership.addr,prevOwnership.startTimestamp);}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{TokenOwnershipmemoryprevOwnership=_ownershipOf(tokenId);if(prevOwnership.addr!=from)revertTransferFromIncorrectOwner();boolisApprovedOrOwner=(_msgSender()==from||isApprovedForAll(from,_msgSender())||getApproved(tokenId)==_msgSender());if(!isApprovedOrOwner)revertTransferCallerNotOwnerNorApproved();if(to==address(0))revertTransferToZeroAddress();_beforeTokenTransfers(from,to,tokenId,1);_approve(address(0),tokenId,from);unchecked{_addressData[from].balance-=1;_addressData[to].balance+=1;TokenOwnershipstoragecurrSlot=_ownerships[tokenId];currSlot.addr=to;currSlot.startTimestamp=uint64(block.timestamp);uint256nextTokenId=tokenId+1;TokenOwnershipstoragenextSlot=_ownerships[nextTokenId];if(nextSlot.addr==address(0)){if(nextTokenId!=_currentIndex){nextSlot.addr=from;nextSlot.startTimestamp=prevOwnership.startTimestamp;}}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||getApproved(tokenId)==_msgSender()||isApprovedForAll(prevOwnership.addr,_msgSender()));require(isApprovedOrOwner,\"ERC721A:transfercallerisnotownernorapproved\");require(prevOwnership.addr==from,\"ERC721A:transferfromincorrectowner\");require(to!=address(0),\"ERC721A:transfertothezeroaddress\");_beforeTokenTransfers(from,to,tokenId,1);_approve(address(0),tokenId,prevOwnership.addr);_addressData[from].balance-=1;_addressData[to].balance+=1;_ownerships[tokenId]=TokenOwnership(to,uint64(block.timestamp));uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(_exists(nextTokenId)){_ownerships[nextTokenId]=TokenOwnership(prevOwnership.addr,prevOwnership.startTimestamp);}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||getApproved(tokenId)==_msgSender()||isApprovedForAll(prevOwnership.addr,_msgSender()));require(isApprovedOrOwner,\"ERC721A:transfercallerisnotownernorapproved\");require(prevOwnership.addr==from,\"ERC721A:transferfromincorrectowner\");require(to!=address(0),\"ERC721A:transfertothezeroaddress\");_beforeTokenTransfers(from,to,tokenId,1);_approve(address(0),tokenId,prevOwnership.addr);_addressData[from].balance-=1;_addressData[to].balance+=1;_ownerships[tokenId]=TokenOwnership(to,uint64(block.timestamp));uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(_exists(nextTokenId)){_ownerships[nextTokenId]=TokenOwnership(prevOwnership.addr,prevOwnership.startTimestamp);}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{}",
    "{require(sender!=address(0),\"ERC20:transferfromthezeroaddress\");require(recipient!=address(0),\"ERC20:transfertothezeroaddress\");_beforeTokenTransfer(sender,recipient,amount);uint256senderBalance=_balances[sender];require(senderBalance>=amount,\"ERC20:transferamountexceedsbalance\");unchecked{_balances[sender]=senderBalance-amount;}_balances[recipient]+=amount;emitTransfer(sender,recipient,amount);_afterTokenTransfer(sender,recipient,amount);}",
    "{require(from!=address(0),\"ERC20:transferfromthezeroaddress\");require(to!=address(0),\"ERC20:transfertothezeroaddress\");_beforeTokenTransfer(from,to,amount);uint256fromBalance=_balances[from];require(fromBalance>=amount,\"ERC20:transferamountexceedsbalance\");unchecked{_balances[from]=fromBalance-amount;//Overflownotpossible:thesumofallbalancesiscappedbytotalSupply,andthesumispreservedby//decrementingthenincrementing._balances[to]+=amount;}emitTransfer(from,to,amount);_afterTokenTransfer(from,to,amount);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId,1);require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");delete_tokenApprovals[tokenId];unchecked{_balances[from]-=1;_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId,1);}",
    "{require(isOwnerOf(from,tokenId),\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_tokens[tokenId].owner=uint160(to);emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);}",
    "{require(from!=address(0),\"ERC20:transferfromthezeroaddress\");require(to!=address(0),\"ERC20:transfertothezeroaddress\");_beforeTokenTransfer(from,to,amount);uint256fromBalance=_balances[from];require(fromBalance>=amount,\"ERC20:transferamountexceedsbalance\");unchecked{_balances[from]=fromBalance-amount;}_balances[to]+=amount;emitTransfer(from,to,amount);_afterTokenTransfer(from,to,amount);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");//internalownerrequire(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");//internalownerrequire(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);}",
    "{require(ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"\");require(to!=address(0),\"\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"\");require(to!=address(0),\"\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"\");require(to!=address(0),\"\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"\");require(to!=address(0),\"\");_beforeTokenTransfer(from,to,tokenId,1);require(ERC721.ownerOf(tokenId)==from,\"\");delete_tokenApprovals[tokenId];unchecked{_balances[from]-=1;_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId,1);}",
    "{if(CHECKS721.ownerOf(tokenId)!=from){revertERC721__InvalidOwner();}if(to==address(0)){revertERC721__TransferToZero();}_beforeTokenTransfer(from,to,tokenId,1);if(CHECKS721.ownerOf(tokenId)!=from){revertERC721__InvalidOwner();}delete_tokenApprovals[tokenId];unchecked{_balances[from]-=1;_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId,1);}"
  ],
  "_beforeTokenTransfer": [
    "{if(from==address(0)){_addTokenToAllTokensEnumeration(tokenId);}elseif(from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to==address(0)){_removeTokenFromAllTokensEnumeration(tokenId);}elseif(to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{}",
    "{\\rsuper._beforeTokenTransfer(from,to,tokenId);\\r\\rif(from==address(0)){\\r_addTokenToAllTokensEnumeration(tokenId);\\r}elseif(from!=to){\\r_removeTokenFromOwnerEnumeration(from,tokenId);\\r}\\rif(to==address(0)){\\r_removeTokenFromAllTokensEnumeration(tokenId);\\r}elseif(to!=from){\\r_addTokenToOwnerEnumeration(to,tokenId);\\r}\\r}",
    "{super._beforeTokenTransfer(_from,_to,_tokenId);}",
    "{\\rif(beforeTokenTransferHandler!=address(0)){\\rIERC721BeforeTokenTransferHandlerhandlerRef=IERC721BeforeTokenTransferHandler(\\rbeforeTokenTransferHandler\\r);\\rhandlerRef.beforeTokenTransfer(\\raddress(this),\\r_msgSender(),\\rfrom,\\rto,\\rfirstTokenId,\\rbatchSize\\r);\\r}\\r\\rfor(uint256idx=0;idx<batchSize;idx++){\\ruint256tokenId=firstTokenId+idx;\\ruint32lastTransferTime=lastTransfer[tokenId];\\ruint32currentTime=SafeCast.toUint32(block.timestamp);\\rif(lastTransferTime>0){\\r_timeHeld[tokenId][from]+=(currentTime-lastTransferTime);\\r}\\rlastTransfer[tokenId]=currentTime;\\r}\\r\\rsuper._beforeTokenTransfer(from,to,firstTokenId,batchSize);\\r}",
    "{super._beforeTokenTransfer(from,to,tokenId);if(tradingPaused)require(from==address(0),\"Thetradingofthistokenispausedatthemoment\");}",
    "{\rif(isTokenRented(tokenId)){\rrequire(super.isApprovedOperatorRole(_msgSender()),\"Transferofrentedtokenallowedonlybytheapprovedoperatorrole\");\r}\rsuper._beforeTokenTransfer(from,to,tokenId);\r}",
    " {\\rif(beforeTokenTransferHandler!=address(0)){\\rIERC1155BeforeTokenTransferHandlerhandlerRef=IERC1155BeforeTokenTransferHandler(\\rbeforeTokenTransferHandler\\r);\\rhandlerRef.beforeTokenTransfer(\\raddress(this),\\roperator,\\rfrom,\\rto,\\rids,\\ramounts,\\rdata\\r);\\r}\\r\\rsuper._beforeTokenTransfer(operator,from,to,ids,amounts,data);\\r}",
    "{if(rentedTokensLandlords[tokenId]!=address(0)){require(super.isApprovedOperatorRole(_msgSender()),\"Transferofrentedtokenallowedonlybytheapprovedoperatorrole\");}super._beforeTokenTransfer(from,to,tokenId);}",
    "{uint256[]storagesenderTokenList=allTokens[from];for(uint256i;i<ids.length;i++){//addtransferredtokento'to'usertokenlistallTokens[to].push(ids[i]);//findandremovethetransferredtokenfromthe'from'usertokenlist//thecodebelowfindsthetokenid,movesthelasttokentofoundindex//anddecreasesthearraylength.So,theallTokensisanunorderedarrayoftokens.for(uint256j;j<senderTokenList.length;j++){if(senderTokenList[j]==ids[i]){senderTokenList[j]=senderTokenList[senderTokenList.length-1];senderTokenList.pop();}}}}",
    "{if(beforeTokenTransferHandler!=address(0)){IERC721BeforeTokenTransferHandlerhandlerRef=IERC721BeforeTokenTransferHandler(beforeTokenTransferHandler);handlerRef.beforeTokenTransfer(address(this),_msgSender(),from,to,firstTokenId,batchSize);}for(uint256idx=0;idx<batchSize;idx++){uint256tokenId=firstTokenId+idx;uint32lastTransferTime=lastTransfer[tokenId];uint32currentTime=SafeCast.toUint32(block.timestamp);if(lastTransferTime>0){_timeHeld[tokenId][from]+=(currentTime-lastTransferTime);}lastTransfer[tokenId]=currentTime;}super._beforeTokenTransfer(from,to,firstTokenId,batchSize);}",
    "{super._beforeTokenTransfer(from,to,firstTokenId,batchSize);if(batchSize>1){revert(\"ERC721Enumerable:consecutivetransfersnotsupported\");}uint256tokenId=firstTokenId;if(from==address(0)){_addTokenToAllTokensEnumeration(tokenId);}elseif(from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to==address(0)){_removeTokenFromAllTokensEnumeration(tokenId);}elseif(to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{require(!frozenAccount[from],\"frozenaccount\");require(!frozenToken[tokenId],\"frozentoken\");super._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,amount);}",
    "{super._beforeTokenTransfer(from,to,tokenId);if(from!=address(0)&&from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to!=address(0)&&to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{super._beforeTokenTransfer(operator,from,to,nftIds,amounts,data);}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);for(uint256i=0;i<ids.length;i++){if(from!=address(0)&&balanceOf(from,ids[i])<=amounts[i])_ownedTokens[from].remove(ids[i]);if(to!=address(0)&&balanceOf(to,ids[i])==0)_ownedTokens[to].add(ids[i]);}_players.add(from);_players.add(to);}",
    "{require(whitelisted[from],\"!fromnotwhitelisted\");require(whitelisted[to],\"!tonotwhitelisted\");super._beforeTokenTransfer(operator,from,to,ids,amounts,data);}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);if(from==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]+=amounts[i];}}if(to==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]-=amounts[i];}}}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);if(from==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]+=amounts[i];}}if(to==address(0)){for(uint256i=0;i<ids.length;++i){uint256id=ids[i];uint256amount=amounts[i];uint256supply=_totalSupply[id];require(supply>=amount,\"ERC1155:burnamountexceedstotalSupply\");unchecked{_totalSupply[id]=supply-amount;}}}}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);}",
    "{\\rsuper._beforeTokenTransfer(operator,from,to,ids,amounts,data);\\r}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);require(!paused(),\"ERC1155Pausable:tokentransferwhilepaused\");}",
    "{}",
    "{super._beforeTokenTransfer(from,to,tokenId);}",
    "{if(batchSize>1){if(from!=address(0)){_balances[from]-=batchSize;}if(to!=address(0)){_balances[to]+=batchSize;}}}",
    "{ERC721Enumerable._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,tokenId);if(from==address(0)){_addTokenToAllTokensEnumeration(tokenId);}elseif(from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to==address(0)){_removeTokenFromAllTokensEnumeration(tokenId);}elseif(to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{super._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,tokenId);require(!paused(),\"ERC721Pausable:tokentransferwhilepaused\");}"
  ],
  "_beforeTokenTransfers": [
    "{}",
    "{\\rif(isTokenRented(tokenId)){\\rrequire(super.isApprovedOperatorRole(_msgSender()),\"Transferofrentedtokenallowedonlybytheapprovedoperatorrole\");\\r}\\rsuper._beforeTokenTransfer(from,to,tokenId);\\r}",
    "{\\rif(isTokenRented(tokenId)){\\rrequire(super.isApprovedOperatorRole(_msgSender()),\"Transferofrentedtokenallowedonlybytheapprovedoperatorrole\");\\r}\\rsuper._beforeTokenTransfer(from,to,tokenId);\\r}",
    "{require(!frozenAccount[from],\"frozenaccount\");require(!frozenToken[tokenId],\"frozentoken\");super._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,amount);}",
    "{super._beforeTokenTransfer(from,to,tokenId);if(from!=address(0)&&from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to!=address(0)&&to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{super._beforeTokenTransfer(operator,from,to,nftIds,amounts,data);}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);for(uint256i=0;i<ids.length;i++){if(from!=address(0)&&balanceOf(from,ids[i])<=amounts[i])_ownedTokens[from].remove(ids[i]);if(to!=address(0)&&balanceOf(to,ids[i])==0)_ownedTokens[to].add(ids[i]);}_players.add(from);_players.add(to);}",
    "{require(whitelisted[from],\"!fromnotwhitelisted\");require(whitelisted[to],\"!tonotwhitelisted\");super._beforeTokenTransfer(operator,from,to,ids,amounts,data);}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);if(from==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]+=amounts[i];}}if(to==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]-=amounts[i];}}}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);if(from==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]+=amounts[i];}}if(to==address(0)){for(uint256i=0;i<ids.length;++i){uint256id=ids[i];uint256amount=amounts[i];uint256supply=_totalSupply[id];require(supply>=amount,\"ERC1155:burnamountexceedstotalSupply\");unchecked{_totalSupply[id]=supply-amount;}}}}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);}",
    "{\\rsuper._beforeTokenTransfer(operator,from,to,ids,amounts,data);\\r}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);require(!paused(),\"ERC1155Pausable:tokentransferwhilepaused\");}",
    "{}",
    "{super._beforeTokenTransfer(from,to,tokenId);}",
    "{if(batchSize>1){if(from!=address(0)){_balances[from]-=batchSize;}if(to!=address(0)){_balances[to]+=batchSize;}}}",
    "{ERC721Enumerable._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,tokenId);if(from==address(0)){_addTokenToAllTokensEnumeration(tokenId);}elseif(from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to==address(0)){_removeTokenFromAllTokensEnumeration(tokenId);}elseif(to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{super._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,tokenId);require(!paused(),\"ERC721Pausable:tokentransferwhilepaused\");}"
  ],
  "_nextExtraData": [
    "{uint24extraData=uint24(prevOwnershipPacked\\u003e\\u003e_BITPOS_EXTRA_DATA);returnuint256(_extraData(from,to,extraData))\\u003c\\u003c_BITPOS_EXTRA_DATA;}",
    "{uint24extraData=uint24(prevOwnershipPacked>>_BITPOS_EXTRA_DATA);returnuint256(_extraData(from,to,extraData))<<_BITPOS_EXTRA_DATA;}"
  ],
  "_getApprovedSlotAndAddress": [
    "{TokenApprovalRefstoragetokenApproval=_tokenApprovals[tokenId];assembly{approvedAddressSlot:=tokenApproval.slotapprovedAddress:=sload(approvedAddressSlot)}}"
  ],
  "_packOwnershipData": [
    "{assembly{owner:=and(owner,_BITMASK_ADDRESS)result:=or(owner,or(shl(_BITPOS_START_TIMESTAMP,timestamp()),flags))}}",
    "{}"
  ],
  "_mintIfNotExist": [
    "{if(msg.sender==_admin){if(!_exists(tokenId)){_mint(_admin,tokenId);}}}",
    "{}"
  ],
  "hookrequire": ["{}"],
  "_baseURI": [
    "{returnbaseURI;}",
    "{}",
    "{_pause();}",
    "{return\"\";}",
    "{return'';}",
    "{returnbaseTokenURI;}"
  ],
  "unsetPause": ["{}", "{_unpause();}"],
  "setPause": [
    "{}",
    "{return\"\";}",
    "{_pause();}",
    "{\\rpaused=_paused;\\r}",
    "{PAUSE=_pause;emitPauseEvent(PAUSE);}"
  ],
  "tokenURI": [
    "{}",
    "{string[17]memoryparts;parts[0]='<svgxmlns=\"http:parts[1]=getWeapon(tokenId);parts[2]='</text><textx=\"10\"y=\"40\"class=\"base\">';parts[3]=getChest(tokenId);parts[4]='</text><textx=\"10\"y=\"60\"class=\"base\">';parts[5]=getHead(tokenId);parts[6]='</text><textx=\"10\"y=\"80\"class=\"base\">';parts[7]=getWaist(tokenId);parts[8]='</text><textx=\"10\"y=\"100\"class=\"base\">';parts[9]=getFoot(tokenId);parts[10]='</text><textx=\"10\"y=\"120\"class=\"base\">';parts[11]=getHand(tokenId);parts[12]='</text><textx=\"10\"y=\"140\"class=\"base\">';parts[13]=getNeck(tokenId);parts[14]='</text><textx=\"10\"y=\"160\"class=\"base\">';parts[15]=getRing(tokenId);parts[16]='</text></svg>';stringmemoryoutput=string(abi.encodePacked(parts[0],parts[1],parts[2],parts[3],parts[4],parts[5],parts[6],parts[7],parts[8]));output=string(abi.encodePacked(output,parts[9],parts[10],parts[11],parts[12],parts[13],parts[14],parts[15],parts[16]));stringmemoryjson=Base64.encode(bytes(string(abi.encodePacked('{\"name\":\"Bag#',toString(tokenId),'\",\"description\":\"MoreLootisadditionalrandomizedadventurergeargeneratedandstoredonchain.Maximumsupplyisdynamic,increasingat1/10thofEthereum\\'sblockrate.Stats,images,andotherfunctionalityareintentionallyomittedforotherstointerpret.FeelfreetouseMoreLootinanywayyouwant.\",\"image\":\"data:image/svg+xml;base64,',Base64.encode(bytes(output)),'\"}'))));output=string(abi.encodePacked('data:application/json;base64,',json));returnoutput;}",
    "{require(_exists(tokenId),\"ERC721Metadata:URIqueryfornonexistenttoken\");stringmemorycurrentBaseURI=_baseURI();returnbytes(currentBaseURI).length>0?string(abi.encodePacked(currentBaseURI,tokenId.toString(),baseExtension)):\"\";}",
    "{require(_exists(tokenId),\"ERC721Metadata:URIqueryfornonexistenttoken\");stringmemorybaseURI=_baseURI();returnbytes(baseURI).length>0?string(abi.encodePacked(baseURI,tokenId.toString())):'';}",
    "{if(!_exists(tokenId))revertURIQueryForNonexistentToken();stringmemorybaseURI=_baseURI();returnbytes(baseURI).length!=0?string(abi.encodePacked(baseURI,tokenId.toString())):'';}",
    "{require(_exists(tokenId),\"\");stringmemory_tokenURI=_tokenURIs[tokenId];stringmemorybase=baseURI();if(bytes(base).length==0){return_tokenURI;}if(bytes(_tokenURI).length>0){returnstring(abi.encodePacked(base,_tokenURI));}returnstring(abi.encodePacked(base,tokenId.toString()));}",
    "{returnidToUri[_tokenId];}",
    "{require(_exists(tokenId),\"\");stringmemorybaseURI=_baseURI();returnbytes(baseURI).length>0?string(abi.encodePacked(baseURI,tokenId.toString())):\"\";}",
    "{_requireMinted(tokenId);stringmemorybaseURI=_baseURI();returnbytes(baseURI).length>0?string(abi.encodePacked(baseURI,tokenId.toString())):\"\";}",
    "{if(!_exists(tokenId))revertURIQueryForNonexistentToken();stringmemorybaseURI=_baseURI();returnbytes(baseURI).length!=0?string(abi.encodePacked(baseURI,_toString(tokenId))):'';}",
    "{if(!_exists(tokenId))revertURIQueryForNonexistentToken();stringmemorybaseURI=_baseURI();if(bytes(baseURI).length==0){return'';}if(openBoxTime==0||openBoxTime>block.timestamp){if(bytes(openBoxBeforeTokenURI).length==0){return'';}returnstring(abi.encodePacked(baseURI,openBoxBeforeTokenURI));}else{stringmemorytoken_uri=_tokenURI[tokenId];returnstring(abi.encodePacked(baseURI,token_uri));}}",
    "{if(!_exists(tokenID))_revert(URIQueryForNonexistentToken.selector);if(bytes(privateURI[tokenID]).length!=0){returnprivateURI[tokenID];}returnbytes(baseURI).length!=0?string(abi.encodePacked(baseURI,_toString(tokenID))):'';}",
    "{if(bytes(staticIpfsImageLink[_tokenId]).length>0){returnStrings.strConcat(projects[tokenIdToProjectId[_tokenId]].projectBaseIpfsURI,staticIpfsImageLink[_tokenId]);}if(!projects[tokenIdToProjectId[_tokenId]].dynamic&&projects[tokenIdToProjectId[_tokenId]].useIpfs){returnStrings.strConcat(projects[tokenIdToProjectId[_tokenId]].projectBaseIpfsURI,projects[tokenIdToProjectId[_tokenId]].ipfsHash);}returnStrings.strConcat(projects[tokenIdToProjectId[_tokenId]].projectBaseURI,Strings.uint2str(_tokenId));}",
    "{_requireMinted(tokenId);return\"\";}"
  ],
  "MintToZeroAddress": ["{}"],
  "MintZeroQuantity": ["{}"],
  "_mint": [
    "{require(to!=address(0),\"ERC1155:minttothezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,address(0),to,_asSingletonArray(id),_asSingletonArray(amount),data);_balances[id][to]+=amount;emitTransferSingle(operator,address(0),to,id,amount);_doSafeTransferAcceptanceCheck(operator,address(0),to,id,amount,data);}",
    "{require(to!=address(0),\"INVALID_RECIPIENT\");require(ownerOf[id]==address(0),\"ALREADY_MINTED\");//Counteroverflowisincrediblyunrealistic.unchecked{balanceOf[to]++;}ownerOf[id]=to;emitTransfer(address(0),to,id);}",
    "{require(to!=address(0));require(!_exists(tokenId));_tokenOwner[tokenId]=to;_ownedTokensCount[to]=_ownedTokensCount[to].add(1);emitTransfer(address(0),to,tokenId);}",
    "{uint256startTokenId=_currentIndex;if(to==address(0))revertMintToZeroAddress();if(quantity==0)revertMintZeroQuantity();_beforeTokenTransfers(address(0),to,startTokenId,quantity);unchecked{_addressData[to].balance+=uint64(quantity);_addressData[to].numberMinted+=uint64(quantity);_ownerships[startTokenId].addr=to;_ownerships[startTokenId].startTimestamp=uint64(block.timestamp);uint256updatedIndex=startTokenId;for(uint256i;i<quantity;i++){emitTransfer(address(0),to,updatedIndex);if(safe&&!_checkOnERC721Received(address(0),to,updatedIndex,_data)){revertTransferToNonERC721ReceiverImplementer();}updatedIndex++;}_currentIndex=updatedIndex;}_afterTokenTransfers(address(0),to,startTokenId,quantity);}",
    "{require(to!=address(0),\"ERC721:minttothezeroaddress\");require(!_exists(tokenId),\"ERC721:tokenalreadyminted\");_beforeTokenTransfer(address(0),to,tokenId,1);//CheckthattokenIdwasnotmintedby`_beforeTokenTransfer`hookrequire(!_exists(tokenId),\"ERC721:tokenalreadyminted\");unchecked{//Willnotoverflowunlessall2**256tokenidsaremintedtothesameowner.//Giventhattokensaremintedonebyone,itisimpossibleinpracticethat//thiseverhappens.Mightchangeifweallowbatchminting.//TheERCfailstodescribethiscase._balances[to]+=1;}_owners[tokenId]=to;emitTransfer(address(0),to,tokenId);_afterTokenTransfer(address(0),to,tokenId,1);}",
    "{require(to!=address(0),\"ERC721:minttothezeroaddress\");require(!_exists(tokenId),\"ERC721:tokenalreadyminted\");_beforeTokenTransfer(address(0),to,tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(address(0),to,tokenId);}",
    "{require(to!=address(0),\"ERC721:minttothezeroaddress\");require(!_exists(tokenId),\"ERC721:tokenalreadyminted\");_beforeTokenTransfer(address(0),to,tokenId);_balances[to]+=1;_owners[tokenId]=to;emitTransfer(address(0),to,tokenId);}",
    "{require(to!=address(0),\"\");require(!_exists(tokenId),\"\");_beforeTokenTransfer(address(0),to,tokenId);_balances[to]+=1;_owners[tokenId]=to;emitTransfer(address(0),to,tokenId);}",
    "{require(to!=address(0),\"\");require(!_exists(tokenId),\"\");_beforeTokenTransfer(address(0),to,tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(address(0),to,tokenId);}",
    "{super._mint(_to,_tokenId);tokens.push(_tokenId);idToIndex[_tokenId]=tokens.length-1;}",
    "{require(to!=address(0),\"\");require(!_exists(tokenId),\"\");_beforeTokenTransfer(address(0),to,tokenId);_balances[to]+=1;_owners[tokenId]=to;emitTransfer(address(0),to,tokenId);_afterTokenTransfer(address(0),to,tokenId);}",
    "{uint256startTokenId=_currentIndex;if(quantity==0)revertMintZeroQuantity();_beforeTokenTransfers(address(0),to,startTokenId,quantity);unchecked{_packedAddressData[to]+=quantity*((1<<_BITPOS_NUMBER_MINTED)|1);_packedOwnerships[startTokenId]=_packOwnershipData(to,_nextInitializedFlag(quantity)|_nextExtraData(address(0),to,0));uint256toMasked;uint256end=startTokenId+quantity;assembly{toMasked:=and(to,_BITMASK_ADDRESS)log4(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,startTokenId)for{lettokenId:=add(startTokenId,1)}iszero(eq(tokenId,end)){tokenId:=add(tokenId,1)}{log4(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)}}if(toMasked==0)revertMintToZeroAddress();_currentIndex=end;}_afterTokenTransfers(address(0),to,startTokenId,quantity);}",
    "{uint256startTokenId=_currentIndex;if(quantity==0)_revert(MintZeroQuantity.selector);_beforeTokenTransfers(address(0),to,startTokenId,quantity);unchecked{_packedOwnerships[startTokenId]=_packOwnershipData(to,_nextInitializedFlag(quantity)|_nextExtraData(address(0),to,0));_packedAddressData[to]+=quantity*((1<<_BITPOS_NUMBER_MINTED)|1);uint256toMasked=uint256(uint160(to))&_BITMASK_ADDRESS;if(toMasked==0)_revert(MintToZeroAddress.selector);uint256end=startTokenId+quantity;uint256tokenId=startTokenId;do{assembly{log4(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)}}while(++tokenId!=end);_currentIndex=end;}_afterTokenTransfers(address(0),to,startTokenId,quantity);}",
    "{super._mint(to,tokenId);_addTokenToOwnerEnumeration(to,tokenId);_addTokenToAllTokensEnumeration(tokenId);}",
    "{require(to!=address(0),\"\");require(!_exists(tokenId),\"\");_beforeTokenTransfer(address(0),to,tokenId,1);require(!_exists(tokenId),\"\");unchecked{_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(address(0),to,tokenId);_afterTokenTransfer(address(0),to,tokenId,1);}",
    "{_mintState(to,tokenId);emitTransfer(address(0),to,tokenId);_afterTokenTransfer(address(0),to,tokenId,1);}"
  ],
  "transferFrom": [
    "{require(from==ownerOf[id],\"WRONG_FROM\");require(to!=address(0),\"INVALID_RECIPIENT\");require(msg.sender==from||msg.sender==getApproved[id]||isApprovedForAll[from][msg.sender],\"NOT_AUTHORIZED\");//Underflowofthesender'sbalanceisimpossiblebecausewecheckfor//ownershipaboveandtherecipient'sbalancecan'trealisticallyoverflow.unchecked{balanceOf[from]--;balanceOf[to]++;}ownerOf[id]=to;deletegetApproved[id];emitTransfer(from,to,id);}",
    "{if(_msgSender()!=address(barn))require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_transfer(from,to,tokenId);}",
    "{require(_isApprovedOrOwner(msg.sender,tokenId));_transferFrom(from,to,tokenId);}",
    "{//Safetychecktopreventagainstanunexpected0x0default.require(_to!=address(0));//Disallowtransferstothiscontracttopreventaccidentalmisuse.//Thecontractshouldneverownanykitties(exceptverybriefly//afteragen0catiscreatedandbeforeitgoesonauction).require(_to!=address(this));//Checkforapprovalandvalidownershiprequire(_approvedFor(msg.sender,_tokenId));require(_owns(_from,_tokenId));//Reassignownership(alsoclearspendingapprovalsandemitsTransferevent)._transfer(_from,_to,_tokenId);}",
    "{//Pretransferchecks.addressoperator=_msgSender();require(!paused(),\"Error:tokentransferwhilepaused\");_transfer(from,to,operator,id);}",
    "{//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownerorapproved\");_transfer(from,to,tokenId);}",
    "{_mintIfNotExist(tokenId);require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_transfer(from,to,tokenId);}",
    "{_transferFrom(_from,_to,_tokenId,msg.sender);}",
    "{ERC721.transferFrom(from,to,tokenId);}",
    "{//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),'ERC721:transfercallerisnotownernorapproved');_transfer(from,to,tokenId);}",
    "{require(to!=address(this),\"Recipientcannotbetheaddressofthecontract\");super.transferFrom(from,to,tokenId);rentedTokensLandlords[tokenId]=address(0);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownerorapproved\");_transfer(from,to,tokenId);}",
    "{//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(msg.sender,tokenId),\"ERC721:transfercallerisnotownernorapproved\");_transferFrom(from,to,tokenId);}",
    "{uint256prevOwnershipPacked=_packedOwnershipOf(tokenId);if(address(uint160(prevOwnershipPacked))!=from)revertTransferFromIncorrectOwner();(uint256approvedAddressSlot,addressapprovedAddress)=_getApprovedSlotAndAddress(tokenId);if(!_isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A()))if(!isApprovedForAll(from,_msgSenderERC721A()))revertTransferCallerNotOwnerNorApproved();if(to==address(0))revertTransferToZeroAddress();_beforeTokenTransfers(from,to,tokenId,1);assembly{ifapprovedAddress{sstore(approvedAddressSlot,0)}}unchecked{--_packedAddressData[from];++_packedAddressData[to];_packedOwnerships[tokenId]=_packOwnershipData(to,_BITMASK_NEXT_INITIALIZED|_nextExtraData(from,to,prevOwnershipPacked));if(prevOwnershipPacked\\u0026_BITMASK_NEXT_INITIALIZED==0){uint256nextTokenId=tokenId+1;if(_packedOwnerships[nextTokenId]==0){if(nextTokenId!=_currentIndex){_packedOwnerships[nextTokenId]=prevOwnershipPacked;}}}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{\\rsuper.transferFrom(from,to,tokenId);\\r}",
    "{\\rrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");\\r\\r_transfer(from,to,tokenId);\\r}",
    "{addresstokenOwner=idToOwner[_tokenId];require(tokenOwner==_from,\"Wrongfromaddress.\");require(_to!=address(0),\"Cannotsendto0x0.\");_transfer(_to,_tokenId);}",
    "{_transfer(from,to,tokenId);}",
    "{uint256prevOwnershipPacked=_packedOwnershipOf(tokenId);if(address(uint160(prevOwnershipPacked))!=from)revertTransferFromIncorrectOwner();(uint256approvedAddressSlot,addressapprovedAddress)=_getApprovedSlotAndAddress(tokenId);if(!_isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A()))if(!isApprovedForAll(from,_msgSenderERC721A()))revertTransferCallerNotOwnerNorApproved();if(to==address(0))revertTransferToZeroAddress();_beforeTokenTransfers(from,to,tokenId,1);assembly{ifapprovedAddress{sstore(approvedAddressSlot,0)}}unchecked{--_packedAddressData[from];++_packedAddressData[to];_packedOwnerships[tokenId]=_packOwnershipData(to,_BITMASK_NEXT_INITIALIZED|_nextExtraData(from,to,prevOwnershipPacked));if(prevOwnershipPacked&_BITMASK_NEXT_INITIALIZED==0){uint256nextTokenId=tokenId+1;if(_packedOwnerships[nextTokenId]==0){if(nextTokenId!=_currentIndex){_packedOwnerships[nextTokenId]=prevOwnershipPacked;}}}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{super.transferFrom(from,to,tokenId);}",
    "{require(CanTransfer,\"YouneedTransferToken\");if(!_exists(tokenId))revertOwnerQueryForNonexistentToken();if(ownerOf(tokenId)!=from)revertTransferFromIncorrectOwner();if(to==address(0))revertTransferToZeroAddress();boolisApprovedOrOwner=(msg.sender==from||msg.sender==getApproved(tokenId)||isApprovedForAll(from,msg.sender));if(!isApprovedOrOwner)revertTransferCallerNotOwnerNorApproved();//deletetokenapprovalsfrompreviousownerdelete_tokenApprovals[tokenId];_owners[tokenId]=to;//iftokenIDbelowtransferredoneisntset,setittopreviousowner//iftokenidiszero,skipthistopreventunderflowif(tokenId>0&&_owners[tokenId-1]==address(0)){_owners[tokenId-1]=from;}emitTransfer(from,to,tokenId);}",
    "{_transfer(sender,recipient,amount);uint256currentAllowance=_allowances[sender][_msgSender()];require(currentAllowance>=amount,\"ERC20:transferamountexceedsallowance\");unchecked{_approve(sender,_msgSender(),currentAllowance-amount);}returntrue;}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_transfer(from,to,tokenId);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownernorapproved\");_transfer(from,to,tokenId);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownernorapproved\");_transfer(from,to,tokenId);}",
    "{//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownernorapproved\");_transfer(from,to,tokenId);}",
    "{//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_transfer(from,to,tokenId);}",
    "{addressspender=_msgSender();_spendAllowance(from,spender,amount);_transfer(from,to,amount);returntrue;}",
    "{\\rrequire(to!=address(this),\"Recipientcannotbetheaddressofthecontract\");\\rsuper.transferFrom(from,to,tokenId);\\rrentedTokensLandlords[tokenId]=address(0);\\r}",
    "{require(to!=address(0),\"ERC721:transfertoaddress(0)\");uint256owner=s.owners[tokenId];require(_tokenExists(owner),\"ERC721:non-existingtoken\");require(_tokenOwner(owner)==from,\"ERC721:non-ownedtoken\");if(!_isOperatable(s,from,sender)){require(_tokenHasApproval(owner)&&sender==s.approvals[tokenId],\"ERC721:non-approvedsender\");}s.owners[tokenId]=uint256(uint160(to));if(from!=to){unchecked{--s.balances[from];++s.balances[to];}}emitTransfer(from,to,tokenId);}",
    "{require(_isApprovedOrOwner(_msgSender(),\"\"),\"ERC721:transfercallerisnotownernorapproved\");_transfer(from,to,tokenId);}",
    "{addresstokenOwner=idToOwner[_tokenId];require(tokenOwner==_from,\"\");require(_to!=address(0),\"\");_transfer(_to,_tokenId);}",
    "{require(_isApprovedOrOwner(_msgSender(),\"\"),\"ERC721:callerisnottokenownernorapproved\");_transfer(from,to,tokenId);}",
    "{uint256prevOwnershipPacked=_packedOwnershipOf(tokenId);from=address(uint160(uint256(uint160(from))&_BITMASK_ADDRESS));if(address(uint160(prevOwnershipPacked))!=from)_revert(TransferFromIncorrectOwner.selector);(uint256approvedAddressSlot,addressapprovedAddress)=_getApprovedSlotAndAddress(tokenId);if(!_isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A()))if(!isApprovedForAll(from,_msgSenderERC721A()))_revert(TransferCallerNotOwnerNorApproved.selector);_beforeTokenTransfers(from,to,tokenId,1);assembly{ifapprovedAddress{sstore(approvedAddressSlot,0)}}unchecked{--_packedAddressData[from];++_packedAddressData[to];_packedOwnerships[tokenId]=_packOwnershipData(to,_BITMASK_NEXT_INITIALIZED|_nextExtraData(from,to,prevOwnershipPacked));if(prevOwnershipPacked&_BITMASK_NEXT_INITIALIZED==0){uint256nextTokenId=tokenId+1;if(_packedOwnerships[nextTokenId]==0){if(nextTokenId!=_currentIndex){_packedOwnerships[nextTokenId]=prevOwnershipPacked;}}}}uint256toMasked=uint256(uint160(to))&_BITMASK_ADDRESS;assembly{log4(0,0,_TRANSFER_EVENT_SIGNATURE,from,toMasked,tokenId)}if(toMasked==0)_revert(TransferToZeroAddress.selector);_afterTokenTransfers(from,to,tokenId,1);}",
    "{require(_isApprovedOrOwner(msg.sender,\"\"),\"ERC721:transfercallerisnotownernorapproved\");_transferFrom(from,to,tokenId);}",
    "{require(_isApprovedOrOwner(_msgSender(),\"\"),\"ERC721:callerisnottokenownerorapproved\");_transfer(from,to,tokenId);}",
    "{if(!_isApprovedOrOwner(_msgSender(),tokenId)){revertERC721__NotAllowed();}_transfer(from,to,tokenId);}"
  ],
  "_packedOwnershipOf": [
    "{uint256curr=tokenId;unchecked{if(_startTokenId()<=curr)if(curr<_currentIndex){uint256packed=_packedOwnerships[curr];//Ifnotburned.if(packed&_BITMASK_BURNED==0){//Invariant://Therewillalwaysbeaninitializedownershipslot//(i.e.`ownership.addr!=address(0)&&ownership.burned==false`)//beforeanunintializedownershipslot//(i.e.`ownership.addr==address(0)&&ownership.burned==false`)//Hence,`curr`willnotunderflow.////Wecandirectlycomparethepackedvalue.//Iftheaddressiszero,packedwillbezero.while(packed==0){packed=_packedOwnerships[--curr];}returnpacked;}}}revertOwnerQueryForNonexistentToken();}",
    "{}",
    "{uint256curr=tokenId;unchecked{if(_startTokenId()\\u003c=curr)if(curr\\u003c_currentIndex){uint256packed=_packedOwnerships[curr];if(packed\\u0026_BITMASK_BURNED==0){while(packed==0){packed=_packedOwnerships[--curr];}returnpacked;}}}revertOwnerQueryForNonexistentToken();}",
    "{if(_startTokenId()<=tokenId){packed=_packedOwnerships[tokenId];if(packed&_BITMASK_BURNED==0){if(packed==0){if(tokenId>=_currentIndex)_revert(OwnerQueryForNonexistentToken.selector);for(;;){unchecked{packed=_packedOwnerships[--tokenId];}if(packed==0)continue;returnpacked;}}returnpacked;}}_revert(OwnerQueryForNonexistentToken.selector);}",
    "{uint256curr=tokenId;unchecked{if(_startTokenId()<=curr)if(curr<_currentIndex){uint256packed=_packedOwnerships[curr];if(packed&_BITMASK_BURNED==0){while(packed==0){packed=_packedOwnerships[--curr];}returnpacked;}}}revertOwnerQueryForNonexistentToken();}",
    "{if(_startTokenId()<=tokenId){packed=_packedOwnerships[tokenId];if(packed==0){if(tokenId>=_currentIndex)_revert(OwnerQueryForNonexistentToken.selector);for(;;){unchecked{packed=_packedOwnerships[--tokenId];}if(packed==0)continue;if(packed&_BITMASK_BURNED==0)returnpacked;_revert(OwnerQueryForNonexistentToken.selector);}}if(packed&_BITMASK_BURNED==0)returnpacked;}_revert(OwnerQueryForNonexistentToken.selector);}"
  ],
  "OwnerQueryForNonexistentToken": ["{}", ""],
  "skipthistopreventunderflowif": ["{}", ""],
  "_ownershipOf": [
    "{return_unpackedOwnership(_packedOwnershipOf(tokenId));}",
    "{}",
    "",
    "{uint256curr=tokenId;unchecked{if(_startTokenId()<=curr&&curr<_currentIndex){TokenOwnershipmemoryownership=_ownerships[curr];if(!ownership.burned){if(ownership.addr!=address(0)){returnownership;}while(true){curr--;ownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}}}}revertOwnerQueryForNonexistentToken();}"
  ],
  "TransferFromIncorrectOwner": ["{}", ""],
  "TransferToZeroAddress": ["{}", ""],
  "isContract": [
    "{uint256size;//XXXCurrentlythereisnobetterwaytocheckifthereisacontractinanaddress//thantocheckthesizeofthecodeatthataddress.//Seehttps://ethereum.stackexchange.com/a/14016/36603//formoredetailsabouthowthisworks.//TODOCheckthisagainbeforetheSerenityrelease,becausealladdresseswillbe//contractsthen.//solhint-disable-next-lineno-inline-assemblyassembly{size:=extcodesize(account)}returnsize>0;}",
    "{\\r\\ruint256size;\\rassembly{size:=extcodesize(account)}\\rreturnsize>0;\\r}",
    "{\\r\\rreturnaccount.code.length\\u003e0;\\r}",
    "{\\r\\ruint256size;\\rassembly{\\rsize:=extcodesize(account)\\r}\\rreturnsize>0;\\r}",
    "{//Thismethodreliesinextcodesize,whichreturns0forcontractsin//construction,sincethecodeisonlystoredattheendofthe//constructorexecution.uint256size;//solhint-disable-next-lineno-inline-assemblyassembly{size:=extcodesize(account)}returnsize>0;}",
    "{uint256size;assembly{size:=extcodesize(_addr)}//solhint-disable-lineaddressCheck=size>0;}",
    "{bytes32codehash;//Currentlythereisnobetterwaytocheckifthereisacontractinanaddress//thantocheckthesizeofthecodeatthataddressorifithasanon-zerocodehashoraccounthashassembly{codehash:=extcodehash(_address)}return(codehash!=0x0&&codehash!=ACCOUNT_HASH);}",
    "{uint256size;assembly{size:=extcodesize(account)}returnsize>0;}",
    "{returnaccount.code.length>0;}",
    "{//Thismethodreliesonextcodesize/address.code.length,whichreturns0//forcontractsinconstruction,sincethecodeisonlystoredattheend//oftheconstructorexecution.returnaccount.code.length>0;}",
    "{//Thismethodreliesonextcodesize,whichreturns0forcontractsin//construction,sincethecodeisonlystoredattheendofthe//constructorexecution.uint256size;assembly{size:=extcodesize(account)}returnsize>0;}",
    "{//Thismethodreliesonextcodesize,whichreturns0forcontractsin//construction,sincethecodeisonlystoredattheendofthe//constructorexecution.uint256size;//solhint-disable-next-lineno-inline-assemblyassembly{size:=extcodesize(account)}returnsize>0;}",
    "{\\t\\t\\t\\tuint256size=0;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tassembly{\\t\\t\\t\\t\\t\\tsize:=extcodesize(addr)\\t\\t}\\t\\t\\t\\treturnsize>0;\\t}",
    "{uint256size;assembly{size:=extcodesize(account)}returnsize\\u003e0;}",
    "{bytes32codehash;bytes32accountHash=0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;assembly{codehash:=extcodehash(_addr)}addressCheck=(codehash!=0x0&&codehash!=accountHash);}"
  ],
  "_requireMinted": [
    "{require(_exists(tokenId),\"ERC721:invalidtokenID\");}",
    "{require(_exists(tokenId),\"\");}",
    "{if(!_exists(tokenId)){revertERC721__InvalidToken();}}"
  ],
  "getNumMinted": ["{return_tokens.length-1;}", "{return_starCount;}"],
  "isOwnerOf": ["", "{}", "{addressowner=ownerOf(id);returnowner==account;}"],
  "paused": [
    "{\\rreturn_paused||_gameRegistry.paused();\\r}",
    "{return_paused||_gameRegistry.paused();}",
    "{}",
    "{return_paused;}",
    "{\\rfor(uint256id;id<items.length;id++){\\ritems[id].isPaused=_isPaused;\\r}\\r}"
  ],
  "_addTokenToAllTokensEnumeration": [
    "{\\r_allTokensIndex[tokenId]=_allTokens.length;\\r_allTokens.push(tokenId);\\r}",
    "{_allTokensIndex[tokenId]=_allTokens.length;_allTokens.push(tokenId);}",
    "{}"
  ],
  "_removeTokenFromOwnerEnumeration": [
    "{//Topreventagapinfrom'stokensarray,westorethelasttokenintheindexofthetokentodelete,and//thendeletethelastslot(swapandpop).uint256lastTokenIndex=balanceOf(from)-1;uint256tokenIndex=_ownedTokensIndex[tokenId];//Whenthetokentodeleteisthelasttoken,theswapoperationisunnecessaryif(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;//Movethelasttokentotheslotoftheto-deletetoken_ownedTokensIndex[lastTokenId]=tokenIndex;//Updatethemovedtoken'sindex}//Thisalsodeletesthecontentsatthelastpositionofthearraydelete_ownedTokensIndex[tokenId];delete_ownedTokens[from][lastTokenIndex];}",
    "{uint256lastTokenIndex=BRC721.balanceOf(from)-1;uint256tokenIndex=_ownedTokensIndex[tokenId];if(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}delete_ownedTokensIndex[tokenId];delete_ownedTokens[from][lastTokenIndex];}",
    "{\\r\\ruint256lastTokenIndex=ERC721.balanceOf(from)-1;\\ruint256tokenIndex=_ownedTokensIndex[tokenId];\\r\\rif(tokenIndex!=lastTokenIndex){\\ruint256lastTokenId=_ownedTokens[from][lastTokenIndex];\\r\\r_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}\\r\\rdelete_ownedTokensIndex[tokenId];\\rdelete_ownedTokens[from][lastTokenIndex];\\r}",
    "{\\r\\ruint256lastTokenIndex=ERC721.balanceOf(from)-1;\\ruint256tokenIndex=_ownedTokensIndex[tokenId];\\r\\rif(tokenIndex!=lastTokenIndex){\\ruint256lastTokenId=_ownedTokens[from][lastTokenIndex];\\r\\r_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}\\r\\rdelete_ownedTokensIndex[tokenId];\\rdelete_ownedTokens[from][lastTokenIndex];\r}",
    "{//Topreventagapinfrom'stokensarray,westorethelasttokenintheindexofthetokentodelete,and//thendeletethelastslot(swapandpop).uint256lastTokenIndex=_ownedTokens[from].length.sub(1);uint256tokenIndex=_ownedTokensIndex[tokenId];//Whenthetokentodeleteisthelasttoken,theswapoperationisunnecessaryif(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;//Movethelasttokentotheslotoftheto-deletetoken_ownedTokensIndex[lastTokenId]=tokenIndex;//Updatethemovedtoken'sindex}//Thisalsodeletesthecontentsatthelastpositionofthearray_ownedTokens[from].length--;//Notethat_ownedTokensIndex[tokenId]hasn'tbeencleared:itstillpointstotheoldslot(nowoccupiedby//lastTokenId,orjustovertheendofthearrayifthetokenwasthelastone).}",
    "{//Topreventagapinfrom'stokensarray,westorethelasttokenintheindexofthetokentodelete,and//thendeletethelastslot(swapandpop).uint256lastTokenIndex=ERC721.balanceOf(from)-1;uint256tokenIndex=_ownedTokensIndex[tokenId];//Whenthetokentodeleteisthelasttoken,theswapoperationisunnecessaryif(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;//Movethelasttokentotheslotoftheto-deletetoken_ownedTokensIndex[lastTokenId]=tokenIndex;//Updatethemovedtoken'sindex}//Thisalsodeletesthecontentsatthelastpositionofthearraydelete_ownedTokensIndex[tokenId];delete_ownedTokens[from][lastTokenIndex];}",
    "{uint256lastTokenIndex=balanceOf(from)-1;uint256tokenIndex=_ownedTokensIndex[tokenId];if(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}delete_ownedTokensIndex[tokenId];delete_ownedTokens[from][lastTokenIndex];}",
    "{uint256lastTokenIndex=ERC721.balanceOf(from)-1;uint256tokenIndex=_ownedTokensIndex[tokenId];if(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}delete_ownedTokensIndex[tokenId];delete_ownedTokens[from][lastTokenIndex];}",
    "{}",
    "{uint256lastTokenIndex=_ownedTokens[from].length.sub(1);uint256tokenIndex=_ownedTokensIndex[tokenId];if(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}_ownedTokens[from].length--;}"
  ],
  "addMinter": ["{_minters[minter]=true;emiteAddMinter(minter,block.number);}"],
  "removeMinter": [
    "{_minters[minter]=false;emiteRemoveMinter(minter,block.number);}"
  ],
  "setMetaType": ["{_metatype=metatype;}"],
  "setBaseURI": [
    "{baseURI=_newBaseURI;}",
    "{_baseUri=uri;}",
    "{_setBaseURI(baseURI);}",
    "{baseURI=uri;}",
    "{\\rbaseTokenURI=baseURI;\\r}",
    "{_baseTokenUri=newURI;}",
    "{baseTokenURI=_baseTokenURI;emitBaseURISet(_baseTokenURI);}"
  ],
  "mintedNumber": ["{return_numberMinted(addr);}"],
  "safeBatchTransferFrom": [
    "{for(uint256i=0;i<ids.length;++i){safeTransferFrom(from,to,ids[i],data);}emitTransferBatch(from,to,ids);}",
    "{require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:transfercallerisnotownernorapproved\");_safeBatchTransferFrom(from,to,ids,amounts,data);}"
  ],
  "getOwnershipOf": ["{return_ownerships[tokenId];}"],
  "mint": [
    "{uint256supply=totalSupply();require(!paused);require(_mintAmount>0);require(_mintAmount<=maxMintAmount);require(supply+_mintAmount<=maxSupply);if(msg.sender!=owner()){if(whitelisted[msg.sender]!=true){if(presaleWallets[msg.sender]!=true){//generalpublicrequire(msg.value>=cost*_mintAmount);}else{//presalerequire(msg.value>=presaleCost*_mintAmount);}}}for(uint256i=1;i<=_mintAmount;i++){_safeMint(_to,supply+i);}}",
    "{_mint(_to,_id,_amount,\"\");}",
    "{uint256tokenId=_currentIndex;ICartoon721.ExtraInfostoragesInfo=_extraInfo[_currentIndex];sInfo.mintRule=mintRule;sInfo.stakeErc20=stakeErc20;sInfo.stakeAmount=stakeAmount;sInfo.id=_currentIndex;_safeMint(to,1,\"\");returntokenId;}",
    "{super._mint(_to,_tokenId);super._setTokenUri(_tokenId,_uri);super._setTokenPayload(_tokenId,_payload);}",
    "{require(msg.sender==tx.origin,\"\");require(to==msg.sender,\"\");addresssignerOwner=signatureMint(stageType,to,quantity,price,_timestamp,_signature);require(signerOwner==whitelistAddress,\"\");require(_timestamp>block.timestamp,\"\");require(maxQuantity==0||maxQuantity>=quantity,\"\");require(maxTotalSupply==0||totalSupply().add(quantity)<maxTotalSupply,\"\");require(!mintedNum[stageType][to],\"\");updateStage(stageType,to,quantity,price);mintedNum[stageType][to]=true;_mint(to,quantity);emitNFTMintEvent(stageType,_nextTokenId()-1,to,quantity,price);}",
    "{\\ruint256total=_totalSupply();\\rrequire(total<=MAX_ELEMENTS,\"\");\\rrequire(total+_tokensId.length<=MAX_ELEMENTS,\"\");\\rrequire(_tokensId.length<=MAX_BY_MINT,\"\");\\r\\rfor(uint256i=0;i<_tokensId.length;i++){\\ruint256_tokenId=_tokensId[i];\\rrequire(canClaim(_tokenId)&&pudgyPenguins.ownerOf(_tokenId)==_msgSender(),\"\");\\r\\r_pudgyPenguinsUsed[_tokenId]=1;\\r_mintAnElement(_to,_tokenId);\\r\\r}\\r}",
    "{require(mintStage==2||mintStage==1,\"\");_mintValidate(amount,_msgSender(),false);_safeMintTo(_msgSender(),amount);}",
    "{\\ruint256total=_totalSupply();\\rrequire(total+_count<=MAX_ELEMENTS,\"\");\\rrequire(total<=MAX_ELEMENTS,\"\");\\rrequire(_count<=MAX_BY_MINT,\"\");\\rrequire(msg.value>=price(_count),\"\");\\r\\rfor(uint256i=0;i<_count;i++){\\r_mintAnElement(_to);\\r}\\r}",
    "{uint256count=tokenIds.length;resolveEpochIfNecessary();for(uint256i;i<count;){uint256id=tokenIds[i];addressowner=editionChecks.ownerOf(id);if(owner!=msg.sender&&(!editionChecks.isApprovedForAll(owner,msg.sender))&&editionChecks.getApproved(id)!=msg.sender){revertNotAllowed();}editionChecks.burn(id);StoredCheckstoragecheck=checks.all[id];check.day=Utilities.day(checks.day0,block.timestamp);check.epoch=uint32(checks.epoch);check.seed=uint16(id);check.divisorIndex=0;if(msg.sender!=recipient){_safeMintVia(recipient,msg.sender,id);}else{_safeMint(msg.sender,id);}unchecked{++i;}}unchecked{checks.minted+=uint32(count);}}"
  ],
  "burn": [
    "{_burn(msg.sender,_id,_amount);}",
    "{require(_isApprovedOrOwner(tokenId),\"callerisnotownernorapproved\");_burn(tokenId);}",
    "{super._burn(_tokenId);}",
    "{if(!burnIsActive)revertBurnIsNotActive();if(!_isApprovedToBurn(tokenId))revertUnauthorizedOwnerOfToken();--_totalSupply;_burn(tokenId);}",
    "{\\rrequire(_msgSender()==owner()||_msgSender()==nuoNFTAddress,\"\");\\rrequire(ownerOf(tokenId)==_user,\"\");\\r_burn(tokenId);\\r}",
    "{_burn(tokenId,true);}",
    "{require(_isApprovedOrOwner(_msgSender(),\"\"),\"ERC721Burnable:callerisnotownernorapproved\");_burn(tokenId);}",
    "{if(!_isApprovedOrOwner(msg.sender,tokenId)){revertNotAllowed();}_burn(tokenId);unchecked{++checks.burned;}}"
  ],
  "tokensInfoByPage": [
    "{require(pageMax>0,\"invalidpagesize!\");uint256balance=_currentIndex;uint256maxCount=0;if(balance<=pageMax){maxCount=balance;}else{maxCount=pageMax;uint256pages=balance/pageMax;require(pages>=offset,\"invalidpagesize!\");if(pages==offset){maxCount=balance%pageMax;require(maxCount>0,\"invalidpagesize!\");}}infos=newICartoon721.ExtraInfo[](maxCount);uint256tokenId=0;for(uinti=0;i<maxCount;i++){tokenId=offset*pageMax+i;infos[i]=_extraInfo[tokenId];}}"
  ],
  "getExtraInfo": ["{return_extraInfo[tokenId];}"],
  "_numberMinted": [
    "{if(owner==address(0))revertMintedQueryForZeroAddress();returnuint256(_addressData[owner].numberMinted);}",
    "{return(_packedAddressData[owner]>>_BITPOS_NUMBER_MINTED)&_BITMASK_ADDRESS_DATA_ENTRY;}"
  ],
  "_numberBurned": [
    "{if(owner==address(0))revertBurnedQueryForZeroAddress();returnuint256(_addressData[owner].numberBurned);}",
    "{return(_packedAddressData[owner]>>_BITPOS_NUMBER_BURNED)&_BITMASK_ADDRESS_DATA_ENTRY;}"
  ],
  "_getAux": [
    "{if(owner==address(0))revertAuxQueryForZeroAddress();return_addressData[owner].aux;}",
    "{returnuint64(_packedAddressData[owner]>>_BITPOS_AUX);}"
  ],
  "_setAux": [
    "{if(owner==address(0))revertAuxQueryForZeroAddress();_addressData[owner].aux=aux;}",
    "{uint256packed=_packedAddressData[owner];uint256auxCasted;assembly{auxCasted:=aux}packed=(packed&_BITMASK_AUX_COMPLEMENT)|(auxCasted<<_BITPOS_AUX);_packedAddressData[owner]=packed;}"
  ],
  "owner": ["{return_owner;}"],
  "_checkOwner": [
    "{require(owner()==_msgSender(),\"Ownable:callerisnottheowner\");}",
    "{require(owner()==_msgSender(),\"\");}"
  ],
  "renounceOwnership": [
    "{_setOwner(address(0));}",
    "{_transferOwnership(address(0));}",
    "{emitOwnershipTransferred(_owner,address(0));_owner=address(0);}"
  ],
  "transferOwnership": [
    "{require(newOwner!=address(0),\"Ownable:newowneristhezeroaddress\");_setOwner(newOwner);}",
    "{require(newOwner!=address(0),\"Ownable:newowneristhezeroaddress\");_transferOwnership(newOwner);}",
    "{require(newOwner!=address(0),\"\");_setOwner(newOwner);}",
    "{require(newOwner!=address(0),\"\");emitOwnershipTransferred(_owner,newOwner);_owner=newOwner;}",
    "{require(_newOwner!=address(0),\"\");emitOwnershipTransferred(owner,_newOwner);owner=_newOwner;}",
    "{require(newOwner!=address(0),\"\");_transferOwnership(newOwner);}"
  ],
  "_transferOwnership": [
    "{addressoldOwner=_owner;_owner=newOwner;emitOwnershipTransferred(oldOwner,newOwner);}"
  ],
  "_ownerOf": ["{return_owners[tokenId];}"],
  "AddBalance": [
    "",
    "{}",
    "{require(tokenId<type(uint96).max,\"Outofrange\");BalanceKeykey=toBalanceKey(account,tokenId);BalanceAmountcurrentBalance=_balanceOf[key];if(currentBalance.getPosition()>0){//Simpleadd_balanceOf[key]=currentBalance.add(amount);}else{uint96[]storagerefTokenIds=tokensHeld[account];uint256length=refTokenIds.length;if(length==0){//AddemptyzeroitemrefTokenIds.push();refTokenIds.push(uint96(tokenId));_balanceOf[key]=BalanceAmount.wrap((uint256(amount)<<16)|1);}else{require(length<type(uint16).max,\"Toomanytypes\");uint16position=uint16(length);refTokenIds.push(uint96(tokenId));_balanceOf[key]=BalanceAmount.wrap((uint256(amount)<<16)|position);}}totalSupply+=amount;}"
  ],
  "get": [
    "{returnaddress(uint256(_get(map._inner,bytes32(key),errorMessage)));}",
    "{\\rreturnaddress(uint160(uint256(_get(map._inner,bytes32(key),errorMessage))));\\r}",
    "{}",
    "{returnaddress(uint160(uint256(_get(map._inner,bytes32(key),errorMessage))));}"
  ],
  "_get": [
    "{uint256keyIndex=map._indexes[key];require(keyIndex!=0,errorMessage);returnmap._entries[keyIndex-1]._value;}",
    "{}",
    "{\\ruint256keyIndex=map._indexes[key];\\rrequire(keyIndex!=0,errorMessage);\\rreturnmap._entries[keyIndex-1]._value;\\r}",
    "{uint256keyIndex=map._indexes[key];require(keyIndex!=0,errorMessage);//Equivalenttocontains(map,key)returnmap._entries[keyIndex-1]._value;//Allindexesare1-based}",
    "{uint256keyIndex=map._indexes[key];require(keyIndex!=0,\"\");returnmap._entries[keyIndex-1]._value;}"
  ],
  "remove": [
    "{require(account!=address(0));require(has(role,account));role.bearer[account]=false;}",
    "{if(account==address(0)){revertUnauthorized();}elseif(!has(role,_type,account)){revertMaxSplaining({reason:string(abi.encodePacked(\"LibRoles:\",Strings.toHexString(uint160(account),20),\"doesnothaverole\",Strings.toHexString(uint32(_type),4)))});}role.bearer[account][_type]=false;emitRoleChanged(_type,account,false);}",
    "{\\rreturn_remove(map._inner,bytes32(key));\\r}",
    "{}",
    "{return_remove(set._inner,bytes32(value));}",
    "{deleteminters[_minter];emitMinterRoleRevoked(_minter);}",
    "{return_remove(map._inner,bytes32(key));}"
  ],
  "set": [
    "{return_set(map._inner,bytes32(key),bytes32(uint256(value)));}",
    "{require(pools.contains(address(_poolToken)),\"HF:Non-existantpool\");massUpdatePools();totalAllocationPoints=totalAllocationPoints.sub(poolInfo[_poolToken].allocation).add(_allocation);poolInfo[_poolToken].allocation=_allocation;emitPoolUpdated(_poolToken,_allocation);if(_allocation==0){pools.remove(address(_poolToken));emitPoolRemoved(_poolToken);}}",
    "{counter._value=number;emitCounterNumberChangedTo(counter._value);}",
    "{\\rreturn_set(map._inner,bytes32(key),bytes32(uint256(uint160(value))));\\r}",
    "{}",
    "{return_set(map._inner,bytes32(key),bytes32(uint256(uint160(value))));}"
  ],
  "andthenremovethelastelement": [
    "",
    "{}",
    "{return_set(map._inner,bytes32(key),bytes32(uint256(uint160(value))));}"
  ],
  "_set": [
    "{\\ruint256keyIndex=map._indexes[key];\\r\\rif(keyIndex==0){map._entries.push(MapEntry({_key:key,_value:value}));\\rmap._indexes[key]=map._entries.length;\\rreturntrue;\\r}else{\\rmap._entries[keyIndex-1]._value=value;\\rreturnfalse;\\r}\\r}",
    "{uint256keyIndex=map._indexes[key];if(keyIndex==0){map._entries.push(MapEntry({_key:key,_value:value}));map._indexes[key]=map._entries.length;returntrue;}else{map._entries[keyIndex-1]._value=value;returnfalse;}}",
    "{}",
    "{return_set(map._inner,bytes32(key),bytes32(uint256(uint160(value))));}",
    "{//Wereadandstorethekey'sindextopreventmultiplereadsfromthesamestorageslotuint256keyIndex=map._indexes[key];if(keyIndex==0){//Equivalentto!contains(map,key)map._entries.push(MapEntry({_key:key,_value:value}));//Theentryisstoredatlength-1,butweadd1toallindexes//anduse0asasentinelvaluemap._indexes[key]=map._entries.length;returntrue;}else{map._entries[keyIndex-1]._value=value;returnfalse;}}"
  ],
  "_pushBurn": [
    "",
    "{}",
    "{require(amount>0,\"non-positiveamount\");_burns[account][nftId]+=amount*block.timestamp;_burnsTotal[nftId]+=amount*block.timestamp;}"
  ],
  "_pushMint": [
    "",
    "{}",
    "{require(amount>0,\"non-positiveamount\");_mints[account][nftId]+=amount*block.timestamp;_mintsTotal[nftId]+=amount*block.timestamp;}"
  ],
  "_callonERC1155Received": [
    "",
    "{}",
    "{//Checkifrecipientiscontractif(_to.isContract()){bytes4retval=IERC1155TokenReceiver(_to).onERC1155Received{gas:_gasLimit}(msg.sender,_from,_id,_amount,_data);if(retval!=ERC1155_RECEIVED_VALUE)revertInvalidOnReceiveMsg();}}"
  ],
  "sub": [
    "{require(b<=a);uint256c=a-b;returnc;}",
    "{\\rrequire(b<=a,errorMessage);\\rreturna-b;\\r}",
    "{require(b<=a,errorMessage);uint256c=a-b;returnc;}",
    "{require(b<=a);returna-b;}",
    "{require(b<=a,\"SafeMath:subtractionoverflow\");uint256c=a-b;returnc;}",
    "{require(b<=a,errorMessage);returna-b;}",
    "{}",
    "{require(b<=a,errorMessage);uintc=a-b;returnc;}",
    "{assert(b\\u003c=a);returna-b;}",
    "{assert(b<=a);returna-b;}",
    "{unchecked{require(b<=a,errorMessage);returna-b;}}",
    "{require(b<=a,\"\");returna-b;}",
    "{require(_subtrahend<=_minuend,\"\");difference=_minuend-_subtrahend;}",
    "{unchecked{require(b<=a,\"\");returna-b;}}",
    "{require(b<=a,\"\");uint256c=a-b;returnc;}"
  ],
  "ownershipOf": [
    "{uint256curr=tokenId;unchecked{if(curr<_currentIndex){TokenOwnershipmemoryownership=_ownerships[curr];if(!ownership.burned){if(ownership.addr!=address(0)){returnownership;}while(true){curr--;ownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}}}}revertOwnerQueryForNonexistentToken();}",
    "{if(!_exists(tokenId))revertOwnerQueryForNonexistentToken();unchecked{for(uint256curr=tokenId;;curr--){TokenOwnershipmemoryownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}}}",
    "{}",
    "{uint256curr=tokenId;unchecked{if(_startTokenId()<=curr&&curr<_currentIndex){TokenOwnershipmemoryownership=_ownerships[curr];if(!ownership.burned){if(ownership.addr!=address(0)){returnownership;}while(true){curr--;ownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}}}}revertOwnerQueryForNonexistentToken();}",
    "{uint256curr=tokenId;unchecked{if(_startTokenId()<=curr&&curr<currentIndex){TokenOwnershipmemoryownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}//Invariant://Therewillalwaysbeanownershipthathasanaddressandisnotburned//beforeanownershipthatdoesnothaveanaddressandisnotburned.//Hence,currwillnotunderflow.while(true){curr--;ownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}}}revert(\"ERC721A:unabletodeterminetheowneroftoken\");}",
    "{require(_exists(tokenId),\"ERC721A:ownerqueryfornonexistenttoken\");uint256lowestTokenToCheck;if(tokenId>=maxBatchSize){lowestTokenToCheck=tokenId-maxBatchSize+1;}for(uint256curr=tokenId;curr>=lowestTokenToCheck;curr--){TokenOwnershipmemoryownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}revert(\"ERC721A:unabletodeterminetheowneroftoken\");}"
  ],
  "functionCall": [
    "{return_functionCallWithValue(target,data,0,errorMessage);}",
    "{}",
    "{\\rreturnfunctionCallWithValue(target,data,0,errorMessage);\\r}",
    "{returnfunctionCallWithValue(target,data,0,errorMessage);}"
  ],
  "_functionCallWithValue": [
    "{require(isContract(target),\"Address:calltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.call{value:weiValue}(data);if(success){returnreturndata;}else{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");return_functionCallWithValue(target,data,value,errorMessage);}",
    "{}"
  ],
  "functionCallWithValue": [
    "{require(address(this).balance\\u003e=value,\"Address:insufficientbalanceforcall\");require(isContract(target),\"Address:calltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{\\rrequire(address(this).balance>=value,\"Address:insufficientbalanceforcall\");\\rrequire(isContract(target),\"Address:calltonon-contract\");\\r\\r(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);\\rreturn_verifyCallResult(success,returndata,errorMessage);\\r}_verifyCallResult {\\rif(success){\\rreturnreturndata;\\r}else{\\rif(returndata.length>0){\\r\\rassembly{\\rletreturndata_size:=mload(returndata)\\rrevert(add(32,returndata),returndata_size)\\r}\\r}else{\\rrevert(errorMessage);\\r}\\r}\\r}",
    "{\\rrequire(address(this).balance>=value,\"Address:insufficientbalanceforcall\");\\rrequire(isContract(target),\"Address:calltonon-contract\");\\r\\r(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);\\rreturn_verifyCallResult(success,returndata,errorMessage);\\r}",
    "{\\rrequire(address(this).balance\\u003e=value,\"Address:insufficientbalanceforcall\");\\rrequire(isContract(target),\"Address:calltonon-contract\");\\r\\r(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);\\rreturnverifyCallResult(success,returndata,errorMessage);\\r}",
    "{require(address(this).balance\\u003e=value,\"Address:insufficientbalanceforcall\");require(isContract(target),\"Address:calltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,'Address:insufficientbalanceforcall');require(isContract(target),'Address:calltonon-contract');(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{\\rrequire(address(this).balance>=value,\"Address:insufficientbalanceforcall\");\\rrequire(isContract(target),\"Address:calltonon-contract\");\\r\\r(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);\\rreturnverifyCallResult(success,returndata,errorMessage);\\r}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");return_functionCallWithValue(target,data,value,errorMessage);}",
    "{}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");require(isContract(target),\"Address:calltonon-contract\");//solhint-disable-next-lineavoid-low-level-calls(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");require(isContract(target),\"Address:calltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResultFromTarget(target,success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");require(isContract(target),\"Address:calltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"\");require(isContract(target),\"\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"\");require(isContract(target),\"\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResultFromTarget(target,success,returndata,errorMessage);}"
  ],
  "verifyCallResultFromTarget": [
    "",
    "{if(success){if(returndata.length==0){//onlycheckisContractifthecallwassuccessfulandthereturndataisempty//otherwisewealreadyknowthatitwasacontractrequire(isContract(target),\"Address:calltonon-contract\");}returnreturndata;}else{_revert(returndata,errorMessage);}}",
    "{}",
    "{if(success){if(returndata.length==0){require(isContract(target),\"Address:calltonon-contract\");}returnreturndata;}else{_revert(returndata,errorMessage);}}",
    "{if(success){if(returndata.length==0){require(isContract(target),\"\");}returnreturndata;}else{_revert(returndata,errorMessage);}}"
  ],
  "_revert": [
    "",
    "{assembly{mstore(0x00,errorSelector)revert(0x00,0x04)}}",
    "{//Lookforrevertreasonandbubbleitupifpresentif(returndata.length>0){//Theeasiestwaytobubbletherevertreasonisusingmemoryviaassembly///@soliditymemory-safe-assemblyassembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}",
    "{}",
    "{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}"
  ],
  "_callOptionalReturn": [
    "{//Weneedtoperformalowlevelcallhere,tobypassSolidity'sreturndatasizecheckingmechanism,since//we'reimplementingitourselves.Weuse{Address.functionCall}toperformthiscall,whichverifiesthat//thetargetaddresscontainscontractcodeandalsoassertsforsuccessinthelow-levelcall.bytesmemoryreturndata=address(token).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){//Returndataisoptional//solhint-disable-next-linemax-line-lengthrequire(abi.decode(returndata,(bool)),\"SafeERC20:ERC20operationdidnotsucceed\");}}",
    "{//Weneedtoperformalowlevelcallhere,tobypassSolidity'sreturndatasizecheckingmechanism,since//we'reimplementingitourselves.Weuse{Address.functionCall}toperformthiscall,whichverifiesthat//thetargetaddresscontainscontractcodeandalsoassertsforsuccessinthelow-levelcall.bytesmemoryreturndata=address(token).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){//Returndataisoptionalrequire(abi.decode(returndata,(bool)),\"SafeERC20:ERC20operationdidnotsucceed\");}}",
    "{//Weneedtoperformalowlevelcallhere,tobypassSolidity'sreturndatasizecheckingmechanism,since//we'reimplementingitourselves.Weuse{Address-functionCall}toperformthiscall,whichverifiesthat//thetargetaddresscontainscontractcodeandalsoassertsforsuccessinthelow-levelcall.bytesmemoryreturndata=address(token).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){//Returndataisoptionalrequire(abi.decode(returndata,(bool)),\"SafeERC20:ERC20operationdidnotsucceed\");}}",
    "{bytesmemoryreturndata=address(token).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){require(abi.decode(returndata,(bool)),\"SafeERC20:ERC20operationdidnotsucceed\");}}",
    "",
    "{}",
    "{bytesmemoryreturndata=address(token).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){require(abi.decode(returndata,\"\")),\"SafeERC20:ERC20operationdidnotsucceed\");}}",
    "{bytesmemoryreturndata=address(tBscen).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){require(abi.decode(returndata,\"\")),\"SafeERC20:ERC20operationdidnotsucceed\");}}"
  ],
  "_safeTransferFrom": [
    "{require(to!=address(0),\"ERC1155WithTerminusStorage:transfertothezeroaddress\");LibTerminus.TerminusStoragestoragets=LibTerminus.terminusStorage();require(!ts.poolNotTransferable[id],\"ERC1155WithTerminusStorage:_safeTransferFrom--poolisnottransferable\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);uint256fromBalance=ts.poolBalances[id][from];require(fromBalance>=amount,\"ERC1155WithTerminusStorage:insufficientbalancefortransfer\");unchecked{ts.poolBalances[id][from]=fromBalance-amount;}ts.poolBalances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{addresstokenOwner=idToOwner[_tokenId];require(tokenOwner==_from,\"Incorrectowner.\");require(_to!=address(0));_transfer(_to,_tokenId);if(isContract(_to)){bytes4retval=ERC721TokenReceiver(_to).onERC721Received(msg.sender,_from,_tokenId,_data);require(retval==MAGIC_ON_ERC721_RECEIVED);}}",
    "{//Updatebalances_updateIDBalance(_from,_id,_amount,Operations.Sub);//Subtractamountfromsender_updateIDBalance(_to,_id,_amount,Operations.Add);//Addamounttorecipient//EmiteventemitTransferSingle(msg.sender,_from,_to,_id,_amount);}",
    "{require(from!=address(0),\"ERC1155:transferfromthezeroaddress\");require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();SubtractBalance(from,id,amount);AddBalance(to,id,amount);emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{//require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();uint256[]memoryids=_asSingletonArray(id);uint256[]memoryamounts=_asSingletonArray(amount);_beforeTokenTransfer(operator,from,to,ids,amounts,data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_afterTokenTransfer(operator,from,to,ids,amounts,data);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "",
    "{\\rrequire(to!=address(0),\"ERC1155:transfertothezeroaddress\");\\r\\raddressoperator=_msgSender();\\ruint256[]memoryids=_asSingletonArray(id);\\ruint256[]memoryamounts=_asSingletonArray(amount);\\r\\r_beforeTokenTransfer(operator,from,to,ids,amounts,data);\\r\\ruint256fromBalance=_balances[id][from];\\rrequire(\\rfromBalance>=amount,\\r\"ERC1155:insufficientbalancefortransfer\"\\r);\\runchecked{\\r_balances[id][from]=fromBalance-amount;\\r}\\r_balances[id][to]+=amount;\\r\\remitTransferSingle(operator,from,to,id,amount);\\r\\r_afterTokenTransfer(operator,from,to,ids,amounts,data);\\r\\r_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);\\r}",
    "{}",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();uint256[]memoryids=_asSingletonArray(id);uint256[]memoryamounts=_asSingletonArray(amount);_beforeTokenTransfer(operator,from,to,ids,amounts,data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_afterTokenTransfer(operator,from,to,ids,amounts,data);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{addresstokenOwner=idToOwner[_tokenId];require(tokenOwner==_from,\"\");require(_to!=address(0),\"\");_transfer(_to,_tokenId);if(_to.isContract()){bytes4retval=ERC721TokenReceiver(_to).onERC721Received(msg.sender,_from,_tokenId,_data);require(retval==MAGIC_ON_ERC721_RECEIVED,\"\");}}"
  ],
  "_asSingletonArray": [
    "",
    "{\\ruint256[]memoryarray=newuint256[](1);\\rarray[0]=element;\\r\\rreturnarray;\\r}",
    "{}",
    "{uint256[]memoryarray=newuint256[](1);array[0]=element;returnarray;}"
  ],
  "_doSafeTransferAcceptanceCheck": [
    "{if(to.isContract()){tryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){if(response!=IERC1155Receiver.onERC1155Received.selector){revert(\"ERC1155WithTerminusStorage:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155WithTerminusStorage:transfertononERC1155Receiverimplementer\");}}}",
    "{\\rif(to.isContract()){\\rtryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){\\rif(response!=IERC1155Receiver(to).onERC1155Received.selector){\\rrevert(\"ERC1155:ERC1155Receiverrejectedtokens\");\\r}\\r}catchError(stringmemoryreason){\\rrevert(reason);\\r}catch{\\rrevert(\"ERC1155:transfertononERC1155Receiverimplementer\");\\r}\\r}\\r}",
    "{if(isContract(to)){tryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){if(response!=IERC1155Receiver.onERC1155Received.selector){revert(\"ERC1155:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155:transfertononERC1155Receiverimplementer\");}}}",
    "{if(to.isContract()){tryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){if(response!=IERC1155Receiver(to).onERC1155Received.selector){revert(\"ERC1155:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155:transfertononERC1155Receiverimplementer\");}}}",
    "{}",
    "{\\rif(to.isContract()){\\rtry\\rIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)\\rreturns(bytes4response){\\rif(response!=IERC1155Receiver.onERC1155Received.selector){\\rrevert(\"ERC1155:ERC1155Receiverrejectedtokens\");\\r}\\r}catchError(stringmemoryreason){\\rrevert(reason);\\r}catch{\\rrevert(\"ERC1155:transfertononERC1155Receiverimplementer\");\\r}\\r}\\r}",
    "{require(ERC1155TokenReceiver(_to).onERC1155Received(_operator,_from,_id,_value,_data)==ERC1155_ACCEPTED,\"contractreturnedanunknownvaluefromonERC1155Received\");}",
    "{if(to.isContract()){tryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){if(response!=IERC1155Receiver.onERC1155Received.selector){revert(\"ERC1155:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155:transfertonon-ERC1155Receiverimplementer\");}}}",
    "{if(to.isContract()){tryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){if(response!=IERC1155Receiver.onERC1155Received.selector){revert(\"ERC1155:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155:transfertononERC1155Receiverimplementer\");}}}"
  ],
  "_startTokenId": ["{}", "{returnstartTokenId;}", "{return0;}", "{return1;}"],
  "_msgSenderERC721A": [
    "{}",
    "",
    "{return0;}",
    "{returnmsg.sender;}",
    "{returnmsg.sender;}"
  ],
  "onERC1155Received": ["", "{returnthis.onERC1155Received.selector;}", "{}"],
  "onERC721Received": [
    "{}",
    "{returnthis.onERC721Received.selector;}",
    "{require(from==address(0x0),\"CannotsendtokenstoBarndirectly\");returnIERC721Receiver.onERC721Received.selector;}",
    "{require(!_reverts,\"\");emitReceived(operator,from,tokenId,data,gasleft());return_retval;}"
  ],
  "_spendAllowance": [
    "{uint256currentAllowance=allowance(owner,spender);if(currentAllowance!=type(uint256).max){require(currentAllowance>=amount,\"ERC20:insufficientallowance\");unchecked{_approve(owner,spender,currentAllowance-amount);}}}",
    "",
    "{}"
  ],
  "_checkContractOnERC721Received": [
    "{tryERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)returns(bytes4retval){returnretval==ERC721A__IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){_revert(TransferToNonERC721ReceiverImplementer.selector);}assembly{revert(add(32,reason),mload(reason))}}}",
    "",
    "{tryERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)returns(bytes4retval){returnretval==ERC721A__IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revertTransferToNonERC721ReceiverImplementer();}else{assembly{revert(add(32,reason),mload(reason))}}}}",
    "{tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revertTransferToNonERC721ReceiverImplementer();}else{assembly{revert(add(32,reason),mload(reason))}}}}",
    "{tryERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)returns(bytes4retval){returnretval==ERC721A__IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revertTransferToNonERC721ReceiverImplementer();}else{assembly{revert(add(32,reason),mload(reason))}}}}",
    "{}"
  ],
  "_add": [
    "{\\rif(!_contains(set,value)){\\rset._values.push(value);\\rset._indexes[value]=set._values.length;\\rreturntrue;\\r}else{\\rreturnfalse;\\r}\\r}",
    "{if(!_contains(set,value)){set._values.push(value);//Thevalueisstoredatlength-1,butweadd1toallindexes//anduse0asasentinelvalueset._indexes[value]=set._values.length;returntrue;}else{returnfalse;}}",
    "",
    "{}",
    "{if(!_contains(set,value)){set._values.push(value);set._indexes[value]=set._values.length;returntrue;}else{returnfalse;}}"
  ],
  "hasRole": [
    "{return_checkRole(role,account);}",
    "{return_roles[role].members[account];}",
    "{}",
    "{return_roles[role].members.contains(account);}"
  ],
  "erc721Storage": [
    "{}",
    "{bytes32position=ERC721_STORAGE_POSITION;assembly{es.slot:=position}}"
  ],
  "isApprovedForPool": [
    "{}",
    "{returnLibTerminus._isApprovedForPool(poolID,operator);}"
  ],
  "terminusStorage": [
    "{}",
    "{bytes32position=TERMINUS_STORAGE_POSITION;assembly{es.slot:=position}}"
  ],
  "emitRoleChanged": ["{}", ""],
  "_isApprovedForPool": ["{}", ""],
  "isTokenRented": ["{}", ""],
  "_checkRole": [
    "{}",
    "{\\rif(!_gameRegistry.hasAccessRole(role,account)){\\rrevertMissingRole(account,role);\\r}\\r}",
    "{returncontractRoles.has(role,account);}",
    "{if(!hasRole(role,account)){revert(string(abi.encodePacked(\"AccessControl:account\",Strings.toHexString(uint160(account),20),\"ismissingrole\",Strings.toHexString(uint256(role),32))));}}",
    "{if(!hasRole(role,account)){revert(string(abi.encodePacked(\"AccessControl:account\",Strings.toHexString(account),\"ismissingrole\",Strings.toHexString(uint256(role),32))));}}"
  ],
  "toHexString": [
    "{bytesmemorybuffer=newbytes(2*length+2);buffer[0]=\"0\";buffer[1]=\"x\";for(uint256i=2*length+1;i>1;--i){buffer[i]=_HEX_SYMBOLS[value&0xf];value>>=4;}require(value==0,\"\");returnstring(buffer);}",
    "{bytesmemorybuffer=newbytes(2*length+2);buffer[0]=\"0\";buffer[1]=\"x\";for(uint256i=2*length+1;i>1;--i){buffer[i]=alphabet[value&0xf];value>>=4;}require(value==0,\"Strings:hexlengthinsufficient\");returnstring(buffer);}",
    "{bytesmemorybuffer=newbytes(2*length+2);buffer[0]='0';buffer[1]='x';for(uint256i=2*length+1;i>1;--i){buffer[i]=_HEX_SYMBOLS[value&0xf];value>>=4;}require(value==0,'Strings:hexlengthinsufficient');returnstring(buffer);}",
    "{bytesmemorybuffer=newbytes(2*length+2);buffer[0]=\"0\";buffer[1]=\"x\";for(uint256i=2*length+1;i\\u003e1;--i){buffer[i]=_HEX_SYMBOLS[value\\u00260xf];value\\u003e\\u003e=4;}require(value==0,\"Strings:hexlengthinsufficient\");returnstring(buffer);}",
    "{returntoHexString(uint256(uint160(addr)),_ADDRESS_LENGTH);}",
    "{\\rbytesmemorybuffer=newbytes(2*length+2);\\rbuffer[0]=\"0\";\\rbuffer[1]=\"x\";\\rfor(uint256i=2*length+1;i\\u003e1;--i){\\rbuffer[i]=_HEX_SYMBOLS[value\\u00260xf];\\rvalue\\u003e\\u003e=4;\\r}\\rrequire(value==0,\"Strings:hexlengthinsufficient\");\\rreturnstring(buffer);\\r}",
    "{}",
    "{bytesmemorybuffer=newbytes(2*length+2);buffer[0]=\"0\";buffer[1]=\"x\";for(uint256i=2*length+1;i>1;--i){buffer[i]=_HEX_SYMBOLS[value&0xf];value>>=4;}require(value==0,\"Strings:hexlengthinsufficient\");returnstring(buffer);}"
  ],
  "supportsInterface": [
    "{return_supportedInterfaces[interfaceId];}",
    "{returninterfaceId==type(IERC721Enumerable).interfaceId||super.supportsInterface(interfaceId);}",
    "{returninterfaceId==type(IERC165).interfaceId;}",
    "{returninterfaceId==type(IERC1155).interfaceId||interfaceId==type(IERC1155MetadataURI).interfaceId||super.supportsInterface(interfaceId);}",
    "{returnsupportedInterfaces[_interfaceID];}",
    "{returninterfaceId==type(IERC721).interfaceId||interfaceId==type(IERC721Metadata).interfaceId||super.supportsInterface(interfaceId);}",
    "{returninterfaceId==type(IERC721EnumerableMod).interfaceId||super.supportsInterface(interfaceId);}",
    "{returninterfaceId==0x01ffc9a7||interfaceId==0x80ac58cd||interfaceId==0x5b5e139f;}",
    "{returninterfaceId==type(IAccessControl).interfaceId||super.supportsInterface(interfaceId);}"
  ],
  "balanceOf": [
    "{require(owner!=address(0),\"ERC721:balancequeryforthezeroaddress\");return_balances[owner];}",
    "{if(owner==address(0))revertBalanceQueryForZeroAddress();returnuint256(_addressData[owner].balance);}",
    "{require(account!=address(0),\"ERC1155:balancequeryforthezeroaddress\");return_balances[id][account];}",
    "{require(owner!=address(0),\"\");return_balances[owner];}",
    "{require(owner!=address(0),\"\");return_holderTokens[owner].length();}",
    "{require(_owner!=address(0),\"\");return_getOwnerNFTCount(_owner);}",
    "{if(owner==address(0))revertBalanceQueryForZeroAddress();return_packedAddressData[owner]&_BITMASK_ADDRESS_DATA_ENTRY;}",
    "{if(owner==address(0))_revert(BalanceQueryForZeroAddress.selector);return_packedAddressData[owner]&_BITMASK_ADDRESS_DATA_ENTRY;}",
    "{require(owner!=address(0),\"\");return_ownedTokensCount[owner].current();}",
    "{if(owner==address(0)){revertERC721__InvalidOwner();}return_balances[owner];}"
  ],
  "name": ["{return_name;}", "{_name=nftName;}"],
  "symbol": ["{return_symbol;}", "{_symbol=nftSymbol;}"],
  "admin": ["{return_admin;}", "{admin_=_getAdmin();}"],
  "approve": [
    "{addressowner=ERC721.ownerOf(tokenId);require(to!=owner,\"ERC721:approvaltocurrentowner\");require(_msgSender()==owner||isApprovedForAll(owner,_msgSender()),\"ERC721:approvecallerisnotownernorapprovedforall\");_approve(to,tokenId);}",
    "{addressowner=ERC721A.ownerOf(tokenId);if(to==owner)revertApprovalToCurrentOwner();if(_msgSender()!=owner&&!isApprovedForAll(owner,_msgSender())){revertApprovalCallerNotOwnerNorApproved();}_approve(to,tokenId,owner);}",
    "{addressowner=BRC721.ownerOf(tokenId);require(to!=owner,\"ERC721:approvaltocurrentowner\");require(_msgSender()==owner||isApprovedForAll(owner,_msgSender()),\"ERC721:approvecallerisnotownernorapprovedforall\");_approve(to,tokenId);}",
    "{addressowner=ERC721.ownerOf(tokenId);require(to!=owner,\"\");require(_msgSender()==owner||isApprovedForAll(owner,\"\")),\"ERC721:approvecallerisnotownernorapprovedforall\");_approve(to,tokenId);}",
    "{addressowner=ERC721.ownerOf(tokenId);require(to!=owner,\"\");require(_msgSender()==owner||ERC721.isApprovedForAll(owner,\"\")),\"ERC721:approvecallerisnotownernorapprovedforall\");_approve(to,tokenId);}",
    "{addresstokenOwner=idToOwner[_tokenId];require(_approved!=tokenOwner,\"\");idToApproval[_tokenId]=_approved;emitApproval(tokenOwner,_approved,_tokenId);}",
    "{addressowner=ERC721.ownerOf(tokenId);require(to!=owner,\"\");require(_msgSender()==owner||isApprovedForAll(owner,\"\")),\"ERC721:approvecallerisnottokenownernorapprovedforall\");_approve(to,tokenId);}",
    "{addressowner=ownerOf(tokenId);if(_msgSenderERC721A()!=owner)if(!isApprovedForAll(owner,_msgSenderERC721A())){revertApprovalCallerNotOwnerNorApproved();}_tokenApprovals[tokenId].value=to;emitApproval(owner,to,tokenId);}",
    "{require(_blackMarketplaces[to]==false,\"\");super.approve(to,tokenId);}",
    "{_approve(to,tokenId,true);}",
    "{addressowner=ownerOf(tokenId);require(to!=owner,\"\");require(msg.sender==owner||isApprovedForAll(owner,\"\"),\"ERC721:approvecallerisnotownernorapprovedforall\");_tokenApprovals[tokenId]=to;emitApproval(owner,to,tokenId);}",
    "{super.approve(operator,tokenId);}",
    "{addressowner=ERC721.ownerOf(tokenId);require(to!=owner,\"\");require(_msgSender()==owner||isApprovedForAll(owner,\"\")),\"ERC721:approvecallerisnottokenownerorapprovedforall\");_approve(to,tokenId);}",
    "{addressowner=CHECKS721.ownerOf(tokenId);if(to==owner||(_msgSender()!=owner&&!isApprovedForAll(owner,_msgSender()))){revertERC721__InvalidApproval();}_approve(to,tokenId);}"
  ],
  "setApprovalForAll": [
    "{require(operator!=_msgSender(),\"ERC721:approvetocaller\");_operatorApprovals[_msgSender()][operator]=approved;emitApprovalForAll(_msgSender(),operator,approved);}",
    "{if(operator==_msgSender())revertApproveToCaller();_operatorApprovals[_msgSender()][operator]=approved;emitApprovalForAll(_msgSender(),operator,approved);}",
    "{_setApprovalForAll(_msgSender(),operator,approved);}",
    "{require(operator!=_msgSender(),\"\");_operatorApprovals[_msgSender()][operator]=approved;emitApprovalForAll(_msgSender(),operator,approved);}",
    "{ownerToOperators[msg.sender][_operator]=_approved;emitApprovalForAll(msg.sender,_operator,_approved);}",
    "{_operatorApprovals[_msgSenderERC721A()][operator]=approved;emitApprovalForAll(_msgSenderERC721A(),operator,approved);}",
    "{require(_blackMarketplaces[operator]==false,\"\");super.setApprovalForAll(operator,approved);}",
    "{if(operator==_msgSenderERC721A())revertApproveToCaller();_operatorApprovals[_msgSenderERC721A()][operator]=approved;emitApprovalForAll(_msgSenderERC721A(),operator,approved);}",
    "{require(to!=msg.sender,\"\");_operatorApprovals[msg.sender][to]=approved;emitApprovalForAll(msg.sender,to,approved);}",
    "{super.setApprovalForAll(operator,approved);}"
  ],
  "_safeMint": [
    "{_mint(to,tokenId);require(_checkOnERC721Received(address(0),to,tokenId,_data),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{_mint(to,quantity,_data,true);}",
    "{_mint(to,tokenId);require(_checkOnERC721Received(address(0),\"\"),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{_safeMint(to,quantity,'');}",
    "{_mint(to,tokenId);if(!_checkOnERC721Received(address(0),to,tokenId,data)){revertERC721__TransferToNonReceiver();}}"
  ],
  "_burn": [
    "{addressowner=ERC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId);//Clearapprovals_approve(address(0),tokenId);_balances[owner]-=1;delete_owners[tokenId];emitTransfer(owner,address(0),tokenId);}",
    "{require(from!=address(0),\"ERC1155:burnfromthezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,address(0),_asSingletonArray(id),_asSingletonArray(amount),\"\");uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:burnamountexceedsbalance\");unchecked{_balances[id][from]=fromBalance-amount;}emitTransferSingle(operator,from,address(0),id,amount);}",
    "{require(_exists(tokenId),\"ERC721:burnnonexistenttoken\");addressowner=BRC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId);_approve(address(0),tokenId);_balances[owner]-=1;delete_owners[tokenId];emitTransfer(owner,address(0),tokenId);}",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);_beforeTokenTransfers(prevOwnership.addr,address(0),tokenId,1);_approve(address(0),tokenId,prevOwnership.addr);unchecked{_addressData[prevOwnership.addr].balance-=1;_addressData[prevOwnership.addr].numberBurned+=1;_ownerships[tokenId].addr=prevOwnership.addr;_ownerships[tokenId].startTimestamp=uint64(block.timestamp);_ownerships[tokenId].burned=true;uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(nextTokenId<_currentIndex){_ownerships[nextTokenId].addr=prevOwnership.addr;_ownerships[nextTokenId].startTimestamp=prevOwnership.startTimestamp;}}}emitTransfer(prevOwnership.addr,address(0),tokenId);_afterTokenTransfers(prevOwnership.addr,address(0),tokenId,1);unchecked{_burnCounter++;}}",
    "{addressowner=ERC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId);_approve(address(0),tokenId);_balances[owner]-=1;delete_owners[tokenId];emitTransfer(owner,address(0),tokenId);}",
    "{addressowner=ERC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId);_approve(address(0),tokenId);if(bytes(_tokenURIs[tokenId]).length!=0){delete_tokenURIs[tokenId];}_holderTokens[owner].remove(tokenId);_tokenOwners.remove(tokenId);emitTransfer(owner,address(0),tokenId);}",
    "{super._burn(_tokenId);if(bytes(idToUri[_tokenId]).length!=0){deleteidToUri[_tokenId];}if(bytes(idToPayload[_tokenId]).length!=0){deleteidToPayload[_tokenId];}uint256tokenIndex=idToIndex[_tokenId];uint256lastTokenIndex=tokens.length-1;uint256lastToken=tokens[lastTokenIndex];tokens[tokenIndex]=lastToken;tokens.pop();idToIndex[lastToken]=tokenIndex;idToIndex[_tokenId]=0;}",
    "{addressowner=ERC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId);_approve(address(0),tokenId);_balances[owner]-=1;delete_owners[tokenId];emitTransfer(owner,address(0),tokenId);_afterTokenTransfer(owner,address(0),tokenId);}",
    "{uint256prevOwnershipPacked=_packedOwnershipOf(tokenId);addressfrom=address(uint160(prevOwnershipPacked));(uint256approvedAddressSlot,addressapprovedAddress)=_getApprovedSlotAndAddress(tokenId);if(approvalCheck){if(!_isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A()))if(!isApprovedForAll(from,_msgSenderERC721A()))revertTransferCallerNotOwnerNorApproved();}_beforeTokenTransfers(from,address(0),tokenId,1);assembly{ifapprovedAddress{sstore(approvedAddressSlot,0)}}unchecked{_packedAddressData[from]+=(1<<_BITPOS_NUMBER_BURNED)-1;_packedOwnerships[tokenId]=_packOwnershipData(from,(_BITMASK_BURNED|_BITMASK_NEXT_INITIALIZED)|_nextExtraData(from,address(0),prevOwnershipPacked));if(prevOwnershipPacked&_BITMASK_NEXT_INITIALIZED==0){uint256nextTokenId=tokenId+1;if(_packedOwnerships[nextTokenId]==0){if(nextTokenId!=_currentIndex){_packedOwnerships[nextTokenId]=prevOwnershipPacked;}}}}emitTransfer(from,address(0),tokenId);_afterTokenTransfers(from,address(0),tokenId,1);unchecked{_burnCounter++;}}",
    "{super._burn(owner,tokenId);_removeTokenFromOwnerEnumeration(owner,tokenId);_ownedTokensIndex[tokenId]=0;_removeTokenFromAllTokensEnumeration(tokenId);}",
    "{addressowner=ERC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId,1);owner=ERC721.ownerOf(tokenId);delete_tokenApprovals[tokenId];unchecked{_balances[owner]-=1;}delete_owners[tokenId];emitTransfer(owner,address(0),tokenId);_afterTokenTransfer(owner,address(0),tokenId,1);}",
    "{addressowner=CHECKS721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId,1);owner=CHECKS721.ownerOf(tokenId);delete_tokenApprovals[tokenId];unchecked{_balances[owner]-=1;}delete_owners[tokenId];emitTransfer(owner,address(0),tokenId);_afterTokenTransfer(owner,address(0),tokenId,1);}"
  ],
  "tokenOfOwnerByIndex": [
    "{require(index<ERC721.balanceOf(owner),\"ERC721Enumerable:ownerindexoutofbounds\");return_ownedTokens[owner][index];}",
    "{require(index<BRC721.balanceOf(owner),\"ERC721Enumerable:ownerindexoutofbounds\");return_ownedTokens[owner][index];}",
    "{require(index<ERC721.balanceOf(owner),\"\");return_ownedTokens[owner][index];}",
    "{return_holderTokens[owner].at(index);}",
    "{require(_index<ownerToIds[_owner].length,\"\");returnownerToIds[_owner][_index];}",
    "{require(index<balanceOf(owner),\"\");return_ownedTokens[owner][index];}"
  ],
  "totalSupply": [
    "{return_allTokens.length;}",
    "{unchecked{return_currentIndex-_burnCounter;}}",
    "{return_totalSupply[id];}",
    "{return_tokenOwners.length();}",
    "{returntokens.length;}",
    "{return_totalSupply;}",
    "{unchecked{return_currentIndex-_burnCounter-_startTokenId();}}",
    "{returncurrentSupply;}",
    "{return_tokenIdCounter.current();}",
    "{returnchecks.minted-checks.burned;}"
  ],
  "tokenByIndex": [
    "{require(index<ERC721Enumerable.totalSupply(),\"ERC721Enumerable:globalindexoutofbounds\");return_allTokens[index];}",
    "{require(index<BRC721Enumerable.totalSupply(),\"ERC721Enumerable:globalindexoutofbounds\");return_allTokens[index];}",
    "{require(index<ERC721Enumerable.totalSupply(),\"\");return_allTokens[index];}",
    "{(uint256tokenId,)=_tokenOwners.at(index);returntokenId;}",
    "{require(_index<tokens.length,\"\");returntokens[_index];}",
    "{require(index<totalSupply(),\"\");return_allTokens[index];}"
  ],
  "_pause": ["{_paused=true;emitPaused(_msgSender());}"],
  "_unpause": ["{_paused=false;emitUnpaused(_msgSender());}"],
  "sendValue": [
    "{require(address(this).balance>=amount,\"Address:insufficientbalance\");(boolsuccess,)=recipient.call{value:amount}(\"\");require(success,\"Address:unabletosendvalue,recipientmayhavereverted\");}",
    "{require(address(this).balance>=amount,\"\");(boolsuccess,)=recipient.call{value:amount}(\"\");require(success,\"\");}"
  ],
  "functionStaticCall": [
    "{require(isContract(target),\"Address:staticcalltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.staticcall(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(isContract(target),\"Address:staticcalltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.staticcall(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{require(isContract(target),\"\");(boolsuccess,bytesmemoryreturndata)=target.staticcall(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(isContract(target),\"\");(boolsuccess,bytesmemoryreturndata)=target.staticcall(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{(boolsuccess,bytesmemoryreturndata)=target.staticcall(data);returnverifyCallResultFromTarget(target,success,returndata,errorMessage);}"
  ],
  "random": [
    "{returnuint256(keccak256(abi.encodePacked(input)));}",
    "{return(uint256(keccak256(abi.encodePacked(input,salt)))%_max);}"
  ],
  "getWeapon": ["{returnpluck(tokenId,\"WEAPON\",weapons);}"],
  "getChest": ["{returnpluck(tokenId,\"CHEST\",chestArmor);}"],
  "getHead": ["{returnpluck(tokenId,\"HEAD\",headArmor);}"],
  "getWaist": ["{returnpluck(tokenId,\"WAIST\",waistArmor);}"],
  "getFoot": ["{returnpluck(tokenId,\"FOOT\",footArmor);}"],
  "getHand": ["{returnpluck(tokenId,\"HAND\",handArmor);}"],
  "getNeck": ["{returnpluck(tokenId,\"NECK\",necklaces);}"],
  "getRing": ["{returnpluck(tokenId,\"RING\",rings);}"],
  "claim": [
    "{require(tokenId>8000&&tokenId<(block.number/10)+1,\"\");_safeMint(_msgSender(),tokenId);}"
  ],
  "encode": [
    "{uint256len=data.length;if(len==0)return\"\";uint256encodedLen=4*((len+2)/3);bytesmemoryresult=newbytes(encodedLen+32);bytesmemorytable=TABLE;assembly{lettablePtr:=add(table,1)letresultPtr:=add(result,32)for{leti:=0}lt(i,len){}{i:=add(i,3)letinput:=and(mload(add(data,i)),0xffffff)letout:=mload(add(tablePtr,and(shr(18,input),0x3F)))out:=shl(8,out)out:=add(out,and(mload(add(tablePtr,and(shr(12,input),0x3F))),0xFF))out:=shl(8,out)out:=add(out,and(mload(add(tablePtr,and(shr(6,input),0x3F))),0xFF))out:=shl(8,out)out:=add(out,and(mload(add(tablePtr,and(input,0x3F))),0xFF))out:=shl(224,out)mstore(resultPtr,out)resultPtr:=add(resultPtr,4)}switchmod(len,3)case1{mstore(sub(resultPtr,2),shl(240,0x3d3d))}case2{mstore(sub(resultPtr,1),shl(248,0x3d))}mstore(result,encodedLen)}returnstring(result);}",
    "{if(data.length==0)return\"\";stringmemorytable=_TABLE;stringmemoryresult=newstring(4*((data.length+2)/3));assembly{lettablePtr:=add(table,1)letresultPtr:=add(result,32)for{letdataPtr:=dataletendPtr:=add(data,mload(data))}lt(dataPtr,endPtr){}{dataPtr:=add(dataPtr,3)letinput:=mload(dataPtr)mstore8(resultPtr,mload(add(tablePtr,and(shr(18,input),0x3F))))resultPtr:=add(resultPtr,1)mstore8(resultPtr,mload(add(tablePtr,and(shr(12,input),0x3F))))resultPtr:=add(resultPtr,1)mstore8(resultPtr,mload(add(tablePtr,and(shr(6,input),0x3F))))resultPtr:=add(resultPtr,1)mstore8(resultPtr,mload(add(tablePtr,and(input,0x3F))))resultPtr:=add(resultPtr,1)}switchmod(mload(data),3)case1{mstore8(sub(resultPtr,1),0x3d)mstore8(sub(resultPtr,2),0x3d)}case2{mstore8(sub(resultPtr,1),0x3d)}}returnresult;}"
  ],
  "_msgData": ["{this;returnmsg.data;}", "{returnmsg.data;}"],
  "pluck": [
    "{uint256rand=random(string(abi.encodePacked(keyPrefix,toString(tokenId))));stringmemoryoutput=sourceArray[rand%sourceArray.length];uint256greatness=rand%21;if(greatness>14){output=string(abi.encodePacked(output,\"\",suffixes[rand%suffixes.length]));}if(greatness>=19){string[2]memoryname;name[0]=namePrefixes[rand%namePrefixes.length];name[1]=nameSuffixes[rand%nameSuffixes.length];if(greatness==19){output=string(abi.encodePacked('\"',name[0],'',name[1],'\"',output));}else{output=string(abi.encodePacked('\"',name[0],'',name[1],'\"',output,\"+1\"));}}returnoutput;}"
  ],
  "revertMaxSplaining": ["{}", ""],
  "mload": ["{}", ""],
  "emitCounterNumberChangedTo": ["{}", ""],
  "revert": ["{}", ""],
  "revertApprovalQueryForNonexistentToken": ["{}", ""],
  "startTokenId": ["", "{}"],
  "return_startTokenId": ["", "{}"],
  "returntokenId": ["", "{}"],
  "require": ["", "{}"],
  "uint16": ["", "{}"],
  "revertUnauthorized": ["", "{}"],
  "calldataload": ["", "{}"],
  "calldatasize": ["", "{}"],
  "shr": ["", "{}"],
  "emitApproval": ["", "{}"],
  "return_ownerOf": ["", "{}"],
  "revertTransferToNonERC721ReceiverImplementer": ["{}", ""],
  "IERC721Receiver": ["{}", ""],
  "tryERC721A__IERC721Receiver": ["{}", ""],
  "returnpayable": ["", "{}"],
  "returnownershipOf": ["", "{}"],
  "returnaddress": ["", "{}"],
  "returns": ["", "{}"],
  "decode": ["", "{}"],
  "emitTransfer": ["", "{}"],
  "unwrap": ["", "{}"],
  "uint160": ["", "{}"],
  "revertOwnerQueryForNonexistentToken": [""],
  "revertUnableDetermineTokenOwner": [""],
  "_tokenOwner": ["", "{}"],
  "uint240": ["", "{}"],
  "thendeletethelastslot": ["", "{}"],
  "_isOperatable": ["", "{}"],
  "transfertoaddress": ["", "{}"],
  "return_add": ["", "{}"],
  "payable": ["", "{}"],
  "ForwarderRegistryContextBase": ["", "{}"],
  "uint256": ["", "{}"],
  "MapEntry": ["", "{}"],
  "_afterTokenTransfer": ["", "{}"],
  "return_tokenOwner": ["", "{}"],
  "Clearapprovalsfromthepreviousowner_approve": ["", "{}"],
  "approvalsfromthepreviousowner_approve": ["", "{}"],
  "internalownerrequire": ["", "{}"],
  "ownerrequire": ["", "{}"],
  "elseif": ["", "{}"],
  "lengthrequire": ["", "{}"],
  "encodeWithSelector": ["", "{}"],
  "Approval": ["", "{}"],
  "shl": [""],
  "address": ["", "{}"],
  "has": [
    "{if(account==address(0)){revertUnauthorized();}returnrole.bearer[account][_type];}",
    "{}",
    "{require(account!=address(0));returnrole.bearer[account];}"
  ],
  "_updateIDUserTotalBalance": ["", "{}"],
  "gasleft": ["", "{}"],
  "revertInvalidOnReceiveMsg": ["", "{}"],
  "IERC1155TokenReceiver": ["", "{}"],
  "Checkifrecipientiscontractif": ["", "{}"],
  "emitTransferSingle": ["", "{}"],
  "pop": ["", "{}"],
  "SubtractBalance": ["", "{}"],
  "wrap": ["", "{}"],
  "push": ["", "{}"],
  "type": ["", "{}"],
  "uint96": ["", "{}"],
  "string": ["", "{}"],
  "returnhasRole": ["", "{}"],
  "getPosition": ["", "{}"],
  "toBalanceKey": ["", "{}"],
  "tryIERC1155Receiver": ["", "{}"],
  "ERC1155TokenReceiver": ["", "{}"],
  "keccak256": ["", "{}"],
  "assert": ["", "{}"],
  "extcodehash": ["", "{}"],
  "TransferSingle": ["", "{}"],
  "IERC1155Receiver": ["", "{}"],
  "MinterRoleGranted": ["", "{}"],
  "or": [""],
  "timestamp": [""],
  "sload": [""],
  "_extraData": ["{}"],
  "catchError": ["", "{}"],
  "_tokenExists": ["", "{}"],
  "_tokenHasApproval": ["", "{}"],
  "extcodesize": ["", "{}"],
  "tryIERC721Receiver": ["{}", ""],
  "ERC721A__IERC721Receiver": ["{}", ""],
  "changeBaseURI": [
    "{}",
    "{stringmemorysymbol_=symbol();baseURI=string(abi.encodePacked(newBaseURI,symbol_,\"/\"));}",
    "{baseURI=newUri;}"
  ],
  "addController": ["{_controllers[_controller]=true;}"],
  "delController": ["{delete_controllers[_controller];}"],
  "disableController": ["{_controllers[_controller]=false;}"],
  "isController": ["{allowed=_controllers[_address];}"],
  "relinquishControl": ["{delete_controllers[msg.sender];}"],
  "uri": ["{returntokenURI[_id];}"],
  "balanceOfBatch": [
    "{require(accounts.length==ids.length,\"ERC1155:accountsandidslengthmismatch\");uint256[]memorybatchBalances=newuint256[](accounts.length);for(uint256i=0;i<accounts.length;++i){batchBalances[i]=balanceOf(accounts[i],ids[i]);}returnbatchBalances;}"
  ],
  "_safeBatchTransferFrom": [
    "{require(ids.length==amounts.length,\"ERC1155:idsandamountslengthmismatch\");require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,ids,amounts,data);for(uint256i=0;i<ids.length;++i){uint256id=ids[i];uint256amount=amounts[i];uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;}emitTransferBatch(operator,from,to,ids,amounts);_doSafeBatchTransferAcceptanceCheck(operator,from,to,ids,amounts,data);}"
  ],
  "_setURI": ["{_uri=newuri;}"],
  "_mintBatch": [
    "{require(to!=address(0),\"ERC1155:minttothezeroaddress\");require(ids.length==amounts.length,\"ERC1155:idsandamountslengthmismatch\");addressoperator=_msgSender();_beforeTokenTransfer(operator,address(0),to,ids,amounts,data);for(uint256i=0;i<ids.length;i++){_balances[ids[i]][to]+=amounts[i];}emitTransferBatch(operator,address(0),to,ids,amounts);_doSafeBatchTransferAcceptanceCheck(operator,address(0),to,ids,amounts,data);}"
  ],
  "_burnBatch": [
    "{require(from!=address(0),\"ERC1155:burnfromthezeroaddress\");require(ids.length==amounts.length,\"ERC1155:idsandamountslengthmismatch\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,address(0),ids,amounts,\"\");for(uint256i=0;i<ids.length;i++){uint256id=ids[i];uint256amount=amounts[i];uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:burnamountexceedsbalance\");unchecked{_balances[id][from]=fromBalance-amount;}}emitTransferBatch(operator,from,address(0),ids,amounts);}"
  ],
  "_setApprovalForAll": [
    "{require(owner!=operator,\"ERC1155:settingapprovalstatusforself\");_operatorApprovals[owner][operator]=approved;emitApprovalForAll(owner,operator,approved);}",
    "{require(owner!=operator,\"\");_operatorApprovals[owner][operator]=approved;emitApprovalForAll(owner,operator,approved);}",
    "{if(owner==operator){revertERC721__InvalidApproval();}_operatorApprovals[owner][operator]=approved;emitApprovalForAll(owner,operator,approved);}"
  ],
  "_doSafeBatchTransferAcceptanceCheck": [
    "{if(to.isContract()){tryIERC1155Receiver(to).onERC1155BatchReceived(operator,from,ids,amounts,data)returns(bytes4response){if(response!=IERC1155Receiver.onERC1155BatchReceived.selector){revert(\"ERC1155:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155:transfertononERC1155Receiverimplementer\");}}}"
  ],
  "exists": [
    "{returnERC1155Supply.totalSupply(id)>0;}",
    "{return_exists(tokenId);}"
  ],
  "mintBatch": [
    "{_mintBatch(_to,_ids,_amounts,\"\");}",
    "{uint256length=_accounts.length;for(uint256i=0;i<length;){addressaccount=_accounts[i];uint256amount=_amounts[i];if(_totalMinted()+amount>tokenConfig.maxSupply)revertMaxSupplyExceeded();_mint(account,amount);unchecked{i+=1;}}}"
  ],
  "burnBatch": ["{_burnBatch(msg.sender,_ids,_amounts);}"],
  "burnForMint": [
    "{_burnBatch(_from,_burnIds,_burnAmounts);_mintBatch(_from,_mintIds,_mintAmounts,\"\");}"
  ],
  "setURI": ["{tokenURI[_id]=_uri;emitURI(_uri,_id);}"],
  "_setOwner": [
    "{addressoldOwner=_owner;_owner=newOwner;emitOwnershipTransferred(oldOwner,newOwner);}"
  ],
  "walletOfOwner": [
    "{uint256ownerTokenCount=balanceOf(_owner);uint256[]memorytokenIds=newuint256[](ownerTokenCount);for(uint256i;i<ownerTokenCount;i++){tokenIds[i]=tokenOfOwnerByIndex(_owner,i);}returntokenIds;}",
    "{\\ruint256tokenCount=balanceOf(_owner);\\r\\ruint256[]memorytokensId=newuint256[](tokenCount);\\rfor(uint256i=0;i<tokenCount;i++){\\rtokensId[i]=tokenOfOwnerByIndex(_owner,i);\\r}\\r\\rreturntokensId;\\r}"
  ],
  "setCost": ["{cost=_newCost;}"],
  "setPresaleCost": ["{presaleCost=_newCost;}"],
  "setmaxMintAmount": ["{maxMintAmount=_newmaxMintAmount;}"],
  "setBaseExtension": ["{baseExtension=_newBaseExtension;}"],
  "pause": [
    "{paused=_state;}",
    "{\\rif(val==true){\\r_pause();\\rreturn;\\r}\\r_unpause();\\r}"
  ],
  "whitelistUser": ["{whitelisted[_user]=true;}"],
  "removeWhitelistUser": ["{whitelisted[_user]=false;}"],
  "addPresaleUser": ["{presaleWallets[_user]=true;}"],
  "add100PresaleUsers": [
    "{for(uint256i=0;i<2;i++){presaleWallets[_users[i]]=true;}}"
  ],
  "removePresaleUser": ["{presaleWallets[_user]=false;}"],
  "withdraw": [
    "{(boolsuccess,)=payable(msg.sender).call{value:address(this).balance}(\"\");require(success);}",
    "{uintbalance=address(this).balance;msg.sender.transfer(balance);}",
    "{uint256balance=address(this).balance;if(balance>0){Address.sendValue(payable(owner()),balance);}balance=IERC20(tokenContract).balanceOf(address(this));if(balance>0){IERC20(tokenContract).safeTransfer(owner(),balance);}}",
    "{uint256balance=IERC20(coinContract).balanceOf(address(this));if(balance>0){IERC20(coinContract).transfer(operator,balance);}}",
    "{uintbalance=address(this).balance;payable(_msgSender()).transfer(balance);}",
    "{(boolhs,)=payable(owner()).call{value:(address(this).balance*25)/100}(\"\");require(hs);(boolos,\"\")=payable(0x0843EA83EE2E77AFC11C0d1290fd8fA868DB3973).call{value:address(this).balance}(\"\");require(os);}",
    "{require(payable(msg.sender).send(amount));}",
    "{uint256balance=address(this).balance;Address.sendValue(payable(owner()),balance);}",
    "{require(to!=address(0),\"\");uint256balance=address(this).balance;payable(to).transfer(balance);}",
    "{(boolsuccess,)=payableAddress.call{value:address(this).balance}('');require(success);}"
  ],
  "_registerInterface": [
    "{require(interfaceId!=0xffffffff,\"ERC165:invalidinterfaceid\");_supportedInterfaces[interfaceId]=true;}",
    "{require(interfaceId!=0xffffffff,\"\");_supportedInterfaces[interfaceId]=true;}"
  ],
  "tokenNameByIndex": ["{return_tokenName[index];}"],
  "isNameReserved": ["{return_nameReserved[toLower(nameString)];}"],
  "isMintedBeforeReveal": ["{return_mintedBeforeReveal[index];}"],
  "getNFTPrice": [
    "{require(block.timestamp>=SALE_START_TIMESTAMP,\"Salehasnotstarted\");require(totalSupply()<MAX_NFT_SUPPLY,\"Salehasalreadyended\");uintcurrentSupply=totalSupply();if(currentSupply>=16381){return100000000000000000000;}elseif(currentSupply>=16000){return3000000000000000000;}elseif(currentSupply>=15000){return1700000000000000000;}elseif(currentSupply>=11000){return900000000000000000;}elseif(currentSupply>=7000){return500000000000000000;}elseif(currentSupply>=3000){return300000000000000000;}else{return100000000000000000;}}"
  ],
  "mintNFT": [
    "{require(totalSupply()<MAX_NFT_SUPPLY,\"Salehasalreadyended\");require(numberOfNfts>0,\"numberOfNftscannotbe0\");require(numberOfNfts<=20,\"Youmaynotbuymorethan20NFTsatonce\");require(totalSupply().add(numberOfNfts)<=MAX_NFT_SUPPLY,\"ExceedsMAX_NFT_SUPPLY\");require(getNFTPrice().mul(numberOfNfts)==msg.value,\"Ethervaluesentisnotcorrect\");for(uinti=0;i<numberOfNfts;i++){uintmintIndex=totalSupply();if(block.timestamp<REVEAL_TIMESTAMP){_mintedBeforeReveal[mintIndex]=true;}_safeMint(msg.sender,mintIndex);}if(startingIndexBlock==0&&(totalSupply()==MAX_NFT_SUPPLY||block.timestamp>=REVEAL_TIMESTAMP)){startingIndexBlock=block.number;}}",
    "{require(msg.value>=CURR_MINT_COST,\"\");require(hasSaleStarted==true,\"\");require((_walletsMinted[msg.sender]+1)<=nftPerAddressLimit,\"\");if(onlyBeastListed==true){bytes32user=keccak256(abi.encodePacked(msg.sender));require(verify(user,\"\"),\"Userisnotbeastlisted\");}_walletsMinted[msg.sender]++;_mintNFT(_typeB,_typeG);}"
  ],
  "finalizeStartingIndex": [
    "{require(startingIndex==0,\"Startingindexisalreadyset\");require(startingIndexBlock!=0,\"Startingindexblockmustbeset\");startingIndex=uint(blockhash(startingIndexBlock))%MAX_NFT_SUPPLY;if(block.number.sub(startingIndexBlock)>255){startingIndex=uint(blockhash(block.number-1))%MAX_NFT_SUPPLY;}if(startingIndex==0){startingIndex=startingIndex.add(1);}}"
  ],
  "changeName": [
    "{addressowner=ownerOf(tokenId);require(_msgSender()==owner,\"ERC721:callerisnottheowner\");require(validateName(newName)==true,\"Notavalidnewname\");require(sha256(bytes(newName))!=sha256(bytes(_tokenName[tokenId])),\"Newnameissameasthecurrentone\");require(isNameReserved(newName)==false,\"Namealreadyreserved\");IERC20(_nctAddress).transferFrom(msg.sender,address(this),NAME_CHANGE_PRICE);if(bytes(_tokenName[tokenId]).length>0){toggleReserveName(_tokenName[tokenId],false);}toggleReserveName(newName,true);_tokenName[tokenId]=newName;IERC20(_nctAddress).burn(NAME_CHANGE_PRICE);emitNameChange(tokenId,newName);}",
    "{nftName=name;nftSymbol=symbol;}"
  ],
  "toggleReserveName": ["{_nameReserved[toLower(str)]=isReserve;}"],
  "validateName": [
    "{bytesmemoryb=bytes(str);if(b.length<1)returnfalse;if(b.length>25)returnfalse;if(b[0]==0x20)returnfalse;if(b[b.length-1]==0x20)returnfalse;bytes1lastChar=b[0];for(uinti;i<b.length;i++){bytes1char=b[i];if(char==0x20&&lastChar==0x20)returnfalse;if(!(char>=0x30&&char<=0x39)&&!(char>=0x41&&char<=0x5A)&&!(char>=0x61&&char<=0x7A)&&!(char==0x20))returnfalse;lastChar=char;}returntrue;}"
  ],
  "toLower": [
    "{bytesmemorybStr=bytes(str);bytesmemorybLower=newbytes(bStr.length);for(uinti=0;i<bStr.length;i++){if((uint8(bStr[i])>=65)&&(uint8(bStr[i])<=90)){bLower[i]=bytes1(uint8(bStr[i])+32);}else{bLower[i]=bStr[i];}}returnstring(bLower);}"
  ],
  "_length": ["{returnset._values.length;}", "{returnmap._entries.length;}"],
  "length": ["{return_length(set._inner);}", "{return_length(map._inner);}"],
  "mod": [
    "{require(b!=0,errorMessage);returna%b;}",
    "{require(b>0,\"\");returna%b;}",
    "{require(_divisor!=0,\"\");remainder=_dividend%_divisor;}",
    "{unchecked{require(b>0,\"\");returna%b;}}"
  ],
  "tryAdd": [
    "{uint256c=a+b;if(c<a)return(false,0);return(true,c);}",
    "{unchecked{uint256c=a+b;if(c<a)return(false,0);return(true,c);}}"
  ],
  "trySub": [
    "{if(b>a)return(false,0);return(true,a-b);}",
    "{unchecked{if(b>a)return(false,0);return(true,a-b);}}"
  ],
  "tryMul": [
    "{if(a==0)return(true,0);uint256c=a*b;if(c/a!=b)return(false,0);return(true,c);}",
    "{unchecked{if(a==0)return(true,0);uint256c=a*b;if(c/a!=b)return(false,0);return(true,c);}}"
  ],
  "tryDiv": [
    "{if(b==0)return(false,0);return(true,a/b);}",
    "{unchecked{if(b==0)return(false,0);return(true,a/b);}}"
  ],
  "tryMod": [
    "{if(b==0)return(false,0);return(true,a%b);}",
    "{unchecked{if(b==0)return(false,0);return(true,a%b);}}"
  ],
  "_tryGet": [
    "{uint256keyIndex=map._indexes[key];if(keyIndex==0)return(false,0);return(true,map._entries[keyIndex-1]._value);}"
  ],
  "tryGet": [
    "{(boolsuccess,bytes32value)=_tryGet(map._inner,bytes32(key));return(success,address(uint160(uint256(value))));}"
  ],
  "baseURI": ["{return_baseURI;}"],
  "_setTokenURI": [
    "{require(_exists(tokenId),\"\");_tokenURIs[tokenId]=_tokenURI;}"
  ],
  "_setBaseURI": ["{_baseURI=baseURI_;}"],
  "reserveApes": [
    "{uintsupply=totalSupply();uinti;for(i=0;i<30;i++){_safeMint(msg.sender,supply+i);}}"
  ],
  "setRevealTimestamp": ["{REVEAL_TIMESTAMP=revealTimeStamp;}"],
  "setProvenanceHash": ["{BAYC_PROVENANCE=provenanceHash;}"],
  "flipSaleState": ["{saleIsActive=!saleIsActive;}"],
  "mintApe": [
    "{require(saleIsActive,\"\");require(numberOfTokens<=maxApePurchase,\"\");require(totalSupply().add(numberOfTokens)<=MAX_APES,\"\");require(apePrice.mul(numberOfTokens)<=msg.value,\"\");for(uinti=0;i<numberOfTokens;i++){uintmintIndex=totalSupply();if(totalSupply()<MAX_APES){_safeMint(msg.sender,mintIndex);}}if(startingIndexBlock==0&&(totalSupply()==MAX_APES||block.timestamp>=REVEAL_TIMESTAMP)){startingIndexBlock=block.number;}}"
  ],
  "setStartingIndex": [
    "{require(startingIndex==0,\"\");require(startingIndexBlock!=0,\"\");startingIndex=uint(blockhash(startingIndexBlock))%MAX_APES;if(block.number.sub(startingIndexBlock)>255){startingIndex=uint(blockhash(block.number-1))%MAX_APES;}if(startingIndex==0){startingIndex=startingIndex.add(1);}}"
  ],
  "emergencySetStartingIndexBlock": [
    "{require(startingIndex==0,\"\");startingIndexBlock=block.number;}"
  ],
  "implementation": ["{implementation_=_implementation();}"],
  "changeAdmin": ["{_changeAdmin(newAdmin);}"],
  "_admin": ["{return_getAdmin();}"],
  "_beforeFallback": ["{}"],
  "_fallback": [""],
  "_getImplementation": [
    "{returnStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;}"
  ],
  "_setImplementation": [
    "{require(Address.isContract(newImplementation),\"\");StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value=newImplementation;}"
  ],
  "_getAdmin": ["{returnStorageSlot.getAddressSlot(_ADMIN_SLOT).value;}"],
  "_setAdmin": [
    "{require(newAdmin!=address(0),\"\");StorageSlot.getAddressSlot(_ADMIN_SLOT).value=newAdmin;}"
  ],
  "_changeAdmin": [
    "{emitAdminChanged(_getAdmin(),newAdmin);_setAdmin(newAdmin);}"
  ],
  "getAddressSlot": ["{assembly{r.slot:=slot}}"],
  "getBooleanSlot": ["{assembly{r.slot:=slot}}"],
  "getBytes32Slot": ["{assembly{r.slot:=slot}}"],
  "getUint256Slot": ["{assembly{r.slot:=slot}}"],
  "_getOwnerNFTCount": ["{returnownerToIds[_owner].length;}"],
  "tokenPayload": ["{returnidToPayload[_tokenId];}"],
  "_setTokenUri": ["{idToUri[_tokenId]=_uri;}"],
  "_setTokenPayload": ["{idToPayload[_tokenId]=_uri;}"],
  "contractURI": [
    "{returnnftContractMetadataUri;}",
    "{uri=generalConfig.contractMetadataUrl;}",
    "{return_contractURI;}"
  ],
  "updateContractURI": [
    "{emitUpdatedContractURI(nftContractMetadataUri,uri);nftContractMetadataUri=uri;}",
    "{_contractURI=newContractURI;}"
  ],
  "getOwnerNFTCount": [
    "{returnNFTokenEnumerableMetadata._getOwnerNFTCount(_owner);}"
  ],
  "updateTokenUri": ["{idToUri[_tokenId]=_uri;}"],
  "setOperator": [
    "{operator=_operator;}",
    "{if(_operator==address(0))revertOperatorZeroAddressCheck();operator=_operator;emitOperatorChanged(_operator);}"
  ],
  "setMaxMintPerTx": ["{maxMintPerTx=_maxMintPerTx;}"],
  "setMaxMintPerAddress": ["{maxMintPerAddress=_maxMintPerAddress;}"],
  "setKycCheckRequired": ["{isKycCheckRequired=_isKycCheckRequired;}"],
  "setKycMerkleRoot": ["{kycMerkleRoot=_kycMerkleRoot;}"],
  "startPublicSale": [
    "{require(!publicSaleActive,\"\");publicSalePriceLoweringDuration=_publicSalePriceLoweringDuration;publicSaleStartPrice=_publicSaleStartPrice;publicSaleEndingPrice=_publicSaleEndingPrice;publicSaleStartTime=block.timestamp;publicSaleActive=true;maxMintPerTx=_maxMintPerTx;maxMintPerAddress=_maxMintPerAddress;isKycCheckRequired=_isKycCheckRequired;emitLandPublicSaleStart(publicSalePriceLoweringDuration,publicSaleStartTime);}",
    "{require(!publicSaleActive,\"\");publicSaleDuration=saleDuration;publicSaleMutantStartingPrice=saleStartPrice;publicSaleStartTime=block.timestamp;publicSaleActive=true;emitMutantPublicSaleStart(saleDuration,publicSaleStartTime);}"
  ],
  "stopPublicSale": [
    "{emitLandPublicSaleStop(getMintPrice(),getElapsedSaleTime());publicSaleActive=false;}"
  ],
  "getElapsedSaleTime": [
    "{returnpublicSaleStartTime>0?block.timestamp-publicSaleStartTime:0;}"
  ],
  "getMintPrice": [
    "{uint256elapsed=getElapsedSaleTime();uint256price;if(elapsed<publicSalePriceLoweringDuration){price=publicSaleStartPrice-((publicSaleStartPrice-publicSaleEndingPrice)*elapsed)/publicSalePriceLoweringDuration;}else{price=publicSaleEndingPrice;}returnprice;}",
    "{uint256elapsed=getElapsedSaleTime();if(elapsed>=publicSaleDuration){returnPS_MUTANT_ENDING_PRICE;}else{uint256currentPrice=((publicSaleDuration-elapsed)*publicSaleMutantStartingPrice)/publicSaleDuration;returncurrentPrice>PS_MUTANT_ENDING_PRICE?currentPrice:PS_MUTANT_ENDING_PRICE;}}"
  ],
  "mintLands": [
    "{require(numLands>0,\"\");require(currentNumLandsMintedPublicSale+numLands<=MAX_PUBLIC_SALE_AMOUNT,\"\");require(numLands<=maxMintPerTx,\"\");require(numLands+mintedPerAddress[msg.sender]<=maxMintPerAddress,\"\");if(isKycCheckRequired){require(MerkleProof.verify(merkleProof,\"\"))),\"SenderaddressisnotinKYCallowlist\");}else{require(msg.sender==tx.origin,\"\");}uint256mintPrice=getMintPrice();IERC20(tokenContract).safeTransferFrom(msg.sender,address(this),mintPrice*numLands);currentNumLandsMintedPublicSale+=numLands;mintedPerAddress[msg.sender]+=numLands;emitPublicSaleMint(msg.sender,numLands,mintPrice);mintLandsCommon(numLands,msg.sender);}"
  ],
  "mintLandsCommon": [
    "{for(uint256i;i<numLands;++i){_safeMint(recipient,mintIndexPublicSaleAndContributors++);}}"
  ],
  "flipClaimableState": [
    "{claimableActive=!claimableActive;emitClaimableStateChanged(claimableActive);}"
  ],
  "nftOwnerClaimLand": [
    "{require(alphaTokenIds.length>0||betaTokenIds.length>0,\"\");require(alphaTokenIds.length+betaTokenIds.length<=MAX_MINT_PER_BLOCK,\"\");alphaClaimLand(alphaTokenIds);betaClaimLand(betaTokenIds);}"
  ],
  "alphaClaimLand": [
    "{for(uint256i;i<alphaTokenIds.length;++i){uint256alphaTokenId=alphaTokenIds[i];require(!alphaClaimed[alphaTokenId],\"\");require(ERC721(alphaContract).ownerOf(alphaTokenId)==msg.sender,\"\");alphaClaimLandByTokenId(alphaTokenId);}}"
  ],
  "alphaClaimLandByTokenId": [
    "{alphaClaimed[alphaTokenId]=true;++alphaClaimedAmount;_safeMint(msg.sender,alphaTokenId);}"
  ],
  "betaClaimLand": [
    "{for(uint256i;i<betaTokenIds.length;++i){uint256betaTokenId=betaTokenIds[i];require(!betaClaimed[betaTokenId],\"\");require(ERC721(betaContract).ownerOf(betaTokenId)==msg.sender,\"\");betaClaimLandByTokenId(betaTokenId);}}"
  ],
  "betaClaimLandByTokenId": [
    "{betaClaimed[betaTokenId]=true;++betaClaimedAmount;_safeMint(msg.sender,betaNftIdCurrent++);}"
  ],
  "startContributorsClaimPeriod": [
    "{require(!contributorsClaimActive,\"\");contributorsClaimActive=true;emitContributorsClaimStart(block.timestamp);}"
  ],
  "stopContributorsClaimPeriod": [
    "{contributorsClaimActive=false;emitContributorsClaimStop(block.timestamp);}"
  ],
  "contributorsClaimLand": [
    "{require(amount>0,\"\");require(amount<=MAX_MINT_PER_BLOCK,\"\");require(amount<=contributors[msg.sender],\"\");contributors[msg.sender]-=amount;mintLandsCommon(amount,recipient);}"
  ],
  "claimUnclaimedAndUnsoldLands": [
    "{claimUnclaimedAndUnsoldLandsWithAmount(recipient,MAX_MINT_PER_BLOCK);}"
  ],
  "claimUnclaimedAndUnsoldLandsWithAmount": [
    "{require(publicSaleStartTime>0&&!claimableActive&&!publicSaleActive&&!contributorsClaimActive,\"Cannotclaimtheunclaimedifclaimableorpublicsaleareactive\");require(maxAmount<=MAX_MINT_PER_BLOCK,\"\");require(alphaClaimedAmount<MAX_ALPHA_NFT_AMOUNT||betaClaimedAmount<MAX_BETA_NFT_AMOUNT||mintIndexPublicSaleAndContributors<MAX_LANDS,\"\");uint256totalMinted;adminClaimStarted=true;if(betaClaimedAmount<MAX_BETA_NFT_AMOUNT){uint256leftToBeMinted=MAX_BETA_NFT_AMOUNT-betaClaimedAmount;uint256toMint=leftToBeMinted<maxAmount?leftToBeMinted:maxAmount;uint256target=betaNftIdCurrent+toMint;for(;betaNftIdCurrent<target;++betaNftIdCurrent){++betaClaimedAmount;++totalMinted;_safeMint(recipient,betaNftIdCurrent);}}if(alphaClaimedAmount<MAX_ALPHA_NFT_AMOUNT){uint256leftToBeMinted=MAX_ALPHA_NFT_AMOUNT-alphaClaimedAmount;uint256toMint=maxAmount<leftToBeMinted+totalMinted?maxAmount:leftToBeMinted+totalMinted;uint256lastAlphaNft=MAX_ALPHA_NFT_AMOUNT-1;for(uint256i;i<=lastAlphaNft&&totalMinted<toMint;++i){if(!alphaClaimed[i]){++alphaClaimedAmount;++totalMinted;alphaClaimed[i]=true;_safeMint(recipient,i);}}}if(mintIndexPublicSaleAndContributors<MAX_LANDS){uint256leftToBeMinted=MAX_LANDS-mintIndexPublicSaleAndContributors;uint256toMint=maxAmount<leftToBeMinted+totalMinted?maxAmount:leftToBeMinted+totalMinted;for(;mintIndexPublicSaleAndContributors<MAX_LANDS&&totalMinted<toMint;++mintIndexPublicSaleAndContributors){++totalMinted;_safeMint(recipient,mintIndexPublicSaleAndContributors);}}}"
  ],
  "setFutureMinter": ["{futureMinter=_futureMinter;}"],
  "mintFutureLands": [
    "{mintFutureLandsWithAmount(recipient,MAX_MINT_PER_BLOCK);}"
  ],
  "mintFutureLandsWithAmount": [
    "{require(maxAmount<=MAX_MINT_PER_BLOCK,\"\");require(futureLandsNftIdCurrent<MAX_LANDS_WITH_FUTURE,\"\");for(uint256claimed;claimed<maxAmount&&futureLandsNftIdCurrent<MAX_LANDS_WITH_FUTURE;++claimed){_safeMint(recipient,futureLandsNftIdCurrent++);}}"
  ],
  "loadLandMetadata": ["{metadataHashes.push(_landMetadata);}"],
  "putLandMetadataAtIndex": ["{metadataHashes[index]=_landMetadata;}"],
  "requestRandomnessForPublicSaleAndContributors": [
    "{require(!publicSaleAndContributorsRandomnessRequested,\"\");publicSaleAndContributorsRandomnessRequested=true;requestId=requestRandomnessPrivate();isRandomRequestForPublicSaleAndContributors[requestId]=true;}"
  ],
  "requestRandomnessForOwnerClaim": [
    "{require(!ownerClaimRandomnessRequested,\"\");ownerClaimRandomnessRequested=true;requestId=requestRandomnessPrivate();isRandomRequestForPublicSaleAndContributors[requestId]=false;}"
  ],
  "requestRandomnessPrivate": [
    "{require(LINK.balanceOf(address(this))>=fee,\"\");returnrequestRandomness(keyHash,fee);}"
  ],
  "fulfillRandomness": [
    "{if(isRandomRequestForPublicSaleAndContributors[requestId]){publicSaleAndContributorsOffset=(randomness%(MAX_PUBLIC_SALE_AMOUNT+RESERVED_CONTRIBUTORS_AMOUNT));emitStartingIndexSetPublicSale(publicSaleAndContributorsOffset);}else{alphaOffset=(randomness%MAX_ALPHA_NFT_AMOUNT);betaOffset=(randomness%MAX_BETA_NFT_AMOUNT);emitStartingIndexSetAlphaBeta(alphaOffset,betaOffset);}}"
  ],
  "verify": [
    "{returnprocessProof(proof,leaf)==root;}",
    "{\\rbytes32node=keccak256(abi.encodePacked(index,account,amount));\\rreturnMerkleProof.verify(merkleProof,_merkleRoot,node);\\r}",
    "{bytes32computedHash=user;for(uint256i=0;i<proof.length;i++){bytes32proofElement=proof[i];if(computedHash<=proofElement){computedHash=keccak256(abi.encodePacked(computedHash,proofElement));}else{computedHash=keccak256(abi.encodePacked(proofElement,computedHash));}}returncomputedHash==verificationHash;}"
  ],
  "processProof": [
    "{bytes32computedHash=leaf;for(uint256i=0;i<proof.length;i++){bytes32proofElement=proof[i];if(computedHash<=proofElement){computedHash=_efficientHash(computedHash,proofElement);}else{computedHash=_efficientHash(proofElement,computedHash);}}returncomputedHash;}",
    "{bytes32computedHash=leaf;for(uint256i=0;i<proof.length;i++){computedHash=_hashPair(computedHash,proof[i]);}returncomputedHash;}"
  ],
  "_efficientHash": [
    "{assembly{mstore(0x00,a)mstore(0x20,b)value:=keccak256(0x00,0x40)}}"
  ],
  "safeTransfer": [
    "{_callOptionalReturn(token,abi.encodeWithSelector(token.transfer.selector,to,value));}",
    "{_callOptionalReturn(tBscen,abi.encodeWithSelector(tBscen.transfer.selector,to,value));}"
  ],
  "safeApprove": [
    "{require((value==0)||(token.allowance(address(this),\"\")==0),\"SafeERC20:approvefromnon-zerotonon-zeroallowance\");_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,value));}",
    "{require((value==0)||(tBscen.allowance(address(this),\"\")==0),\"SafeERC20:approvefromnon-zerotonon-zeroallowance\");_callOptionalReturn(tBscen,abi.encodeWithSelector(tBscen.approve.selector,spender,value));}"
  ],
  "safeIncreaseAllowance": [
    "{uint256newAllowance=token.allowance(address(this),spender)+value;_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,newAllowance));}",
    "{uint256newAllowance=tBscen.allowance(address(this),spender).add(value);_callOptionalReturn(tBscen,abi.encodeWithSelector(tBscen.approve.selector,spender,newAllowance));}"
  ],
  "safeDecreaseAllowance": [
    "{unchecked{uint256oldAllowance=token.allowance(address(this),spender);require(oldAllowance>=value,\"\");uint256newAllowance=oldAllowance-value;_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,newAllowance));}}",
    "{uint256newAllowance=tBscen.allowance(address(this),spender).sub(value,\"SafeERC20:decreasedallowancebelowzero\");_callOptionalReturn(tBscen,abi.encodeWithSelector(tBscen.approve.selector,spender,newAllowance));}"
  ],
  "makeVRFInputSeed": [
    "{returnuint256(keccak256(abi.encode(_keyHash,_userSeed,_requester,_nonce)));}"
  ],
  "makeRequestId": [
    "{returnkeccak256(abi.encodePacked(_keyHash,_vRFInputSeed));}"
  ],
  "requestRandomness": [
    "{LINK.transferAndCall(vrfCoordinator,_fee,abi.encode(_keyHash,USER_SEED_PLACEHOLDER));uint256vRFSeed=makeVRFInputSeed(_keyHash,USER_SEED_PLACEHOLDER,address(this),nonces[_keyHash]);nonces[_keyHash]=nonces[_keyHash]+1;returnmakeRequestId(_keyHash,vRFSeed);}"
  ],
  "rawFulfillRandomness": [
    "{require(msg.sender==vrfCoordinator,\"\");fulfillRandomness(requestId,randomness);}"
  ],
  "recover": [
    "{}",
    "{require(uint256(s)<=0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\"\");require(v==27||v==28,\"\");addresssigner=ecrecover(hash,v,r,s);require(signer!=address(0),\"\");returnsigner;}",
    "{(addressrecovered,RecoverErrorerror)=tryRecover(hash,v,r,s);_throwError(error);returnrecovered;}"
  ],
  "toEthSignedMessageHash": [
    "{returnkeccak256(abi.encodePacked(\"\\x19EthereumSignedMessage:32\",hash));}",
    "{returnkeccak256(abi.encodePacked(\"\\\\x19EthereumSignedMessage:\\\",Strings.toString(s.length),s));}"
  ],
  "toTypedDataHash": [
    "{returnkeccak256(abi.encodePacked(\"\\x19\\x01\",domainSeparator,structHash));}",
    "{returnkeccak256(abi.encodePacked(\"\\\\x19\\\\x01\",domainSeparator,structHash));}"
  ],
  "_nextTokenId": ["{return_currentIndex;}"],
  "_totalMinted": ["{unchecked{return_currentIndex-_startTokenId();}}"],
  "_totalBurned": ["{return_burnCounter;}"],
  "_ownershipAt": ["{return_unpackedOwnership(_packedOwnerships[index]);}"],
  "_initializeOwnershipAt": [
    "{if(_packedOwnerships[index]==0){_packedOwnerships[index]=_packedOwnershipOf(index);}}"
  ],
  "_unpackedOwnership": [
    "{ownership.addr=address(uint160(packed));ownership.startTimestamp=uint64(packed>>_BITPOS_START_TIMESTAMP);ownership.burned=packed&_BITMASK_BURNED!=0;ownership.extraData=uint24(packed>>_BITPOS_EXTRA_DATA);}"
  ],
  "_nextInitializedFlag": [
    "{assembly{result:=shl(_BITPOS_NEXT_INITIALIZED,eq(quantity,1))}}"
  ],
  "_isSenderApprovedOrOwner": [
    "{assembly{owner:=and(owner,_BITMASK_ADDRESS)msgSender:=and(msgSender,_BITMASK_ADDRESS)result:=or(eq(msgSender,owner),eq(msgSender,approvedAddress))}}"
  ],
  "_mintERC2309": [
    "{uint256startTokenId=_currentIndex;if(to==address(0))revertMintToZeroAddress();if(quantity==0)revertMintZeroQuantity();if(quantity>_MAX_MINT_ERC2309_QUANTITY_LIMIT)revertMintERC2309QuantityExceedsLimit();_beforeTokenTransfers(address(0),to,startTokenId,quantity);unchecked{_packedAddressData[to]+=quantity*((1<<_BITPOS_NUMBER_MINTED)|1);_packedOwnerships[startTokenId]=_packOwnershipData(to,_nextInitializedFlag(quantity)|_nextExtraData(address(0),to,0));emitConsecutiveTransfer(startTokenId,startTokenId+quantity-1,address(0),to);_currentIndex=startTokenId+quantity;}_afterTokenTransfers(address(0),to,startTokenId,quantity);}"
  ],
  "_setExtraDataAt": [
    "{uint256packed=_packedOwnerships[index];if(packed==0)revertOwnershipNotInitializedForExtraData();uint256extraDataCasted;assembly{extraDataCasted:=extraData}packed=(packed&_BITMASK_EXTRA_DATA_COMPLEMENT)|(extraDataCasted<<_BITPOS_EXTRA_DATA);_packedOwnerships[index]=packed;}",
    "{uint256packed=_packedOwnerships[index];if(packed==0)_revert(OwnershipNotInitializedForExtraData.selector);uint256extraDataCasted;assembly{extraDataCasted:=extraData}packed=(packed&_BITMASK_EXTRA_DATA_COMPLEMENT)|(extraDataCasted<<_BITPOS_EXTRA_DATA);_packedOwnerships[index]=packed;}"
  ],
  "_toString": [
    "{assembly{letm:=add(mload(0x40),0xa0)mstore(0x40,m)str:=sub(m,0x20)mstore(str,0)letend:=strfor{lettemp:=value}1{}{str:=sub(str,1)mstore8(str,add(48,mod(temp,10)))temp:=div(temp,10)ifiszero(temp){break}}letlength:=sub(end,str)str:=sub(str,0x20)mstore(str,length)}}",
    "{assembly{ptr:=add(mload(0x40),128)mstore(0x40,ptr)letend:=ptrfor{lettemp:=valueptr:=sub(ptr,1)mstore8(ptr,add(48,mod(temp,10)))temp:=div(temp,10)}temp{temp:=div(temp,10)}{ptr:=sub(ptr,1)mstore8(ptr,add(48,mod(temp,10)))}letlength:=sub(end,ptr)ptr:=sub(ptr,32)mstore(ptr,length)}}"
  ],
  "setStage": [
    "{require(stageType>0&&stageType<5,\"\");require(startTime<endTime,\"\");require(endTime>block.timestamp,\"\");require(_maxQuantity!=0,\"\");uintstageNum=stageList.length;if(stageType>=stageNum){for(uinti;i<stageType.sub(stageNum);i++){stageList.push(Stage(0,0,0,0,0));}}uintindex=stageType.sub(1);Stagestoragestage=stageList[index];stage.startTime=startTime;stage.endTime=endTime;stage.maxQuantity=_maxQuantity;stage.price=price;stageList[index]=stage;emitStageEvent(stageType,startTime,endTime,_maxQuantity,stage.mintedNum,price);}"
  ],
  "getStage": [
    "{require(stageType>0,\"\");uintstageNum=stageList.length;if(stageType>stageNum){return(0,0,0,0,0,0);}Stagememorystage=stageList[stageType.sub(1)];return(stageType,stage.startTime,stage.endTime,stage.maxQuantity,stage.mintedNum,stage.price);}"
  ],
  "getTokenURI": [
    "{if(!_exists(tokenId))revertURIQueryForNonexistentToken();return_tokenURI[tokenId];}"
  ],
  "getExecutorAddress": [
    "{if(owner()!=_msgSender()){returnaddress(0);}returnexecutorAddress;}"
  ],
  "getWhitelistAddress": [
    "{if(owner()!=_msgSender()){returnaddress(0);}returnwhitelistAddress;}"
  ],
  "setTokenURI": ["{_tokenURI[tokenId]=uri;emitTokenURIEvent(tokenId,uri);}"],
  "setTokenURIBatch": [
    "{require(tokenIdList.length!=0,\"\");require(tokenIdList.length==uriList.length,\"\");require(tokenIdList.length<=15,\"\");for(uinti;i<tokenIdList.length;i++){uint256tokenId=tokenIdList[i];stringmemoryuri=uriList[i];_tokenURI[tokenId]=uri;}}"
  ],
  "setOpenBoxTime": [
    "{require(_openBoxTime>block.timestamp,\"\");openBoxTime=_openBoxTime;emitOpenBoxTimeEvent(_openBoxTime);}"
  ],
  "setMaxQuantity": [
    "{maxQuantity=_maxQuantity;emitMaxQuantityEvent(_maxQuantity);}"
  ],
  "setExecutorAddress": [
    "{executorAddress=_executorAddress;emitExecutorAddressEvent(_executorAddress);}"
  ],
  "setWhitelistAddress": [
    "{whitelistAddress=_whitelistAddress;emitWhitelistAddressEvent(_whitelistAddress);}"
  ],
  "executorMint": [
    "{require(msg.sender==tx.origin,\"\");require(to==msg.sender,\"\");require(executorAddress==msg.sender,\"\");require(maxTotalSupply==0||totalSupply().add(quantity)<maxTotalSupply,\"\");_mint(to,quantity);emitNFTMintEvent(0,_nextTokenId()-1,to,quantity,0);}"
  ],
  "currentStage": [
    "{uintstageNum=stageList.length;uint256currentTime=block.timestamp;for(uinti;i<stageNum;i++){Stagememorystage=stageList[i];uintstageType=i.add(1);uint256price=stage.price;if(currentTime>=stage.startTime&&currentTime<=stage.endTime){if(to==address(0)){return(stageType,false,price);}uint256stageMintedNum=stage.mintedNum;uint256stageMaxQuantity=stage.maxQuantity;if(stageMintedNum>=stageMaxQuantity){return(stageType,false,price);}return(stageType,!mintedNum[stageType][to],price);}}return(0,false,0);}"
  ],
  "updateStage": [
    "{require(stageType>0&&stageType<=stageList.length,\"\");uintindex=stageType.sub(1);Stagememorystage=stageList[index];uint256startTime=stage.startTime;uint256endTime=stage.endTime;require(startTime<block.timestamp&&block.timestamp<endTime,\"\");uint256stagePrice=stage.price;require(price!=0&&price>=stagePrice,\"\");uint256stageMintedNum=stage.mintedNum;uint256stageMaxQuantity=stage.maxQuantity;require(stageMintedNum.add(quantity)<=stageMaxQuantity,\"\");require(quantity.mul(price)<=msg.value,\"\");Stagestorage_stage=stageList[index];_stage.mintedNum=stageMintedNum.add(quantity);stageList[index]=_stage;emitUpdateStageEvent(stageType,to,_stage.mintedNum);}"
  ],
  "signatureMint": [
    "{returnECDSA.recover(keccak256(abi.encode(stageType,to,quantity,price,_timestamp)),_signature);}"
  ],
  "setBlackMarketplaces": ["{_blackMarketplaces[operator]=approved;}"],
  "isBlackMarketplaces": ["{return_blackMarketplaces[operator];}"],
  "withDrawAll": [
    "{(boolsuccess,)=to.call{gas:21000,value:address(this).balance}(\"\");require(success,\"\");",
    "{(boolsuccess,)=to.call{gas:21000,value:address(this).balance}(\"\");require(success,\"\");}"
  ],
  "functionDelegateCall": [
    "{require(isContract(target),\"\");(boolsuccess,bytesmemoryreturndata)=target.delegatecall(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{require(isContract(target),\"\");(boolsuccess,bytesmemoryreturndata)=target.delegatecall(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{(boolsuccess,bytesmemoryreturndata)=target.delegatecall(data);returnverifyCallResultFromTarget(target,success,returndata,errorMessage);}"
  ],
  "mintSewerPass": [
    "{if(!mintIsActive)revertMintIsNotActive();if(_totalSupply>=MAX_TOKENS)revertMaxTokensMinted();if(!minters[_msgSender()])revertNotAllowedToMint();uint256_mintIndex=mintIndex;++mintIndex;++_totalSupply;tokenIdtoMintData[_mintIndex]=mintData;_safeMint(to,_mintIndex);return_mintIndex;}"
  ],
  "getMintDataByTokenId": [
    "{if(!_exists(tokenId))revertTokenIdDoesNotExist();uint256mintData=tokenIdtoMintData[tokenId];tier=uint256(uint64(mintData));apeTokenId=uint256(uint64(mintData>>64));dogTokenId=uint256(uint64(mintData>>128));}"
  ],
  "tokenIdsByWallet": [
    "{uint256tokenCount=balanceOf(_owner);uint256[]memorytokenIds=newuint256[](tokenCount);for(uint256i;i<tokenCount;i++){tokenIds[i]=tokenOfOwnerByIndex(_owner,i);}returntokenIds;}"
  ],
  "flipMintIsActiveState": [
    "{if(contractIsLocked)revertContractIsLocked();mintIsActive=!mintIsActive;}"
  ],
  "flipBurnIsActiveState": [
    "{if(contractIsLocked)revertContractIsLocked();burnIsActive=!burnIsActive;}"
  ],
  "lockContract": [
    "{if(mintIsActive)revertUnableToLockContract();contractIsLocked=true;}"
  ],
  "toggleMinterContract": [
    "{if(contractIsLocked)revertContractIsLocked();minters[_minterContract]=!minters[_minterContract];}"
  ],
  "setMetadataHash": ["{metadataHash=_metadataHash;}"],
  "setNftLicenseTerms": ["{nftLicenseTerms=_nftLicenseUri;}"],
  "setRegistryAddress": ["{registryAddress=_registryAddress;}"],
  "setIsRegistryActive": [
    "{if(registryAddress==address(0))revertRegistryAddressIsNotSet();isRegistryActive=isActive;}"
  ],
  "_isValidAgainstRegistry": [
    "{if(isRegistryActive){IRegistryregistry=IRegistry(registryAddress);returnregistry.isAllowedOperator(operator);}returntrue;}"
  ],
  "_isApprovedToBurn": [
    "{if(!contractIsLocked&&minters[_msgSender()]){returntrue;}elseif(_isApprovedOrOwner(_msgSender(),tokenId)){returntrue;}returnfalse;}"
  ],
  "verifyCalldata": ["{returnprocessProofCalldata(proof,leaf)==root;}"],
  "processProofCalldata": [
    "{bytes32computedHash=leaf;for(uint256i=0;i<proof.length;i++){computedHash=_hashPair(computedHash,proof[i]);}returncomputedHash;}"
  ],
  "multiProofVerify": [
    "{returnprocessMultiProof(proof,proofFlags,leaves)==root;}"
  ],
  "multiProofVerifyCalldata": [
    "{returnprocessMultiProofCalldata(proof,proofFlags,leaves)==root;}"
  ],
  "processMultiProof": [
    "{uint256leavesLen=leaves.length;uint256totalHashes=proofFlags.length;require(leavesLen+proof.length-1==totalHashes,\"\");bytes32[]memoryhashes=newbytes32[](totalHashes);uint256leafPos=0;uint256hashPos=0;uint256proofPos=0;for(uint256i=0;i<totalHashes;i++){bytes32a=leafPos<leavesLen?leaves[leafPos++]:hashes[hashPos++];bytes32b=proofFlags[i]?leafPos<leavesLen?leaves[leafPos++]:hashes[hashPos++]:proof[proofPos++];hashes[i]=_hashPair(a,b);}if(totalHashes>0){returnhashes[totalHashes-1];}elseif(leavesLen>0){returnleaves[0];}else{returnproof[0];}}"
  ],
  "processMultiProofCalldata": [
    "{uint256leavesLen=leaves.length;uint256totalHashes=proofFlags.length;require(leavesLen+proof.length-1==totalHashes,\"\");bytes32[]memoryhashes=newbytes32[](totalHashes);uint256leafPos=0;uint256hashPos=0;uint256proofPos=0;for(uint256i=0;i<totalHashes;i++){bytes32a=leafPos<leavesLen?leaves[leafPos++]:hashes[hashPos++];bytes32b=proofFlags[i]?leafPos<leavesLen?leaves[leafPos++]:hashes[hashPos++]:proof[proofPos++];hashes[i]=_hashPair(a,b);}if(totalHashes>0){returnhashes[totalHashes-1];}elseif(leavesLen>0){returnleaves[0];}else{returnproof[0];}}"
  ],
  "_hashPair": ["{returna<b?_efficientHash(a,b):_efficientHash(b,a);}"],
  "isClaimed": [
    "{\\ruint256claimedWordIndex=index/256;\\ruint256claimedBitIndex=index%256;\\ruint256claimedWord=claimedBitMaps[treeId][claimedWordIndex];\\ruint256mask=(1<<claimedBitIndex);\\rreturnclaimedWord&mask==mask;\\r}"
  ],
  "_setClaimed": [
    "{\\ruint256claimedWordIndex=index/256;\\ruint256claimedBitIndex=index%256;\\rclaimedBitMaps[treeId][claimedWordIndex]=\\rclaimedBitMaps[treeId][claimedWordIndex]|\\r(1<<claimedBitIndex);\\r}"
  ],
  "merkleVerifyAndSetClaimed": [
    "{\\rbytes32node=keccak256(abi.encodePacked(index,account,amount));\\rrequire(\\rMerkleProof.verify(merkleProof,\"\"),\\r\"MerkleDistributor:Invalidproof.\"\\r);\\rclaimed=isClaimed(treeId,index);\\r\\rif(!claimed){\\r_setClaimed(treeId,index);\\r}\\r}"
  ],
  "initialize": ["{\\r}"],
  "setBaseUri": ["{\\rBASE_URI=uri;\\r}"],
  "setNuoNFT": [
    "{\\rrequire(_NuoNFTAddress!=address(0),\"\")!\");\\rnuoNFTAddress=_NuoNFTAddress;\\r}"
  ],
  "setMerkleTree": ["{\\rmerkleRoots[_treeId]=_root;\\r}"],
  "freeMint": [
    "{\\raddresswallet=_msgSender();\\rrequire(account==wallet,\"\");\\r\\rSeasonDatastorager=_seasonDataMap[_season][_round];\\r\\rrequire(r.status==SaleStatus.Saling,\"\");\\r\\rrequire(r.price==0,\"\");\\r\\rrequire(r.maxSupply>=r.minted+_mintAmount,\"\");\\r\\ruint256userRoundMinted=getUserMintedCount(_season,_round,wallet);\\rrequire(r.userMaxMint>=userRoundMinted+_mintAmount,\"\");\\r\\rboolclaimed=merkleVerifyAndSetClaimed(r.treeId,index,account,amount,merkleProof);\\r\\rif(!claimed){\\raddCharge(_season,_round,wallet,amount);\\r}\\rrequire(getCharged(_season,\"\")>=_mintAmount,\"amountoutofrange!\");\\r\\r_safeMint(wallet,_mintAmount);\\r\\rr.minted+=_mintAmount;\\raddUserMinted(_season,_round,account,_mintAmount);\\rcosumeCharge(_season,_round,account,_mintAmount);\\r}"
  ],
  "whitelistMint": [
    "{\\raddresswallet=_msgSender();\\rrequire(account==wallet,\"\");\\r\\rSeasonDatastorager=_seasonDataMap[_season][_round];\\r\\rrequire(r.status==SaleStatus.Saling,\"\");\\r\\rrequire(r.price*_mintAmount<=msg.value,\"\");\\r\\rrequire(r.maxSupply>=r.minted+_mintAmount,\"\");\\r\\ruint256userRoundMinted=getUserMintedCount(_season,_round,wallet);\\rrequire(r.userMaxMint>=userRoundMinted+_mintAmount,\"\");\\r\\rboolclaimed=merkleVerifyAndSetClaimed(r.treeId,index,account,amount,merkleProof);\\rif(!claimed){\\raddCharge(_season,_round,wallet,amount);\\r}\\rrequire(getCharged(_season,\"\")>=_mintAmount,\"amountoutofrange!\");\\r\\r_safeMint(wallet,_mintAmount);\\r\\rr.minted+=_mintAmount;\\raddUserMinted(_season,_round,account,_mintAmount);\\rcosumeCharge(_season,_round,account,_mintAmount);\\r}",
    "{require(whitelistMintConf.isOpen,\"\");require(totalSupply()+amount<=maxSupply,\"\");require(whitelistMintConf.maxPerTx==0||amount<=whitelistMintConf.maxPerTx,\"\");require(whitelistMintConf.price==0||msg.value>=whitelistMintConf.price,\"\");addresstoAddr=to==address(0)?msg.sender:to;require(checkWhitelist(toAddr,\"\"),\"Youarenotinwhitelist\");require(whitelistMintConf.maxPerWallet==0||whitelistMinted[toAddr]+amount<=whitelistMintConf.maxPerWallet,\"\");whitelistMinted[toAddr]+=amount;_safeMint(toAddr,amount);}",
    "{require(mintStage==1,\"\");require(isWhitelisted(merkleProof),\"\");_mintValidate(amount,_msgSender(),true);_safeMintTo(_msgSender(),amount);}"
  ],
  "publicMint": [
    "{\\raddresswallet=_msgSender();\\rrequire(msg.sender==tx.origin,\"\");\\rSeasonDatastorager=_seasonDataMap[_season][_round];\\r\\rrequire(r.status==SaleStatus.Saling,\"\");\\r\\rrequire(r.price*amount<=msg.value,\"\");\\r\\rrequire(r.maxSupply>=r.minted+amount,\"\");\\r\\ruint256userRoundMinted=getUserMintedCount(_season,_round,wallet);\\rrequire(r.userMaxMint>=userRoundMinted+amount,\"\");\\r\\rrequire(r.treeId==0,\"\");\\r\\r_safeMint(wallet,amount);\\r\\rr.minted+=amount;\\r\\raddUserMinted(_season,_round,wallet,amount);\\r}",
    "{require(publicMintConf.isOpen,\"\");require(totalSupply()+amount<=maxSupply,\"\");require(publicMintConf.maxPerTx==0||amount<=publicMintConf.maxPerTx,\"\");require(publicMintConf.price==0||msg.value>=publicMintConf.price,\"\");addresstoAddr=to==address(0)?msg.sender:to;_safeMint(toAddr,amount);}"
  ],
  "withdrawAll": [
    "{\\ruint256balance=address(this).balance;\\rrequire(balance>0);\\r_widthdraw(owner(),\"\").balance);\\r}",
    "{\\ruint256balance=address(this).balance;\\rrequire(balance>0);\\r_widthdraw(devAddress,\"\").div(100));\\r_widthdraw(creatorAddress,address(this).balance);\\r}"
  ],
  "_widthdraw": [
    "{\\r(boolsuccess,)=_address.call{value:_amount}(\"\");\\rrequire(success,\"\");\\r}"
  ],
  "setOperatorFilteringEnabled": [
    "{\\roperatorFilteringEnabled=value;\\r}",
    "{operatorFilteringEnabled=value;}"
  ],
  "bulkGetRoundStatus": [
    "{\\ruint256len=roundList.length;\\rresult=newbool[](len);\\rfor(uint8i=0;i<len;i++){\\ruint32_round=roundList[i];\\rif(paused){\\rresult[i]=false;\\r}else{\\rSeasonDatastorager=_seasonDataMap[_season][_round];\\rresult[i]=r.status==SaleStatus.Saling;\\r}\\r}\\rreturnresult;\\r}"
  ],
  "getUserMintedCount": ["{\\rreturnmintedMap[_season][_round][user];\\r}"],
  "updateUserMinted": ["{\\rmintedMap[_season][_round][user]=amount;\\r}"],
  "addUserMinted": [
    "{\\rmintedMap[_season][_round][user]=getUserMintedCount(_season,_round,user)+newAmount;\\r}"
  ],
  "getRoundData": ["{\\rreturn_seasonDataMap[_season][_round];\\r}"],
  "updateSeasonConfig": [
    "{\\rSeasonDatastoragetemp=_seasonDataMap[_season][_round];\\rif(treeId>0){\\rtemp.treeId=treeId;\\r}\\rif(maxSupply>0){\\rtemp.maxSupply=maxSupply;\\r}\\rif(userMaxMint>0){\\rtemp.userMaxMint=userMaxMint;\\r}\\rif(priceUpdate==1){\\rtemp.price=price;\\r}\\rif(status!=65535){\\rtemp.status=SaleStatus(status);\\r}\\remitLogSeasonConfigUpdate(_season,_round,temp.treeId,temp.maxSupply,temp.price,uint32(temp.status));\\r}"
  ],
  "bulkUpdateSeasonConfig": [
    "{\\rrequire(args.length%8==0,\"\");\\rfor(uint256i=0;i<args.length;i+=8){\\rupdateSeasonConfig(\\ruint32(args[i]),\\ruint32(args[i+1]),\\ruint256(args[i+2]),\\ruint256(args[i+3]),\\ruint256(args[i+4]),\\ruint256(args[i+5]),\\ruint32(args[i+6]),\\ruint32(args[i+7])\\r);\\r}\\r}"
  ],
  "setRoundStatus": [
    "{\\rSeasonDatastoragetemp=_seasonDataMap[_season][_round];\\rtemp.status=SaleStatus(_status);\\r}"
  ],
  "getCharged": ["{\\rreturnchargedMap[_season][_round][_user];\\r}"],
  "addCharge": ["{\\rchargedMap[_season][_round][_user]+=amount;\\r}"],
  "cosumeCharge": ["{\\rchargedMap[_season][_round][_user]-=amount;\\r}"],
  "explicitOwnershipOf": [
    "{TokenOwnershipmemoryownership;if(tokenId<_startTokenId()||tokenId>=_nextTokenId()){returnownership;}ownership=_ownershipAt(tokenId);if(ownership.burned){returnownership;}return_ownershipOf(tokenId);}"
  ],
  "explicitOwnershipsOf": [
    "{unchecked{uint256tokenIdsLength=tokenIds.length;TokenOwnership[]memoryownerships=newTokenOwnership[](tokenIdsLength);for(uint256i;i!=tokenIdsLength;++i){ownerships[i]=explicitOwnershipOf(tokenIds[i]);}returnownerships;}}"
  ],
  "tokensOfOwnerIn": [
    "{unchecked{if(start>=stop)revertInvalidQueryRange();uint256tokenIdsIdx;uint256stopLimit=_nextTokenId();if(start<_startTokenId()){start=_startTokenId();}if(stop>stopLimit){stop=stopLimit;}uint256tokenIdsMaxLength=balanceOf(owner);if(start<stop){uint256rangeLength=stop-start;if(rangeLength<tokenIdsMaxLength){tokenIdsMaxLength=rangeLength;}}else{tokenIdsMaxLength=0;}uint256[]memorytokenIds=newuint256[](tokenIdsMaxLength);if(tokenIdsMaxLength==0){returntokenIds;}TokenOwnershipmemoryownership=explicitOwnershipOf(start);addresscurrOwnershipAddr;if(!ownership.burned){currOwnershipAddr=ownership.addr;}for(uint256i=start;i!=stop&&tokenIdsIdx!=tokenIdsMaxLength;++i){ownership=_ownershipAt(i);if(ownership.burned){continue;}if(ownership.addr!=address(0)){currOwnershipAddr=ownership.addr;}if(currOwnershipAddr==owner){tokenIds[tokenIdsIdx++]=i;}}assembly{mstore(tokenIds,tokenIdsIdx)}returntokenIds;}}"
  ],
  "tokensOfOwner": [
    "{unchecked{uint256tokenIdsIdx;addresscurrOwnershipAddr;uint256tokenIdsLength=balanceOf(owner);uint256[]memorytokenIds=newuint256[](tokenIdsLength);TokenOwnershipmemoryownership;for(uint256i=_startTokenId();tokenIdsIdx!=tokenIdsLength;++i){ownership=_ownershipAt(i);if(ownership.burned){continue;}if(ownership.addr!=address(0)){currOwnershipAddr=ownership.addr;}if(currOwnershipAddr==owner){tokenIds[tokenIdsIdx++]=i;}}returntokenIds;}}",
    "{return_tokensOfOwner(owner);}"
  ],
  "_sendLogPayload": [
    "{\\t\\tuint256payloadLength=payload.length;\\t\\taddressconsoleAddress=CONSOLE_ADDRESS;\\t\\tassembly{\\t\\t\\tletpayloadStart:=add(payload,32)\\t\\t\\tletr:=staticcall(gas(),consoleAddress,payloadStart,payloadLength,0,0)\\t\\t}\\t}"
  ],
  "log": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\",p0,p1,p2,p3));\\t}"
  ],
  "logInt": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\",p0));\\t}"
  ],
  "logUint": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\",p0));\\t}"
  ],
  "logString": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\",p0));\\t}"
  ],
  "logBool": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\",p0));\\t}"
  ],
  "logAddress": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\",p0));\\t}"
  ],
  "logBytes": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\",p0));\\t}"
  ],
  "logBytes1": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\",p0));\\t}"
  ],
  "logBytes2": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\",p0));\\t}"
  ],
  "logBytes3": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\",p0));\\t}"
  ],
  "logBytes4": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\",p0));\\t}"
  ],
  "logBytes5": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\",p0));\\t}"
  ],
  "logBytes6": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\",p0));\\t}"
  ],
  "logBytes7": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\",p0));\\t}"
  ],
  "logBytes8": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\",p0));\\t}"
  ],
  "logBytes9": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\",p0));\\t}"
  ],
  "logBytes10": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\",p0));\\t}"
  ],
  "logBytes11": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\",p0));\\t}"
  ],
  "logBytes12": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\",p0));\\t}"
  ],
  "logBytes13": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\",p0));\\t}"
  ],
  "logBytes14": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\",p0));\\t}"
  ],
  "logBytes15": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\",p0));\\t}"
  ],
  "logBytes16": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\",p0));\\t}"
  ],
  "logBytes17": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\",p0));\\t}"
  ],
  "logBytes18": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\",p0));\\t}"
  ],
  "logBytes19": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\",p0));\\t}"
  ],
  "logBytes20": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\",p0));\\t}"
  ],
  "logBytes21": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\",p0));\\t}"
  ],
  "logBytes22": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\",p0));\\t}"
  ],
  "logBytes23": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\",p0));\\t}"
  ],
  "logBytes24": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\",p0));\\t}"
  ],
  "logBytes25": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\",p0));\\t}"
  ],
  "logBytes26": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\",p0));\\t}"
  ],
  "logBytes27": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\",p0));\\t}"
  ],
  "logBytes28": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\",p0));\\t}"
  ],
  "logBytes29": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\",p0));\\t}"
  ],
  "logBytes30": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\",p0));\\t}"
  ],
  "logBytes31": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\",p0));\\t}"
  ],
  "logBytes32": [
    "{\\t\\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\",p0));\\t}"
  ],
  "_checkFilterOperator": [
    "{if(address(OPERATOR_FILTER_REGISTRY).code.length>0){if(!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this),operator)){revertOperatorNotAllowed(operator);}}}"
  ],
  "_ownershipIsInitialized": ["{return_packedOwnerships[index]!=0;}"],
  "setMintConfig": [
    "{if(mode==1){whitelistMintConf=_conf;}elseif(mode==2){whiteHolderMintConf=_conf;}elseif(mode==3){publicMintConf=_conf;}}"
  ],
  "setWhitelistMerkleRoot": ["{whitelistMerkleRoot=root;}"],
  "checkWhitelist": [
    "{returnMerkleProof.verify(proof,root,keccak256(abi.encodePacked(to)));}"
  ],
  "setWhiteListContract": ["{CONTRACT_A_ADDR=addr;}"],
  "whiteHolderMint": [
    "{require(whiteHolderMintConf.isOpen,\"\");require(totalSupply()+amount<=maxSupply,\"\");require(CONTRACT_A_ADDR!=address(0),\"\");require(whiteHolderMintConf.price==0||msg.value>=whiteHolderMintConf.price,\"\");addresstoAddr=to==address(0)?msg.sender:to;require(IERC721A(CONTRACT_A_ADDR).ownerOf(tokenID)==toAddr,\"\");require(whiteHolderMintConf.maxPerTx==0||whiteHolderMinted[CONTRACT_A_ADDR][tokenID]+amount<=whiteHolderMintConf.maxPerTx,\"\");whiteHolderMinted[CONTRACT_A_ADDR][tokenID]+=amount;_safeMint(toAddr,amount);}"
  ],
  "checkHolderTokenMinted": ["{returnwhiteHolderMinted[addr][tokenID];}"],
  "adminMint": [
    "{require(accounts.length>0&&accounts.length==nums.length,\"\");for(uinti=0;i<accounts.length;i++){_safeMint(accounts[i],nums[i]);}}"
  ],
  "setIsInscriptionTokenOpen": ["{isInscriptionOpen=isOpen;}"],
  "inscriptToken": [
    "{require(isInscriptionOpen,\"\");require(ownerOf(tokenID)==msg.sender,\"\");require(!holderInscripted[tokenID][msg.sender],\"\");Messagememorym=Message(msg.sender,content);tokenInscription[tokenID].push(m);}"
  ],
  "setIsmessageSendOpen": ["{ismessageSendOpen=isOpen;}"],
  "messageSend": [
    "{require(ismessageSendOpen,\"\");Messagememorym=Message(msg.sender,content);tokenMessage[tokenID].push(m);}"
  ],
  "messageDelete": [
    "{require(tokenMessage[tokenID].length>index,\"\");tokenMessage[tokenID][index]=Message(address(0),'');}"
  ],
  "readAllInscription": ["{returntokenInscription[tokenID];}"],
  "readAllMessages": ["{returntokenMessage[tokenID];}"],
  "setPrivateURI": ["{privateURI[tokenID]=uri;}"],
  "resetPrivateURI": ["{privateURI[tokenID]='';}"],
  "_throwError": [
    "{if(error==RecoverError.NoError){return;}elseif(error==RecoverError.InvalidSignature){revert(\"ECDSA:invalidsignature\");}elseif(error==RecoverError.InvalidSignatureLength){revert(\"ECDSA:invalidsignaturelength\");}elseif(error==RecoverError.InvalidSignatureS){revert(\"ECDSA:invalidsignature's'value\");}elseif(error==RecoverError.InvalidSignatureV){revert(\"ECDSA:invalidsignature'v'value\");}}"
  ],
  "tryRecover": [
    "{if(uint256(s)>0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0){return(address(0),RecoverError.InvalidSignatureS);}if(v!=27&&v!=28){return(address(0),RecoverError.InvalidSignatureV);}addresssigner=ecrecover(hash,v,r,s);if(signer==address(0)){return(address(0),RecoverError.InvalidSignature);}return(signer,RecoverError.NoError);}"
  ],
  "contractManager": ["{return_contractManager;}"],
  "transferContractManager": [
    "{require(newContractManager!=address(0),\"\");_transferContractManager(newContractManager);}"
  ],
  "_transferContractManager": [
    "{addressoldContractManager=_contractManager;_contractManager=newContractManager;emitContractManagerTransferred(oldContractManager,newContractManager);}"
  ],
  "supply": ["{_supply=_totalMinted();}"],
  "totalMinted": ["{numMinted=_numberMinted(addr);}"],
  "royaltyInfo": [
    "{royaltyAddress=addresses.secondaryRoyaltyAddress;royaltyAmount=(_salePrice*generalConfig.secondaryRoyaltyFee)/BASIS_POINTS;}",
    "{RoyaltyInfomemoryroyalty=_tokenRoyaltyInfo[_tokenId];if(royalty.receiver==address(0)){royalty=_defaultRoyaltyInfo;}uint256royaltyAmount=(_salePrice*royalty.royaltyFraction)/_feeDenominator();return(royalty.receiver,royaltyAmount);}"
  ],
  "setNameAndSymbol": [
    "{generalConfig.name=_newName;generalConfig.symbol=_newSymbol;}"
  ],
  "setMetadataURIs": [
    "{generalConfig.contractMetadataUrl=_contractURI;generalConfig.tokenMetadataUrl=_tokenURI;if(totalSupply()!=0){emitBatchMetadataUpdate(1,_nextTokenId()-1);}}"
  ],
  "setDates": [
    "{generalConfig.publicSaleDate=_publicSale;generalConfig.saleCloseDate=_saleClosed;}"
  ],
  "setTokenConfig": [
    "{if(totalSupply()>_maxSupply)revertNewSupplyTooLow();tokenConfig.price=_price;tokenConfig.maxSupply=_maxSupply;tokenConfig.maxPerTransaction=_maxPerTransaction;}"
  ],
  "setAddresses": [
    "{if(_addresses.recoveryAddress!=addresses.recoveryAddress)revertImmutableRecoveryAddress();if(addresses.collectionOwnerAddress!=_addresses.collectionOwnerAddress){_transferOwnership(_addresses.collectionOwnerAddress);}addresses=_addresses;}"
  ],
  "setAllowBuy": ["{generalConfig.allowBuy=_allowBuy;}"],
  "setAllowPublicTransfer": [
    "{generalConfig.allowPublicTransfer=_allowPublicTransfer;}"
  ],
  "setEnableOpenSeaOperatorFilterRegistry": [
    "{generalConfig.enableOpenSeaOperatorFilterRegistry=_enable;}"
  ],
  "setRoyalty": [
    "{generalConfig.primaryRoyaltyFee=_primaryFee;generalConfig.secondaryRoyaltyFee=_secondaryFee;}"
  ],
  "buyAuthorised": [
    "{if(block.timestamp>=_expires)revertSignatureExpired();bytes32hash=keccak256(abi.encodePacked(address(this),msg.sender,_amount,_totalPrice,_maxPerAddress,_expires));bytes32message=ECDSA.toEthSignedMessageHash(hash);if(ECDSA.recover(message,_signature)!=addresses.authorisationAddress)revertNotAuthorised();if(_maxPerAddress!=0){if(_numberMinted(msg.sender)+_amount>_maxPerAddress)revertMaxPerAddressExceeded();}_buy(_amount,_totalPrice);}"
  ],
  "buy": [
    "{if(generalConfig.publicSaleDate==0||block.timestamp<generalConfig.publicSaleDate)revertPublicSaleClosed();uint256totalPrice=tokenConfig.price*_amount;_buy(_amount,totalPrice);}"
  ],
  "_buy": [
    "{if(generalConfig.saleCloseDate!=0){if(block.timestamp>=generalConfig.saleCloseDate)revertSaleClosed();}if(_totalMinted()+_amount>tokenConfig.maxSupply)revertMaxSupplyExceeded();if(tokenConfig.maxPerTransaction!=0){if(_amount>tokenConfig.maxPerTransaction)revertMaxPerTransactionExceeded();}uint256royaltyAmount=(_totalPrice*generalConfig.primaryRoyaltyFee)/BASIS_POINTS;if(addresses.purchaseTokenAddress!=address(0)){IERC20token=IERC20(addresses.purchaseTokenAddress);token.safeTransferFrom(msg.sender,addresses.managerPrimaryRoyaltyAddress,royaltyAmount);token.safeTransferFrom(msg.sender,addresses.customerPrimaryRoyaltyAddress,_totalPrice-royaltyAmount);}else{if(msg.value<_totalPrice)revertInsufficientPaymentValue();payable(addresses.managerPrimaryRoyaltyAddress).transfer(royaltyAmount);payable(addresses.customerPrimaryRoyaltyAddress).transfer(_totalPrice-royaltyAmount);}_mint(msg.sender,_amount);}"
  ],
  "transferAuthorised": [
    "{if(block.timestamp>=_expires)revertSignatureExpired();bytes32hash=keccak256(abi.encodePacked(address(this),msg.sender,_from,_to,_tokenId,_expires));bytes32message=ECDSA.toEthSignedMessageHash(hash);if(ECDSA.recover(message,_signature)!=addresses.authorisationAddress)revertNotAuthorised();super.safeTransferFrom(_from,_to,_tokenId);}"
  ],
  "recoverContract": [
    "{if(msg.sender!=addresses.recoveryAddress)revertNotAuthorised();_transferContractManager(addresses.recoveryAddress);}"
  ],
  "current": ["{returncounter._value;}"],
  "increment": ["{counter._value+=1;}", "{unchecked{counter._value+=1;}}"],
  "decrement": [
    "{counter._value=counter._value.sub(1);}",
    "{uint256value=counter._value;require(value>0,\"\");unchecked{counter._value=value-1;}}"
  ],
  "_transferFrom": [
    "{super._transferFrom(from,to,tokenId);_removeTokenFromOwnerEnumeration(from,tokenId);_addTokenToOwnerEnumeration(to,tokenId);}"
  ],
  "_tokensOfOwner": ["{return_ownedTokens[owner];}"],
  "strConcat": [
    "{bytesmemory_ba=bytes(_a);bytesmemory_bb=bytes(_b);bytesmemory_bc=bytes(_c);bytesmemory_bd=bytes(_d);bytesmemory_be=bytes(_e);stringmemoryabcde=newstring(_ba.length+_bb.length+_bc.length+_bd.length+_be.length);bytesmemorybabcde=bytes(abcde);uintk=0;uinti=0;for(i=0;i<_ba.length;i++){babcde[k++]=_ba[i];}for(i=0;i<_bb.length;i++){babcde[k++]=_bb[i];}for(i=0;i<_bc.length;i++){babcde[k++]=_bc[i];}for(i=0;i<_bd.length;i++){babcde[k++]=_bd[i];}for(i=0;i<_be.length;i++){babcde[k++]=_be[i];}returnstring(babcde);}"
  ],
  "uint2str": [
    "{if(_i==0){return\"0\";}uintj=_i;uintlen;while(j!=0){len++;j/=10;}bytesmemorybstr=newbytes(len);uintk=len-1;while(_i!=0){bstr[k--]=byte(uint8(48+_i%10));_i/=10;}returnstring(bstr);}",
    "{if(_i==0){return\"0\";}uint256j=_i;uint256len;while(j!=0){++len;j/=10;}bytesmemorybstr=newbytes(len);uint256k=len;while(_i!=0){k=k-1;uint8temp=(48+uint8(_i-(_i/10)*10));bytes1b1=bytes1(temp);bstr[k]=b1;_i/=10;}returnstring(bstr);}"
  ],
  "purchase": ["{returnpurchaseTo(msg.sender,_projectId);}"],
  "purchaseTo": [
    "{require(msg.value>=projects[_projectId].pricePerTokenInWei,\"\");require(projects[_projectId].invocations.add(1)<=projects[_projectId].maxInvocations,\"\");require(projects[_projectId].active||msg.sender==projects[_projectId].artistAddress,\"\");require(!projects[_projectId].paused||msg.sender==projects[_projectId].artistAddress,\"\");uint256tokenId=_mintToken(_to,_projectId);_splitFunds(_projectId);returntokenId;}"
  ],
  "_mintToken": [
    "{uint256tokenIdToBe=(_projectId*ONE_MILLION)+projects[_projectId].invocations;projects[_projectId].invocations=projects[_projectId].invocations.add(1);for(uint256i=0;i<projects[_projectId].hashes;i++){bytes32hash=keccak256(abi.encodePacked(projects[_projectId].invocations,block.number.add(i),msg.sender));tokenIdToHashes[tokenIdToBe].push(hash);hashToTokenId[hash]=tokenIdToBe;}_mint(_to,tokenIdToBe);tokenIdToProjectId[tokenIdToBe]=_projectId;projectIdToTokenIds[_projectId].push(tokenIdToBe);emitMint(_to,tokenIdToBe,_projectId,projects[_projectId].invocations,projects[_projectId].pricePerTokenInWei);returntokenIdToBe;}"
  ],
  "_splitFunds": [
    "{if(msg.value>0){uint256pricePerTokenInWei=projects[_projectId].pricePerTokenInWei;uint256refund=msg.value.sub(projects[_projectId].pricePerTokenInWei);if(refund>0){msg.sender.transfer(refund);}uint256foundationAmount=pricePerTokenInWei.div(100).mul(artblocksPercentage);if(foundationAmount>0){artblocksAddress.transfer(foundationAmount);}uint256projectFunds=pricePerTokenInWei.sub(foundationAmount);uint256additionalPayeeAmount;if(projects[_projectId].additionalPayeePercentage>0){additionalPayeeAmount=projectFunds.div(100).mul(projects[_projectId].additionalPayeePercentage);if(additionalPayeeAmount>0){projects[_projectId].additionalPayee.transfer(additionalPayeeAmount);}}uint256creatorFunds=projectFunds.sub(additionalPayeeAmount);if(creatorFunds>0){projects[_projectId].artistAddress.transfer(creatorFunds);}}}"
  ],
  "updateArtblocksAddress": ["{artblocksAddress=_artblocksAddress;}"],
  "updateArtblocksPercentage": [
    "{require(_artblocksPercentage<=25,\"\");artblocksPercentage=_artblocksPercentage;}"
  ],
  "addWhitelisted": ["{isWhitelisted[_address]=true;}"],
  "removeWhitelisted": ["{isWhitelisted[_address]=false;}"],
  "toggleProjectIsLocked": ["{projects[_projectId].locked=true;}"],
  "toggleProjectIsActive": [
    "{projects[_projectId].active=!projects[_projectId].active;}"
  ],
  "updateProjectArtistAddress": [
    "{projects[_projectId].artistAddress=_artistAddress;}"
  ],
  "toggleProjectIsPaused": [
    "{projects[_projectId].paused=!projects[_projectId].paused;}"
  ],
  "addProject": [
    "{uint256projectId=nextProjectId;projects[projectId].artistAddress=msg.sender;projects[projectId].pricePerTokenInWei=_pricePerTokenInWei;projects[projectId].paused=true;projects[projectId].dynamic=_dynamic;projects[projectId].maxInvocations=ONE_MILLION;if(!_dynamic){projects[projectId].hashes=0;}else{projects[projectId].hashes=1;}nextProjectId=nextProjectId.add(1);}"
  ],
  "updateProjectPricePerTokenInWei": [
    "{projects[_projectId].pricePerTokenInWei=_pricePerTokenInWei;}"
  ],
  "updateProjectName": ["{projects[_projectId].name=_projectName;}"],
  "updateProjectArtistName": [
    "{projects[_projectId].artist=_projectArtistName;}"
  ],
  "updateProjectAdditionalPayeeInfo": [
    "{require(_additionalPayeePercentage<=100,\"\");projects[_projectId].additionalPayee=_additionalPayee;projects[_projectId].additionalPayeePercentage=_additionalPayeePercentage;}"
  ],
  "updateProjectSecondaryMarketRoyaltyPercentage": [
    "{require(_secondMarketRoyalty<=100,\"\");projects[_projectId].secondMarketRoyalty=_secondMarketRoyalty;}"
  ],
  "updateProjectDescription": [
    "{projects[_projectId].description=_projectDescription;}"
  ],
  "updateProjectWebsite": ["{projects[_projectId].website=_projectWebsite;}"],
  "updateProjectLicense": ["{projects[_projectId].license=_projectLicense;}"],
  "updateProjectMaxInvocations": [
    "{require(_maxInvocations>projects[_projectId].invocations,\"\");require(_maxInvocations<=ONE_MILLION,\"\");projects[_projectId].maxInvocations=_maxInvocations;}"
  ],
  "updateProjectHashesGenerated": [
    "{require(projects[_projectId].invocations==0,\"\");require(projects[_projectId].dynamic,\"\");require(_hashes<=100&&_hashes>=0,\"\");projects[_projectId].hashes=_hashes;}"
  ],
  "addProjectScript": [
    "{projects[_projectId].scripts[projects[_projectId].scriptCount]=_script;projects[_projectId].scriptCount=projects[_projectId].scriptCount.add(1);}"
  ],
  "updateProjectScript": [
    "{require(_scriptId<projects[_projectId].scriptCount,\"\");projects[_projectId].scripts[_scriptId]=_script;}"
  ],
  "removeProjectLastScript": [
    "{require(projects[_projectId].scriptCount>0,\"\");deleteprojects[_projectId].scripts[projects[_projectId].scriptCount-1];projects[_projectId].scriptCount=projects[_projectId].scriptCount.sub(1);}"
  ],
  "updateProjectScriptJSON": [
    "{projects[_projectId].scriptJSON=_projectScriptJSON;}"
  ],
  "updateProjectIpfsHash": ["{projects[_projectId].ipfsHash=_ipfsHash;}"],
  "updateProjectBaseURI": [
    "{projects[_projectId].projectBaseURI=_newBaseURI;}"
  ],
  "updateProjectBaseIpfsURI": [
    "{projects[_projectId].projectBaseIpfsURI=_projectBaseIpfsURI;}"
  ],
  "toggleProjectUseIpfsForStatic": [
    "{require(!projects[_projectId].dynamic,\"\");projects[_projectId].useIpfs=!projects[_projectId].useIpfs;}"
  ],
  "toggleProjectIsDynamic": [
    "{require(projects[_projectId].invocations==0,\"\");if(projects[_projectId].dynamic){projects[_projectId].hashes=0;}else{projects[_projectId].hashes=1;}projects[_projectId].dynamic=!projects[_projectId].dynamic;}"
  ],
  "overrideTokenDynamicImageWithIpfsLink": [
    "{staticIpfsImageLink[_tokenId]=_ipfsHash;}"
  ],
  "clearTokenIpfsImageUri": [
    "{deletestaticIpfsImageLink[tokenIdToProjectId[_tokenId]];}"
  ],
  "projectDetails": [
    "{projectName=projects[_projectId].name;artist=projects[_projectId].artist;description=projects[_projectId].description;website=projects[_projectId].website;license=projects[_projectId].license;dynamic=projects[_projectId].dynamic;}"
  ],
  "projectTokenInfo": [
    "{artistAddress=projects[_projectId].artistAddress;pricePerTokenInWei=projects[_projectId].pricePerTokenInWei;invocations=projects[_projectId].invocations;maxInvocations=projects[_projectId].maxInvocations;active=projects[_projectId].active;additionalPayee=projects[_projectId].additionalPayee;additionalPayeePercentage=projects[_projectId].additionalPayeePercentage;}"
  ],
  "projectScriptInfo": [
    "{scriptJSON=projects[_projectId].scriptJSON;scriptCount=projects[_projectId].scriptCount;hashes=projects[_projectId].hashes;ipfsHash=projects[_projectId].ipfsHash;locked=projects[_projectId].locked;paused=projects[_projectId].paused;}"
  ],
  "projectScriptByIndex": ["{returnprojects[_projectId].scripts[_index];}"],
  "projectURIInfo": [
    "{projectBaseURI=projects[_projectId].projectBaseURI;projectBaseIpfsURI=projects[_projectId].projectBaseIpfsURI;useIpfs=projects[_projectId].useIpfs;}"
  ],
  "projectShowAllTokens": ["{returnprojectIdToTokenIds[_projectId];}"],
  "showTokenHashes": ["{returntokenIdToHashes[_tokenId];}"],
  "getRoyaltyData": [
    "{artistAddress=projects[tokenIdToProjectId[_tokenId]].artistAddress;additionalPayee=projects[tokenIdToProjectId[_tokenId]].additionalPayee;additionalPayeePercentage=projects[tokenIdToProjectId[_tokenId]].additionalPayeePercentage;royaltyFeeByID=projects[tokenIdToProjectId[_tokenId]].secondMarketRoyalty;}"
  ],
  "_totalSupply": ["{\\rreturn_tokenIdTracker.current();\\r}"],
  "totalMint": ["{\\rreturn_totalSupply();\\r}"],
  "canClaim": ["{\\rreturn_pudgyPenguinsUsed[_tokenId]==0;\\r}"],
  "_mintAnElement": [
    "{\\r_tokenIdTracker.increment();\\r_safeMint(_to,id);\\remitCreatePenguinPresent(id);\\r}",
    "{\\ruintid=_totalSupply();\\r_tokenIdTracker.increment();\\r_safeMint(_to,id);\\remitCreatePenguin(id);\\r}"
  ],
  "setEndClaimDate": ["{\\rendClaim_timestamp=_end;\\r}"],
  "getEndClaimDate": ["{\\rreturnendClaim_timestamp;\\r}"],
  "setPudgyPenguins": [
    "{\\rpudgyPenguins=PudgyPenguinsInterface(_pudgyPenguins);\\r}"
  ],
  "reset": ["{counter._value=0;}"],
  "_registerForOperatorFiltering": [
    "{assembly{letfunctionSelector:=0x7d3e3dbesubscriptionOrRegistrantToCopy:=shr(96,shl(96,subscriptionOrRegistrantToCopy))for{}iszero(subscribe){}{ifiszero(subscriptionOrRegistrantToCopy){functionSelector:=0x4420e486break}functionSelector:=0xa0af2903break}mstore(0x00,shl(224,functionSelector))mstore(0x04,address())mstore(0x24,subscriptionOrRegistrantToCopy)ifiszero(call(gas(),_OPERATOR_FILTER_REGISTRY,0,0x00,0x44,0x00,0x04)){ifeq(shr(224,mload(0x00)),functionSelector){revert(0,0)}}mstore(0x24,0)}}"
  ],
  "_revertIfBlocked": [
    "{assembly{mstore(0x00,0xc6171134001122334455)mstore(0x1a,address())mstore(0x3a,operator)ifiszero(staticcall(gas(),_OPERATOR_FILTER_REGISTRY,0x16,0x44,0x00,0x00)){returndatacopy(0x00,0x00,returndatasize())revert(0x00,returndatasize())}mstore(0x3a,0)}}"
  ],
  "_operatorFilteringEnabled": ["{returnoperatorFilteringEnabled;}"],
  "_isPriorityOperator": ["{returnfalse;}"],
  "togglePortal": ["{portalOpen=!portalOpen;}"],
  "summonFree": [
    "{if(!portalOpen)revertPortalNotOpen();if(_totalMinted()>=MAX_SUPPLY)revertSummonExceedsMaxSupply();if(_getAux(msg.sender)!=0)revertFreeSummonLimitReached();_setAux(msg.sender,1);_mint(msg.sender,1);}"
  ],
  "summonPaid": [
    "{if(!portalOpen)revertPortalNotOpen();if(_totalMinted()+qty>MAX_SUPPLY)revertSummonExceedsMaxSupply();if(qty>PAID_SUMMON_LIMIT)revertPaidSummonLimitReached();if(msg.value<qty*PAID_SUMMON_PRICE)revertInsufficientPayment();_mint(msg.sender,qty);}"
  ],
  "_mintNFT": [
    "{require(_typeB<=20&&_typeG<=2,\"\");require(currentSupply<MAX_TOKENS,\"\");unchecked{BeastTypememorybt=Supply[_typeB];uintselectedSupply=0;if(_typeG==0)selectedSupply=bt.Male;elseif(_typeG==1)selectedSupply=bt.Female;else{_typeG=uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp,totalSupply())))%2;if(_typeG==0){if(bt.Male>0)selectedSupply=bt.Male;else{selectedSupply=bt.Female;_typeG=1;}}elseif(_typeG==1){if(bt.Female>0)selectedSupply=bt.Female;else{selectedSupply=bt.Male;_typeG=0;}}}require(selectedSupply>0,\"\");uinttheToken=(_typeB*MAX_EACH_TYPE)-(_typeG==0?(selectedSupply+TOTAL_FEMALES):selectedSupply)+1;if(_typeG==0)Supply[_typeB].Male--;elseSupply[_typeB].Female--;currentSupply++;_safeMint(msg.sender,theToken);}}"
  ],
  "getInformations": [
    "{uint256[(MAX_TOKENS/MAX_EACH_TYPE)+1]memorytokenIdsMale;uint256[(MAX_TOKENS/MAX_EACH_TYPE)+1]memorytokenIdsFemale;for(uint256i=1;i<=(MAX_TOKENS/MAX_EACH_TYPE);i++){tokenIdsMale[i]=Supply[i].Male;tokenIdsFemale[i]=Supply[i].Female;}return(CURR_ROUND_NAME,tokenIdsMale,tokenIdsFemale,CURR_ROUND_TIME,CURR_MINT_COST,nftPerAddressLimit,totalSupply(),hasSaleStarted,onlyBeastListed);}"
  ],
  "setNewRound": [
    "{CURR_MINT_COST=cost;CURR_ROUND_NAME=name;nftPerAddressLimit=perAddressLimit;CURR_ROUND_TIME=theTime;hasSaleStarted=saleState;onlyBeastListed=isOnlyBeastListed;}"
  ],
  "setVerificationHash": ["{verificationHash=_hash;}"],
  "setOnlyBeastListed": ["{onlyBeastListed=_BeastListed;}"],
  "setSaleStarted": ["{hasSaleStarted=_state;}"],
  "setURIManager": [
    "{require(_uriManagerAddr!=address(0),\"\");uriManagerAddr=_uriManagerAddr;}"
  ],
  "setTeamReserveAddr": [
    "{require(_teamReserveAddr!=address(0),\"\");teamReserveAddr=_teamReserveAddr;}"
  ],
  "mintReserves": [
    "{require(_typeG<=1,\"\");if(_typeG==0){require(Supply[_typeB].Male-amount>=TOTAL_MALES-40,\"\");}else{require(Supply[_typeB].Female-amount>=TOTAL_FEMALES-10,\"\");}uinti;for(i=0;i<amount;i++){_mintNFT(_typeB,_typeG);}}"
  ],
  "mintHoodReserve": [
    "{require(Supply[_typeB].Male+Supply[_typeB].Female==MAX_EACH_TYPE,\"\");uinti;for(i=0;i<40;i++){_mintNFT(_typeB,0);if(i<10){_mintNFT(_typeB,1);}}}"
  ],
  "pausePublicSale": [
    "{uint256currentSalePrice=getMintPrice();publicSaleActive=false;emitMutantPublicSalePaused(currentSalePrice,getElapsedSaleTime());}"
  ],
  "getRemainingSaleTime": [
    "{require(publicSaleStartTime>0,\"\");if(getElapsedSaleTime()>=publicSaleDuration){return0;}return(publicSaleStartTime+publicSaleDuration)-block.timestamp;}"
  ],
  "mintMutants": [
    "{require(numMutantsMinted+numMutants<=PS_MAX_MUTANTS,\"\");require(numMutants>0,\"\");require(numMutants<=PS_MAX_MUTANT_PURCHASE,\"\");uint256costToMint=getMintPrice()*numMutants;require(costToMint<=msg.value,\"\");if(mintedMutantsStartingIndex==0){collectionStartingIndexBlock=block.number;}for(uint256i=0;i<numMutants;i++){uint256mintIndex=numMutantsMinted;if(numMutantsMinted<PS_MAX_MUTANTS){numMutantsMinted++;_safeMint(msg.sender,mintIndex);}}if(msg.value>costToMint){Address.sendValue(payable(msg.sender),msg.value-costToMint);}}"
  ],
  "mutateApeWithSerum": [
    "{require(serumMutationActive,\"\");require(bayc.ownerOf(apeId)==msg.sender,\"\");require(bacc.balanceOf(msg.sender,\"\")>0,\"Mustownatleastoneofthisserumtypetomutate\");uint256mutantId;if(serumTypeId==MEGA_MUTATION_TYPE){require(currentMegaMutationId<=MAX_MEGA_MUTATION_ID,\"\");require(megaMutationIdsByApe[apeId]==0,\"\");mutantId=currentMegaMutationId;megaMutationIdsByApe[apeId]=mutantId;currentMegaMutationId++;}else{mutantId=getMutantId(serumTypeId,apeId);require(!_exists(mutantId),\"\");}bacc.burnSerumForAddress(serumTypeId,msg.sender);_safeMint(msg.sender,mutantId);}"
  ],
  "getMutantIdForApeAndSerumCombination": [
    "{uint256mutantId;if(serumTypeId==MEGA_MUTATION_TYPE){mutantId=megaMutationIdsByApe[apeId];require(mutantId>0,\"\");}else{mutantId=getMutantId(serumTypeId,apeId);}require(_exists(mutantId),\"\");returnmutantId;}"
  ],
  "hasApeBeenMutatedWithType": [
    "{if(serumType==MEGA_MUTATION_TYPE){returnmegaMutationIdsByApe[apeId]>0;}uint256mutantId=getMutantId(serumType,apeId);return_exists(mutantId);}"
  ],
  "getMutantId": [
    "{require(serumType!=MEGA_MUTATION_TYPE,\"\");return(apeId*NUM_MUTANT_TYPES)+serumType+SERUM_MUTATION_OFFSET;}"
  ],
  "isMinted": [
    "{require(tokenId<MAX_MEGA_MUTATION_ID,\"\");return_exists(tokenId);}"
  ],
  "totalApesMutated": ["{returntotalSupply()-numMutantsMinted;}"],
  "togglePublicSaleActive": ["{publicSaleActive=!publicSaleActive;}"],
  "toggleSerumMutationActive": ["{serumMutationActive=!serumMutationActive;}"],
  "calculateStartingIndex": [
    "{returnuint256(blockhash(blockNumber))%collectionSize;}"
  ],
  "setStartingIndices": [
    "{require(collectionStartingIndexBlock!=0,\"\");uint256elapsed=getElapsedSaleTime();require(elapsed>=publicSaleDuration&&publicSaleStartTime>0,\"\");mintedMutantsStartingIndex=calculateStartingIndex(collectionStartingIndexBlock,PS_MAX_MUTANTS);megaMutantsStartingIndex=calculateStartingIndex(collectionStartingIndexBlock,NUM_MEGA_MUTANTS);if((block.number-collectionStartingIndexBlock)>255){mintedMutantsStartingIndex=calculateStartingIndex(block.number-1,PS_MAX_MUTANTS);megaMutantsStartingIndex=calculateStartingIndex(block.number-1,NUM_MEGA_MUTANTS);}if(mintedMutantsStartingIndex==0){mintedMutantsStartingIndex++;}if(megaMutantsStartingIndex==0){megaMutantsStartingIndex++;}emitStartingIndicesSet(mintedMutantsStartingIndex,megaMutantsStartingIndex);}"
  ],
  "batchMint": [
    "{require(msg.sender==tx.origin,\"\");require(!_isPaused,\"\");require(landType<MAX_LAND_TYPE,\"\");require(quantity<=MAX_PER_TX,\"\");LandParammemoryland=landInfo[landType];require(msg.value==quantity*land.price,\"\");require(land.currentId<land.maxId,\"\");if(land.currentId+quantity<=land.maxId){_batchMint(landType,quantity);}else{uint256actQuant=land.maxId-land.currentId;uint256value=msg.value-land.price*actQuant;_batchMint(landType,actQuant);_refund(value);}}"
  ],
  "_batchMint": [
    "{LandParamstorageland=landInfo[landType];for(uinti;i<quantity;i++){_safeMint(msg.sender,land.currentId+1+i);}land.currentId+=quantity;}"
  ],
  "_refund": ["{payable(msg.sender).transfer(refundValue);}"],
  "getLandSupply": [
    "{landSupply=newuint256[](4);landSupply[0]=superLandSupply();landSupply[1]=largeLandSupply();landSupply[2]=mediumLandSupply();landSupply[3]=smallLandSupply();}"
  ],
  "superLandSupply": ["{returnlandInfo[0].currentId;}"],
  "largeLandSupply": ["{returnlandInfo[1].currentId-LARGE_LAND_START;}"],
  "mediumLandSupply": ["{returnlandInfo[2].currentId-MEDIUM_LAND_START;}"],
  "smallLandSupply": ["{returnlandInfo[3].currentId-SMALL_LAND_START;}"],
  "setMintPaused": ["{_isPaused=!_isPaused;}"],
  "setPrice": ["{landInfo[landType].price=newPrice;}"],
  "isWhitelisted": [
    "{bytes32leaf=keccak256(abi.encodePacked(_msgSender()));returnMerkleProof.verify(_merkleProof,merkleRoot,leaf);}"
  ],
  "updateMerkleRoot": ["{merkleRoot=newMerkleRoot;}"],
  "teamMint": ["{_safeMintTo(to,amount);}"],
  "setBaseTokenURI": ["{_baseTokenURI=uri;}"],
  "mintTo": ["{_mintValidate(1,_to,false);_safeMintTo(_to,1);}"],
  "_safeMintTo": [
    "{uint256startTokenId=_nextTokenId.current();require(SafeMath.sub(startTokenId,\"\")+amount<=MAX_SUPPLY,\"collectionsoldout\");require(to!=address(0),\"\");_beforeTokenTransfers(address(0),to,startTokenId,amount);for(uint256i;i<amount;i++){uint256tokenId=_nextTokenId.current();_nextTokenId.increment();_mint(to,tokenId);}_afterTokenTransfers(address(0),to,startTokenId,amount);}"
  ],
  "_mintValidate": [
    "{require(amount!=0,\"\");require(isSaleActive()==true,\"\");uint256balance=balanceOf(to);if(balance+amount>maxFree(isWhitelist)){int256free=int256(maxFree(isWhitelist))-int256(balance);if(free>0){require(int256(msg.value)>=(int256(amount)-free)*int256(mintPriceInWei()),\"\");}else{require(msg.value>=SafeMath.mul(amount,\"\")),\"incorrectvaluesent\");}}require(amount<=maxMintPerTx(),\"\");require(balance+amount<=maxMintPerWallet(),\"\");}"
  ],
  "setPublicSale": ["{_isActive=toggle;}"],
  "setMintStage": ["{mintStage=stage;}"],
  "isSaleActive": ["{return_isActive;}"],
  "baseTokenURI": ["{return_baseTokenURI;}"],
  "maxSupply": ["{returnMAX_SUPPLY;}"],
  "maxMintPerTx": ["{returnMAX_PER_TX;}"],
  "maxMintPerWallet": ["{returnMAX_PER_WALLET;}"],
  "cutSupply": [
    "{require(newSupply<MAX_SUPPLY,\"\");require(newSupply>totalSupply(),\"\");MAX_SUPPLY=newSupply;}"
  ],
  "executeMetaTransaction": [
    "{MetaTransactionmemorymetaTx=MetaTransaction({nonce:nonces[userAddress],from:userAddress,functionSignature:functionSignature});require(verify(userAddress,\"\"),\"Signerandsignaturedonotmatch\");nonces[userAddress]=nonces[userAddress].add(1);emitMetaTransactionExecuted(userAddress,payable(msg.sender),functionSignature);(boolsuccess,bytesmemoryreturnData)=address(this).call(abi.encodePacked(functionSignature,userAddress));require(success,\"\");returnreturnData;}"
  ],
  "hashMetaTransaction": [
    "{returnkeccak256(abi.encode(META_TRANSACTION_TYPEHASH,metaTx.nonce,metaTx.from,keccak256(metaTx.functionSignature)));}"
  ],
  "getNonce": ["{nonce=nonces[user];}"],
  "_initializeEIP712": ["{_setDomainSeperator(name);}"],
  "_setDomainSeperator": [
    "{domainSeperator=keccak256(abi.encode(EIP712_DOMAIN_TYPEHASH,keccak256(bytes(name)),keccak256(bytes(ERC712_VERSION)),address(this),bytes32(getChainId())));}"
  ],
  "getDomainSeperator": ["{returndomainSeperator;}"],
  "getChainId": ["{uint256id;assembly{id:=chainid()}returnid;}"],
  "toTypedMessageHash": [
    "{returnkeccak256(abi.encodePacked(\"\\\\x19\\\\x01\",getDomainSeperator(),messageHash));}"
  ],
  "setFreePerWallet": ["{MAX_FREE=amount;}"],
  "setMintPriceInGWei": ["{PRICE=price;}"],
  "mintPriceInWei": ["{returnSafeMath.mul(PRICE,1e9);}"],
  "maxFree": ["{returnMAX_FREE;}"],
  "isOperatorAllowed": [
    "{addressregistration=_registrations[registrant];if(registration!=address(0)){EnumerableSet.AddressSetstoragefilteredOperatorsRef;EnumerableSet.Bytes32SetstoragefilteredCodeHashesRef;filteredOperatorsRef=_filteredOperators[registration];filteredCodeHashesRef=_filteredCodeHashes[registration];if(filteredOperatorsRef.contains(operator)){revertAddressFiltered(operator);}if(operator.code.length>0){bytes32codeHash=operator.codehash;if(filteredCodeHashesRef.contains(codeHash)){revertCodeHashFiltered(operator,codeHash);}}}returntrue;}"
  ],
  "register": [
    "{if(_registrations[registrant]!=address(0)){revertAlreadyRegistered();}_registrations[registrant]=registrant;emitRegistrationUpdated(registrant,true);}"
  ],
  "unregister": [
    "{addressregistration=_registrations[registrant];if(registration==address(0)){revertNotRegistered(registrant);}if(registration!=registrant){_subscribers[registration].remove(registrant);emitSubscriptionUpdated(registrant,registration,false);}_registrations[registrant]=address(0);emitRegistrationUpdated(registrant,false);}"
  ],
  "registerAndSubscribe": [
    "{addressregistration=_registrations[registrant];if(registration!=address(0)){revertAlreadyRegistered();}if(registrant==subscription){revertCannotSubscribeToSelf();}addresssubscriptionRegistration=_registrations[subscription];if(subscriptionRegistration==address(0)){revertNotRegistered(subscription);}if(subscriptionRegistration!=subscription){revertCannotSubscribeToRegistrantWithSubscription(subscription);}_registrations[registrant]=subscription;_subscribers[subscription].add(registrant);emitRegistrationUpdated(registrant,true);emitSubscriptionUpdated(registrant,subscription,true);}"
  ],
  "registerAndCopyEntries": [
    "{if(registrantToCopy==registrant){revertCannotCopyFromSelf();}addressregistration=_registrations[registrant];if(registration!=address(0)){revertAlreadyRegistered();}addressregistrantRegistration=_registrations[registrantToCopy];if(registrantRegistration==address(0)){revertNotRegistered(registrantToCopy);}_registrations[registrant]=registrant;emitRegistrationUpdated(registrant,true);_copyEntries(registrant,registrantToCopy);}"
  ],
  "updateOperator": [
    "{addressregistration=_registrations[registrant];if(registration==address(0)){revertNotRegistered(registrant);}if(registration!=registrant){revertCannotUpdateWhileSubscribed(registration);}EnumerableSet.AddressSetstoragefilteredOperatorsRef=_filteredOperators[registrant];if(!filtered){boolremoved=filteredOperatorsRef.remove(operator);if(!removed){revertAddressNotFiltered(operator);}}else{booladded=filteredOperatorsRef.add(operator);if(!added){revertAddressAlreadyFiltered(operator);}}emitOperatorUpdated(registrant,operator,filtered);}"
  ],
  "updateCodeHash": [
    "{if(codeHash==EOA_CODEHASH){revertCannotFilterEOAs();}addressregistration=_registrations[registrant];if(registration==address(0)){revertNotRegistered(registrant);}if(registration!=registrant){revertCannotUpdateWhileSubscribed(registration);}EnumerableSet.Bytes32SetstoragefilteredCodeHashesRef=_filteredCodeHashes[registrant];if(!filtered){boolremoved=filteredCodeHashesRef.remove(codeHash);if(!removed){revertCodeHashNotFiltered(codeHash);}}else{booladded=filteredCodeHashesRef.add(codeHash);if(!added){revertCodeHashAlreadyFiltered(codeHash);}}emitCodeHashUpdated(registrant,codeHash,filtered);}"
  ],
  "updateOperators": [
    "{addressregistration=_registrations[registrant];if(registration==address(0)){revertNotRegistered(registrant);}if(registration!=registrant){revertCannotUpdateWhileSubscribed(registration);}EnumerableSet.AddressSetstoragefilteredOperatorsRef=_filteredOperators[registrant];uint256operatorsLength=operators.length;unchecked{if(!filtered){for(uint256i=0;i<operatorsLength;++i){addressoperator=operators[i];boolremoved=filteredOperatorsRef.remove(operator);if(!removed){revertAddressNotFiltered(operator);}}}else{for(uint256i=0;i<operatorsLength;++i){addressoperator=operators[i];booladded=filteredOperatorsRef.add(operator);if(!added){revertAddressAlreadyFiltered(operator);}}}}emitOperatorsUpdated(registrant,operators,filtered);}"
  ],
  "updateCodeHashes": [
    "{addressregistration=_registrations[registrant];if(registration==address(0)){revertNotRegistered(registrant);}if(registration!=registrant){revertCannotUpdateWhileSubscribed(registration);}EnumerableSet.Bytes32SetstoragefilteredCodeHashesRef=_filteredCodeHashes[registrant];uint256codeHashesLength=codeHashes.length;unchecked{if(!filtered){for(uint256i=0;i<codeHashesLength;++i){bytes32codeHash=codeHashes[i];boolremoved=filteredCodeHashesRef.remove(codeHash);if(!removed){revertCodeHashNotFiltered(codeHash);}}}else{for(uint256i=0;i<codeHashesLength;++i){bytes32codeHash=codeHashes[i];if(codeHash==EOA_CODEHASH){revertCannotFilterEOAs();}booladded=filteredCodeHashesRef.add(codeHash);if(!added){revertCodeHashAlreadyFiltered(codeHash);}}}}emitCodeHashesUpdated(registrant,codeHashes,filtered);}"
  ],
  "subscribe": [
    "{if(registrant==newSubscription){revertCannotSubscribeToSelf();}if(newSubscription==address(0)){revertCannotSubscribeToZeroAddress();}addressregistration=_registrations[registrant];if(registration==address(0)){revertNotRegistered(registrant);}if(registration==newSubscription){revertAlreadySubscribed(newSubscription);}addressnewSubscriptionRegistration=_registrations[newSubscription];if(newSubscriptionRegistration==address(0)){revertNotRegistered(newSubscription);}if(newSubscriptionRegistration!=newSubscription){revertCannotSubscribeToRegistrantWithSubscription(newSubscription);}if(registration!=registrant){_subscribers[registration].remove(registrant);emitSubscriptionUpdated(registrant,registration,false);}_registrations[registrant]=newSubscription;_subscribers[newSubscription].add(registrant);emitSubscriptionUpdated(registrant,newSubscription,true);}"
  ],
  "unsubscribe": [
    "{addressregistration=_registrations[registrant];if(registration==address(0)){revertNotRegistered(registrant);}if(registration==registrant){revertNotSubscribed();}_subscribers[registration].remove(registrant);_registrations[registrant]=registrant;emitSubscriptionUpdated(registrant,registration,false);if(copyExistingEntries){_copyEntries(registrant,registration);}}"
  ],
  "copyEntriesOf": [
    "{if(registrant==registrantToCopy){revertCannotCopyFromSelf();}addressregistration=_registrations[registrant];if(registration==address(0)){revertNotRegistered(registrant);}if(registration!=registrant){revertCannotUpdateWhileSubscribed(registration);}addressregistrantRegistration=_registrations[registrantToCopy];if(registrantRegistration==address(0)){revertNotRegistered(registrantToCopy);}_copyEntries(registrant,registrantToCopy);}"
  ],
  "_copyEntries": [
    "{EnumerableSet.AddressSetstoragefilteredOperatorsRef=_filteredOperators[registrantToCopy];EnumerableSet.Bytes32SetstoragefilteredCodeHashesRef=_filteredCodeHashes[registrantToCopy];uint256filteredOperatorsLength=filteredOperatorsRef.length();uint256filteredCodeHashesLength=filteredCodeHashesRef.length();unchecked{for(uint256i=0;i<filteredOperatorsLength;++i){addressoperator=filteredOperatorsRef.at(i);booladded=_filteredOperators[registrant].add(operator);if(added){emitOperatorUpdated(registrant,operator,true);}}for(uint256i=0;i<filteredCodeHashesLength;++i){bytes32codehash=filteredCodeHashesRef.at(i);booladded=_filteredCodeHashes[registrant].add(codehash);if(added){emitCodeHashUpdated(registrant,codehash,true);}}}}"
  ],
  "subscriptionOf": [
    "{subscription=_registrations[registrant];if(subscription==address(0)){revertNotRegistered(registrant);}elseif(subscription==registrant){subscription=address(0);}}"
  ],
  "subscribers": ["{return_subscribers[registrant].values();}"],
  "subscriberAt": ["{return_subscribers[registrant].at(index);}"],
  "isOperatorFiltered": [
    "{addressregistration=_registrations[registrant];if(registration!=registrant){return_filteredOperators[registration].contains(operator);}return_filteredOperators[registrant].contains(operator);}"
  ],
  "isCodeHashFiltered": [
    "{addressregistration=_registrations[registrant];if(registration!=registrant){return_filteredCodeHashes[registration].contains(codeHash);}return_filteredCodeHashes[registrant].contains(codeHash);}"
  ],
  "isCodeHashOfFiltered": [
    "{bytes32codeHash=operatorWithCode.codehash;addressregistration=_registrations[registrant];if(registration!=registrant){return_filteredCodeHashes[registration].contains(codeHash);}return_filteredCodeHashes[registrant].contains(codeHash);}"
  ],
  "isRegistered": ["{return_registrations[registrant]!=address(0);}"],
  "filteredOperators": [
    "{addressregistration=_registrations[registrant];if(registration!=registrant){return_filteredOperators[registration].values();}return_filteredOperators[registrant].values();}"
  ],
  "filteredCodeHashes": [
    "{addressregistration=_registrations[registrant];if(registration!=registrant){return_filteredCodeHashes[registration].values();}return_filteredCodeHashes[registrant].values();}"
  ],
  "filteredOperatorAt": [
    "{addressregistration=_registrations[registrant];if(registration!=registrant){return_filteredOperators[registration].at(index);}return_filteredOperators[registrant].at(index);}"
  ],
  "filteredCodeHashAt": [
    "{addressregistration=_registrations[registrant];if(registration!=registrant){return_filteredCodeHashes[registration].at(index);}return_filteredCodeHashes[registrant].at(index);}"
  ],
  "codeHashOf": ["{returna.codehash;}"],
  "_values": ["{returnset._values;}"],
  "values": [
    "{bytes32[]memorystore=_values(set._inner);uint256[]memoryresult;assembly{result:=store}returnresult;}"
  ],
  "average": ["{return(a&b)+(a^b)/2;}"],
  "ceilDiv": ["{returna==0?0:(a-1)/b+1;}"],
  "mulDiv": [
    "{uint256result=mulDiv(x,y,denominator);if(rounding==Rounding.Up&&mulmod(x,y,denominator)>0){result+=1;}returnresult;}"
  ],
  "sqrt": [
    "{unchecked{uint256result=sqrt(a);returnresult+(rounding==Rounding.Up&&result*result<a?1:0);}}"
  ],
  "log2": [
    "{unchecked{uint256result=log2(value);returnresult+(rounding==Rounding.Up&&1<<result<value?1:0);}}"
  ],
  "log10": [
    "{unchecked{uint256result=log10(value);returnresult+(rounding==Rounding.Up&&10**result<value?1:0);}}"
  ],
  "log256": [
    "{unchecked{uint256result=log256(value);returnresult+(rounding==Rounding.Up&&1<<(result*8)<value?1:0);}}"
  ],
  "getRoleMember": ["{return_roleMembers[role].at(index);}"],
  "getRoleMemberCount": ["{return_roleMembers[role].length();}"],
  "_grantRole": [
    "{if(!hasRole(role,account)){_roles[role].members[account]=true;emitRoleGranted(role,account,_msgSender());}}"
  ],
  "_revokeRole": [
    "{if(hasRole(role,account)){_roles[role].members[account]=false;emitRoleRevoked(role,account,_msgSender());}}"
  ],
  "getRoleAdmin": ["{return_roles[role].adminRole;}"],
  "grantRole": ["{_grantRole(role,account);}"],
  "revokeRole": ["{_revokeRole(role,account);}"],
  "renounceRole": [
    "{require(account==_msgSender(),\"\");_revokeRole(role,account);}"
  ],
  "_setupRole": ["{_grantRole(role,account);}"],
  "_setRoleAdmin": [
    "{bytes32previousAdminRole=getRoleAdmin(role);_roles[role].adminRole=adminRole;emitRoleAdminChanged(role,previousAdminRole,adminRole);}"
  ],
  "mintFromOwner": [
    "{require(_tokenIdCounter.current()+_quantity<=maxSupply,\"\");for(uint256i=0;i<_quantity;i++){_tokenIdCounter.increment();_safeMint(_receiver,_tokenIdCounter.current());}}"
  ],
  "mintPublic": [
    "{require(!addressMinted[_msgSender()],\"\");require(_tokenIdCounter.current()<maxSupply,\"\");_verifySignature(_signature);_tokenIdCounter.increment();addressMinted[_msgSender()]=true;_safeMint(_msgSender(),_tokenIdCounter.current());}"
  ],
  "_verifySignature": [
    "{bytes32hash=_hashTypedDataV4(keccak256(abi.encode(keccak256(\"Approved(addresswallet)\"),_msgSender())));require(signer==ECDSA.recover(hash,\"\"),\"Invalidsigner\");}"
  ],
  "setSuffixURI": ["{suffixURI=_suffixURI;emitSuffixURISet(_suffixURI);}"],
  "setSigner": ["{signer=_signer;emitSignerSet(_signer);}"],
  "setRoyaltyInfo": [
    "{_setDefaultRoyalty(_receiver,_feeNumerator);emitRoyaltySet(_receiver,_feeNumerator);}"
  ],
  "_domainSeparatorV4": [
    "{if(address(this)==_CACHED_THIS&&block.chainid==_CACHED_CHAIN_ID){return_CACHED_DOMAIN_SEPARATOR;}else{return_buildDomainSeparator(_TYPE_HASH,_HASHED_NAME,_HASHED_VERSION);}}"
  ],
  "_buildDomainSeparator": [
    "{returnkeccak256(abi.encode(typeHash,nameHash,versionHash,block.chainid,address(this)));}"
  ],
  "_hashTypedDataV4": [
    "{returnECDSA.toTypedDataHash(_domainSeparatorV4(),structHash);}"
  ],
  "_feeDenominator": ["{return10000;}"],
  "_setDefaultRoyalty": [
    "{require(feeNumerator<=_feeDenominator(),\"\");require(receiver!=address(0),\"\");_defaultRoyaltyInfo=RoyaltyInfo(receiver,feeNumerator);}"
  ],
  "_deleteDefaultRoyalty": ["{delete_defaultRoyaltyInfo;}"],
  "_setTokenRoyalty": [
    "{require(feeNumerator<=_feeDenominator(),\"\");require(receiver!=address(0),\"\");_tokenRoyaltyInfo[tokenId]=RoyaltyInfo(receiver,feeNumerator);}"
  ],
  "_resetTokenRoyalty": ["{delete_tokenRoyaltyInfo[tokenId];}"],
  "price": ["{\\rreturnPRICE.mul(_count);\\r}"],
  "getCheck": [
    "{IChecks.StoredCheckmemorystored=checks.all[tokenId];stored.divisorIndex=divisorIndex;check.stored=stored;uint128randomness=checks.epochs[stored.epoch].randomness;check.seed=(uint256(keccak256(abi.encodePacked(randomness,stored.seed)))%type(uint128).max);check.isRoot=divisorIndex==0;check.isRevealed=randomness>0;check.hasManyChecks=divisorIndex<6;check.composite=!check.isRoot&&divisorIndex<7?stored.composites[divisorIndex-1]:0;check.colorBand=colorBandIndex(check,divisorIndex);check.gradient=gradientIndex(check,divisorIndex);check.checksCount=DIVISORS()[divisorIndex];check.speed=uint8(2**(check.seed%3));check.direction=uint8(check.seed%2);}"
  ],
  "inItForTheArt": ["{_sacrifice(tokenId,burnId);unchecked{++checks.burned;}}"],
  "inItForTheArts": [
    "{uint256pairs=_multiTokenOperation(tokenIds,burnIds);for(uint256i;i<pairs;){_sacrifice(tokenIds[i],burnIds[i]);unchecked{++i;}}unchecked{checks.burned+=uint32(pairs);}}"
  ],
  "composite": [
    "{if(swap){StoredCheckmemorytoKeep=checks.all[tokenId];checks.all[tokenId]=checks.all[burnId];checks.all[burnId]=toKeep;}_composite(tokenId,burnId);unchecked{++checks.burned;}}"
  ],
  "compositeMany": [
    "{uint256pairs=_multiTokenOperation(tokenIds,burnIds);for(uint256i;i<pairs;){_composite(tokenIds[i],burnIds[i]);unchecked{++i;}}unchecked{checks.burned+=uint32(pairs);}}"
  ],
  "infinity": [
    "{uint256count=tokenIds.length;if(count!=64){revertInvalidTokenCount();}for(uint256i;i<count;){uint256id=tokenIds[i];if(checks.all[id].divisorIndex!=6){revertBlackCheck__InvalidCheck();}if(!_isApprovedOrOwner(msg.sender,id)){revertNotAllowed();}unchecked{++i;}}uint256blackCheckId=tokenIds[0];StoredCheckstoragecheck=checks.all[blackCheckId];check.day=Utilities.day(checks.day0,block.timestamp);check.divisorIndex=7;for(uinti=1;i<count;){_burn(tokenIds[i]);unchecked{++i;}}unchecked{checks.burned+=63;}emitInfinity(blackCheckId,tokenIds[1:]);emitMetadataUpdate(blackCheckId);}"
  ],
  "resolveEpochIfNecessary": [
    "{EpochstoragecurrentEpoch=checks.epochs[checks.epoch];if(currentEpoch.committed==false||(currentEpoch.revealed==false&&currentEpoch.revealBlock<block.number-256)){currentEpoch.revealBlock=uint64(block.number+50);currentEpoch.committed=true;}elseif(block.number>currentEpoch.revealBlock){currentEpoch.randomness=uint128(uint256(keccak256(abi.encodePacked(blockhash(currentEpoch.revealBlock),block.difficulty)))%(2**128-1));currentEpoch.revealed=true;emitNewEpoch(checks.epoch,currentEpoch.revealBlock);checks.epoch++;resolveEpochIfNecessary();}}"
  ],
  "getEpoch": ["{returnchecks.epoch;}"],
  "getEpochData": ["{returnchecks.epochs[index];}"],
  "simulateComposite": [
    "{_requireMinted(tokenId);_requireMinted(burnId);uint8index=checks.all[tokenId].divisorIndex;uint8nextDivisor=index+1;check=ChecksArt.getCheck(tokenId,nextDivisor,checks);check.stored.composites[index]=uint16(burnId);if(index<5){(uint8gradient,uint8colorBand)=_compositeGenes(tokenId,burnId);check.stored.colorBands[index]=colorBand;check.stored.gradients[index]=gradient;}check.composite=!check.isRoot&&index<7?check.stored.composites[index]:0;check.colorBand=ChecksArt.colorBandIndex(check,nextDivisor);check.gradient=ChecksArt.gradientIndex(check,nextDivisor);}"
  ],
  "simulateCompositeSVG": [
    "{returnstring(ChecksArt.generateSVG(simulateComposite(tokenId,burnId),checks));}"
  ],
  "colors": [
    "{if(check.stored.divisorIndex==7){string[]memoryzeroColors=newstring[](1);uint256[]memoryzeroIndexes=newuint256[](1);zeroColors[0]='000';zeroIndexes[0]=999;return(zeroColors,zeroIndexes);}if(!check.isRevealed){string[]memorypreRevealColors=newstring[](1);uint256[]memorypreRevealIndexes=newuint256[](1);preRevealColors[0]='424242';preRevealIndexes[0]=0;return(preRevealColors,preRevealIndexes);}uint256[]memoryindexes=colorIndexes(check.stored.divisorIndex,check,checks);string[]memorycheckColors=newstring[](indexes.length);string[80]memoryallColors=EightyColors.COLORS();checkColors[0]=allColors[indexes[0]];for(uint256i=1;i<indexes.length;i++){checkColors[i]=allColors[indexes[i]];}return(checkColors,indexes);}"
  ],
  "svg": [
    "{returnstring(ChecksArt.generateSVG(ChecksArt.getCheck(tokenId,checks),checks));}"
  ],
  "_sacrifice": [
    "{(,StoredCheckstoragetoBurn,)=_tokenOperation(tokenId,burnId);checks.all[tokenId]=toBurn;checks.all[tokenId].day=Utilities.day(checks.day0,block.timestamp);_burn(burnId);emitSacrifice(burnId,tokenId);emitMetadataUpdate(tokenId);}"
  ],
  "_composite": [
    "{(StoredCheckstoragetoKeep,,uint8divisorIndex)=_tokenOperation(tokenId,burnId);uint8nextDivisor=divisorIndex+1;if(divisorIndex<5){(uint8gradient,uint8colorBand)=_compositeGenes(tokenId,burnId);toKeep.colorBands[divisorIndex]=colorBand;toKeep.gradients[divisorIndex]=gradient;}toKeep.day=Utilities.day(checks.day0,block.timestamp);toKeep.composites[divisorIndex]=uint16(burnId);toKeep.divisorIndex=nextDivisor;_burn(burnId);emitComposite(tokenId,burnId,ChecksArt.DIVISORS()[toKeep.divisorIndex]);emitMetadataUpdate(tokenId);}"
  ],
  "_compositeGenes": [
    "{Checkmemorykeeper=ChecksArt.getCheck(tokenId,checks);Checkmemoryburner=ChecksArt.getCheck(burnId,checks);uint256randomizer=uint256(keccak256(abi.encodePacked(keeper.seed,burner.seed)));gradient=Utilities.random(randomizer,100)>80?randomizer%2==0?Utilities.minGt0(keeper.gradient,burner.gradient):Utilities.max(keeper.gradient,burner.gradient):Utilities.min(keeper.gradient,burner.gradient);colorBand=Utilities.avg(keeper.colorBand,burner.colorBand);}"
  ],
  "_multiTokenOperation": [
    "{pairs=tokenIds.length;if(pairs!=burnIds.length){revertInvalidTokenCount();}}"
  ],
  "_tokenOperation": [
    "{toKeep=checks.all[tokenId];toBurn=checks.all[burnId];divisorIndex=toKeep.divisorIndex;if(!_isApprovedOrOwner(msg.sender,tokenId)||!_isApprovedOrOwner(msg.sender,burnId)||divisorIndex!=toBurn.divisorIndex||tokenId==burnId||divisorIndex>5){revertNotAllowed();}}"
  ],
  "DIVISORS": ["{return[80,40,20,10,5,4,1,0];}"],
  "COLOR_BANDS": ["{return[80,60,40,20,10,5,1];}"],
  "GRADIENTS": ["{return[0,1,2,5,8,9,10];}"],
  "gradientIndex": [
    "{uint256n=Utilities.random(check.seed,'gradient',100);returndivisorIndex==0?n<20?uint8(1+(n%6)):0:divisorIndex<6?check.stored.gradients[divisorIndex-1]:0;}"
  ],
  "colorBandIndex": [
    "{uint256n=Utilities.random(check.seed,'band',120);returndivisorIndex==0?(n>80?0:n>40?1:n>20?2:n>10?3:n>4?4:n>1?5:6):divisorIndex<6?check.stored.colorBands[divisorIndex-1]:6;}"
  ],
  "colorIndexes": [
    "{uint8[8]memorydivisors=DIVISORS();uint256checksCount=divisors[divisorIndex];uint256seed=check.seed;uint8colorBand=COLOR_BANDS()[colorBandIndex(check,divisorIndex)];uint8gradient=GRADIENTS()[gradientIndex(check,divisorIndex)];uint256possibleColorChoices=divisorIndex>0?divisors[divisorIndex-1]*2:80;uint256[]memoryindexes=newuint256[](checksCount);indexes[0]=Utilities.random(seed,possibleColorChoices);if(check.hasManyChecks){if(gradient>0){for(uint256i=1;i<checksCount;){indexes[i]=(indexes[0]+(i*gradient*colorBand/checksCount)%colorBand)%80;unchecked{++i;}}}elseif(divisorIndex==0){for(uint256i=1;i<checksCount;){indexes[i]=(indexes[0]+Utilities.random(seed+i,colorBand))%80;unchecked{++i;}}}else{for(uint256i=1;i<checksCount;){indexes[i]=Utilities.random(seed+i,possibleColorChoices);unchecked{++i;}}}}if(divisorIndex>0){uint8previousDivisor=divisorIndex-1;uint256[]memoryparentIndexes=colorIndexes(previousDivisor,check,checks);IChecks.Checkmemorycomposited=getCheck(check.composite,checks);uint256[]memorycompositedIndexes=colorIndexes(previousDivisor,composited,checks);uint8count=divisors[previousDivisor];uint256initialBranchIndex=indexes[0]%count;indexes[0]=indexes[0]<count?parentIndexes[initialBranchIndex]:compositedIndexes[initialBranchIndex];if(gradient==0){for(uint256i;i<checksCount;){uint256branchIndex=indexes[i]%count;indexes[i]=indexes[i]<count?parentIndexes[branchIndex]:compositedIndexes[branchIndex];unchecked{++i;}}}else{for(uint256i=1;i<checksCount;){indexes[i]=(indexes[0]+(i*gradient*colorBand/checksCount)%colorBand)%80;unchecked{++i;}}}}returnindexes;}"
  ],
  "perRow": ["{returnchecks==80?8:checks>=20?4:checks==10||checks==4?2:1;}"],
  "rowX": [
    "{returnchecks<=1?286:checks==5?304:checks==10||checks==4?268:196;}"
  ],
  "rowY": ["{returnchecks>4?160:checks==4?268:checks>1?304:286;}"],
  "fillAnimation": [
    "{uint8count=20;bytesmemoryvalues;if(data.check.direction==0){for(uint256i=offset+80;i>offset;){values=abi.encodePacked(values,'#',allColors[i%80],';');unchecked{i-=4;}}}else{for(uint256i=offset;i<offset+80;){values=abi.encodePacked(values,'#',allColors[i%80],';');unchecked{i+=4;}}}values=abi.encodePacked(values,'#',allColors[offset]);returnabi.encodePacked('<animate','attributeName=\"fill\"values=\"',values,'\"','dur=\"',Utilities.uint2str(count*2/data.check.speed),'s\"begin=\"animation.begin\"','repeatCount=\"indefinite\"','/>');}"
  ],
  "generateChecks": [
    "{bytesmemorychecksBytes;string[80]memoryallColors=EightyColors.COLORS();uint8checksCount=data.count;for(uint8i;i<checksCount;i++){data.indexInRow=i%data.perRow;data.isNewRow=data.indexInRow==0&&i>0;if(data.isNewRow)data.rowY+=data.spaceY;if(data.isNewRow&&data.indent){if(i==0){data.rowX+=data.spaceX/2;}if(i%(data.perRow*2)==0){data.rowX-=data.spaceX/2;}else{data.rowX+=data.spaceX/2;}}stringmemorytranslateX=Utilities.uint2str(data.rowX+data.indexInRow*data.spaceX);stringmemorytranslateY=Utilities.uint2str(data.rowY);stringmemorycolor=data.check.isRevealed?data.colors[i]:data.colors[0];checksBytes=abi.encodePacked(checksBytes,abi.encodePacked('<gtransform=\"translate(',translateX,',',translateY,')scale(',data.scale,')\">','<usehref=\"#check\"fill=\"#',color,'\">',(data.check.isRevealed&&!data.isBlack)?fillAnimation(data,data.colorIndexes[i],allColors):bytes(''),'</use>''</g>'));}returnchecksBytes;}"
  ],
  "collectRenderData": [
    "{data.check=check;data.isBlack=check.stored.divisorIndex==7;data.count=data.isBlack?1:DIVISORS()[check.stored.divisorIndex];(string[]memorycolors_,uint256[]memorycolorIndexes_)=colors(check,checks);data.gridColor=data.isBlack?'#F2F2F2':'#191919';data.canvasColor=data.isBlack?'#FFF':'#111';data.colorIndexes=colorIndexes_;data.colors=colors_;data.scale=data.count>20?'1':data.count>1?'2':'3';data.spaceX=data.count==80?36:72;data.spaceY=data.count>20?36:72;data.perRow=perRow(data.count);data.indent=data.count==40;data.rowX=rowX(data.count);data.rowY=rowY(data.count);}"
  ],
  "generateGridRow": [
    "{bytesmemoryrow;for(uint256i;i<8;i++){row=abi.encodePacked(row,'<usehref=\"#square\"x=\"',Utilities.uint2str(196+i*36),'\"y=\"160\"/>');}returnrow;}"
  ],
  "generateGrid": [
    "{bytesmemorygrid;for(uint256i;i<10;i++){grid=abi.encodePacked(grid,'<usehref=\"#row\"y=\"',Utilities.uint2str(i*36),'\"/>');}returnabi.encodePacked('<gid=\"grid\"x=\"196\"y=\"160\">',grid,'</g>');}"
  ],
  "generateSVG": [
    "{CheckRenderDatamemorydata=collectRenderData(check,checks);returnabi.encodePacked('<svg','viewBox=\"00680680\"','fill=\"none\"xmlns=\"http:'style=\"width:100%;background:black;\"','>','<defs>','<pathid=\"check\"fill-rule=\"evenodd\"d=\"',CHECKS_PATH,'\"></path>','<rectid=\"square\"width=\"36\"height=\"36\"stroke=\"',data.gridColor,'\"></rect>','<gid=\"row\">',generateGridRow(),'</g>''</defs>','<rectwidth=\"680\"height=\"680\"fill=\"black\"/>','<rectx=\"188\"y=\"152\"width=\"304\"height=\"376\"fill=\"',data.canvasColor,'\"/>',generateGrid(),generateChecks(data),'<rectwidth=\"680\"height=\"680\"fill=\"transparent\">','<animate','attributeName=\"width\"','from=\"680\"','to=\"0\"','dur=\"0.2s\"','begin=\"click\"','fill=\"freeze\"','id=\"animation\"','/>','</rect>','</svg>');}"
  ],
  "attributes": [
    "{boolshowVisualAttributes=check.isRevealed&&check.hasManyChecks;boolshowAnimationAttributes=check.isRevealed&&check.checksCount>0;returnabi.encodePacked(showVisualAttributes?trait('ColorBand',colorBand(ChecksArt.colorBandIndex(check,check.stored.divisorIndex)),','):'',showVisualAttributes?trait('Gradient',gradients(ChecksArt.gradientIndex(check,check.stored.divisorIndex)),','):'',showAnimationAttributes?trait('Speed',check.speed==4?'2x':check.speed==2?'1x':'0.5x',','):'',showAnimationAttributes?trait('Shift',check.direction==0?'IR':'UV',','):'',check.isRevealed==false?trait('Revealed','No',','):'',trait('Checks',Utilities.uint2str(check.checksCount),','),trait('Day',Utilities.uint2str(check.stored.day),''));}"
  ],
  "gradients": [
    "{return['None','Linear','DoubleLinear','Reflected','DoubleAngled','Angled','LinearZ'][gradientIndex];}"
  ],
  "colorBand": [
    "{return['Eighty','Sixty','Forty','Twenty','Ten','Five','One'][bandIndex];}"
  ],
  "trait": [
    "{returnstring(abi.encodePacked('{','\"trait_type\":\"',traitType,'\",''\"value\":\"',traitValue,'\"''}',append));}"
  ],
  "generateHTML": [
    "{returnabi.encodePacked('<!DOCTYPEhtml>','<htmllang=\"en\">','<head>','<metacharset=\"UTF-8\">','<metahttp-equiv=\"X-UA-Compatible\"content=\"IE=edge\">','<metaname=\"viewport\"content=\"width=device-width,initial-scale=1.0\">','<title>Check#',Utilities.uint2str(tokenId),'</title>','<style>','html,','body{','margin:0;','background:#EFEFEF;','overflow:hidden;','}','svg{','max-width:100vw;','max-height:100vh;','}','</style>','</head>','<body>',svg,'</body>','</html>');}"
  ],
  "COLORS": [
    "{return['E84AA9','F2399D','DB2F96','E73E85','FF7F8E','FA5B67','E8424E','D5332F','C23532','F2281C','D41515','9D262F','DE3237','DA3321','EA3A2D','EB4429','EC7368','FF8079','FF9193','EA5B33','D05C35','ED7C30','EF9933','EF8C37','F18930','F09837','F9A45C','F2A43A','F2A840','F2A93C','FFB340','F2B341','FAD064','F7CA57','F6CB45','FFAB00','F4C44A','FCDE5B','F9DA4D','F9DA4A','FAE272','F9DB49','FAE663','FBEA5B','A7CA45','B5F13B','94E337','63C23C','86E48E','77E39F','5FCD8C','83F1AE','9DEFBF','2E9D9A','3EB8A1','5FC9BF','77D3DE','6AD1DE','5ABAD3','4291A8','33758D','45B2D3','81D1EC','A7DDF9','9AD9FB','A4C8EE','60B1F4','2480BD','4576D0','3263D0','2E4985','25438C','525EAA','3D43B3','322F92','4A2387','371471','3B088C','6C31D7','9741DA'];}"
  ],
  "minGt0": ["{returnone>two?two>0?two:one:one;}"],
  "avg": ["{unchecked{result=(one>>1)+(two>>1)+(one&two&1);}}"],
  "day": ["{returnuint24((to-from)/24hours+1);}"],
  "_safeMintVia": [
    "{_mintVia(to,via,tokenId);if(!_checkOnERC721Received(address(0),to,tokenId,data)){revertERC721__TransferToNonReceiver();}}"
  ],
  "_mintVia": [
    "{_mintState(to,tokenId);emitTransfer(address(0),via,tokenId);emitTransfer(via,to,tokenId);_afterTokenTransfer(address(0),to,tokenId,1);}"
  ],
  "_mintState": [
    "{if(to==address(0)){revertERC721__TransferToZero();}if(_exists(tokenId)){revertERC721__TokenExists();}_beforeTokenTransfer(address(0),to,tokenId,1);if(_exists(tokenId)){revertERC721__TokenExists();}unchecked{_balances[to]+=1;}_owners[tokenId]=to;}"
  ]
}
