{
  "allowance": [
    "",
    "{}",
    "{return_allowances[owner][spender];}",
    "{returnallowances[_owner][_spender][_id];}"
  ],
  "_contains": [
    "{\\rreturnmap._indexes[key]!=0;\\r}",
    "{}",
    "{returnset._indexes[value]!=0;}",
    "{returnmap._indexes[key]!=0;}"
  ],
  "_verifyCallResult": [
    "{\\rif(success){\\rreturnreturndata;\\r}else{\\rif(returndata.length>0){\\r\\rassembly{\\rletreturndata_size:=mload(returndata)\\rrevert(add(32,returndata),returndata_size)\\r}\\r}else{\\rrevert(errorMessage);\\r}\\r}\\r}",
    "{if(success){returnreturndata;}else{if(returndata.length\\u003e0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{if(success){returnreturndata;}else{//Lookforrevertreasonandbubbleitupifpresentif(returndata.length>0){//Theeasiestwaytobubbletherevertreasonisusingmemoryviaassembly//solhint-disable-next-lineno-inline-assemblyassembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{if(success){returnreturndata;}else{//Lookforrevertreasonandbubbleitupifpresentif(returndata.length>0){//Theeasiestwaytobubbletherevertreasonisusingmemoryviaassemblyassembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{if(success){returnreturndata;}else{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "",
    "{if(success){returnreturndata;}else{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{}"
  ],
  "verifyCallResult": [
    "{if(success){returnreturndata;}else{if(returndata.length\\u003e0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{\\rif(success){\\rreturnreturndata;\\r}else{\\rif(returndata.length\\u003e0){\\r\\rassembly{\\rletreturndata_size:=mload(returndata)\\rrevert(add(32,returndata),returndata_size)\\r}\\r}else{\\rrevert(errorMessage);\\r}\\r}\\r}",
    "{\\rif(success){\\rreturnreturndata;\\r}else{\\rif(returndata.length>0){\\r\\rassembly{\\rletreturndata_size:=mload(returndata)\\rrevert(add(32,returndata),returndata_size)\\r}\\r}else{\\rrevert(errorMessage);\\r}\\r}\\r}",
    "{if(success){returnreturndata;}else{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{if(success){returnreturndata;}else{_revert(returndata,errorMessage);}}",
    "{if(success){returnreturndata;}else{//Lookforrevertreasonandbubbleitupifpresentif(returndata.length>0){//Theeasiestwaytobubbletherevertreasonisusingmemoryviaassembly///@soliditymemory-safe-assemblyassembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{if(success){returnreturndata;}else{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{}",
    "{if(success){returnreturndata;}else{//Lookforrevertreasonandbubbleitupifpresentif(returndata.length>0){//Theeasiestwaytobubbletherevertreasonisusingmemoryviaassemblyassembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}"
  ],
  "_remove": [
    "{\\ruint256keyIndex=map._indexes[key];\\r\\rif(keyIndex!=0){\\ruint256toDeleteIndex=keyIndex-1;\\ruint256lastIndex=map._entries.length-1;\\r\\r\\rMapEntrystoragelastEntry=map._entries[lastIndex];\\r\\rmap._entries[toDeleteIndex]=lastEntry;\\rmap._indexes[lastEntry._key]=toDeleteIndex+1;\\r\\rmap._entries.pop();\\r\\rdeletemap._indexes[key];\\r\\rreturntrue;\\r}else{\\rreturnfalse;\\r}\\r}",
    "{uint256valueIndex=set._indexes[value];if(valueIndex!=0){uint256toDeleteIndex=valueIndex-1;uint256lastIndex=set._values.length-1;bytes32lastvalue=set._values[lastIndex];set._values[toDeleteIndex]=lastvalue;set._indexes[lastvalue]=toDeleteIndex+1;set._values.pop();deleteset._indexes[value];returntrue;}else{returnfalse;}}",
    "{}",
    "{//Wereadandstorethevalue'sindextopreventmultiplereadsfromthesamestorageslotuint256valueIndex=set._indexes[value];if(valueIndex!=0){//Equivalenttocontains(set,value)//Todeleteanelementfromthe_valuesarrayinO(1),weswaptheelementtodeletewiththelastonein//thearray,andthenremovethelastelement(sometimescalledas'swapandpop').//Thismodifiestheorderofthearray,asnotedin{at}.uint256toDeleteIndex=valueIndex-1;uint256lastIndex=set._values.length-1;if(lastIndex!=toDeleteIndex){bytes32lastvalue=set._values[lastIndex];//Movethelastvaluetotheindexwherethevaluetodeleteisset._values[toDeleteIndex]=lastvalue;//Updatetheindexforthemovedvalueset._indexes[lastvalue]=valueIndex;//Replacelastvalue'sindextovalueIndex}//Deletetheslotwherethemovedvaluewasstoredset._values.pop();//Deletetheindexforthedeletedslotdeleteset._indexes[value];returntrue;}else{returnfalse;}}",
    "{uint256keyIndex=map._indexes[key];if(keyIndex!=0){uint256toDeleteIndex=keyIndex-1;uint256lastIndex=map._entries.length-1;MapEntrystoragelastEntry=map._entries[lastIndex];map._entries[toDeleteIndex]=lastEntry;map._indexes[lastEntry._key]=toDeleteIndex+1;map._entries.pop();deletemap._indexes[key];returntrue;}else{returnfalse;}}",
    "{uint256valueIndex=set._indexes[value];if(valueIndex!=0){uint256toDeleteIndex=valueIndex-1;uint256lastIndex=set._values.length-1;if(lastIndex!=toDeleteIndex){bytes32lastValue=set._values[lastIndex];set._values[toDeleteIndex]=lastValue;set._indexes[lastValue]=valueIndex;}set._values.pop();deleteset._indexes[value];returntrue;}else{returnfalse;}}",
    "{//Wereadandstorethekey'sindextopreventmultiplereadsfromthesamestorageslotuint256keyIndex=map._indexes[key];if(keyIndex!=0){//Equivalenttocontains(map,key)//Todeleteakey-valuepairfromthe_entriesarrayinO(1),weswaptheentrytodeletewiththelastone//inthearray,andthenremovethelastentry(sometimescalledas'swapandpop').//Thismodifiestheorderofthearray,asnotedin{at}.uint256toDeleteIndex=keyIndex-1;uint256lastIndex=map._entries.length-1;//Whentheentrytodeleteisthelastone,theswapoperationisunnecessary.However,sincethisoccurs//sorarely,westilldotheswapanywaytoavoidthegascostofaddingan'if'statement.MapEntrystoragelastEntry=map._entries[lastIndex];//Movethelastentrytotheindexwheretheentrytodeleteismap._entries[toDeleteIndex]=lastEntry;//Updatetheindexforthemovedentrymap._indexes[lastEntry._key]=toDeleteIndex+1;//Allindexesare1-based//Deletetheslotwherethemovedentrywasstoredmap._entries.pop();//Deletetheindexforthedeletedslotdeletemap._indexes[key];returntrue;}else{returnfalse;}}",
    "{//Wereadandstorethevalue'sindextopreventmultiplereadsfromthesamestorageslotuint256valueIndex=set._indexes[value];if(valueIndex!=0){//Equivalenttocontains(set,value)//Todeleteanelementfromthe_valuesarrayinO(1),weswaptheelementtodeletewiththelastonein//thearray,andthenremovethelastelement(sometimescalledas'swapandpop').//Thismodifiestheorderofthearray,asnotedin{at}.uint256toDeleteIndex=valueIndex-1;uint256lastIndex=set._values.length-1;//Whenthevaluetodeleteisthelastone,theswapoperationisunnecessary.However,sincethisoccurs//sorarely,westilldotheswapanywaytoavoidthegascostofaddingan'if'statement.bytes32lastvalue=set._values[lastIndex];//Movethelastvaluetotheindexwherethevaluetodeleteisset._values[toDeleteIndex]=lastvalue;//Updatetheindexforthemovedvalueset._indexes[lastvalue]=toDeleteIndex+1;//Allindexesare1-based//Deletetheslotwherethemovedvaluewasstoredset._values.pop();//Deletetheindexforthedeletedslotdeleteset._indexes[value];returntrue;}else{returnfalse;}}"
  ],
  "isNonFungible": ["", "{}", "{return_id\\u0026TYPE_NF_BIT==TYPE_NF_BIT;}"],
  "contains": [
    "{\\rreturn_contains(map._inner,bytes32(key));\\r}",
    "{}",
    "{return_contains(set._inner,bytes32(value));}",
    "{return_contains(map._inner,bytes32(key));}"
  ],
  "getNonFungibleBaseType": ["", "{}", "{return_id\\u0026TYPE_MASK;}"],
  "_removeTokenFromAllTokensEnumeration": [
    "{uint256lastTokenIndex=_allTokens.length-1;uint256tokenIndex=_allTokensIndex[tokenId];uint256lastTokenId=_allTokens[lastTokenIndex];_allTokens[tokenIndex]=lastTokenId;//Movethelasttokentotheslotoftheto-deletetoken_allTokensIndex[lastTokenId]=tokenIndex;//Updatethemovedtoken'sindexdelete_allTokensIndex[tokenId];_allTokens.pop();}",
    "{//Topreventagapinthetokensarray,westorethelasttokenintheindexofthetokentodelete,and//thendeletethelastslot(swapandpop).uint256lastTokenIndex=_allTokens.length-1;uint256tokenIndex=_allTokensIndex[tokenId];//Whenthetokentodeleteisthelasttoken,theswapoperationisunnecessary.However,sincethisoccursso//rarely(whenthelastmintedtokenisburnt)thatwestilldotheswapheretoavoidthegascostofadding//an'if'statement(likein_removeTokenFromOwnerEnumeration)uint256lastTokenId=_allTokens[lastTokenIndex];_allTokens[tokenIndex]=lastTokenId;//Movethelasttokentotheslotoftheto-deletetoken_allTokensIndex[lastTokenId]=tokenIndex;//Updatethemovedtoken'sindex//Thisalsodeletesthecontentsatthelastpositionofthearraydelete_allTokensIndex[tokenId];_allTokens.pop();}",
    "{\\r\\ruint256lastTokenIndex=_allTokens.length-1;\\ruint256tokenIndex=_allTokensIndex[tokenId];\\r\\ruint256lastTokenId=_allTokens[lastTokenIndex];\\r\\r_allTokens[tokenIndex]=lastTokenId;_allTokensIndex[lastTokenId]=tokenIndex;\\rdelete_allTokensIndex[tokenId];\\r_allTokens.pop();\\r}",
    "{}",
    "{uint256lastTokenIndex=_allTokens.length-1;uint256tokenIndex=_allTokensIndex[tokenId];uint256lastTokenId=_allTokens[lastTokenIndex];_allTokens[tokenIndex]=lastTokenId;_allTokensIndex[lastTokenId]=tokenIndex;delete_allTokensIndex[tokenId];_allTokens.pop();}"
  ],
  "_addTokenToOwnerEnumeration": [
    "{uint256length=BRC721.balanceOf(to);_ownedTokens[to][length]=tokenId;_ownedTokensIndex[tokenId]=length;}",
    "{\\ruint256length=ERC721.balanceOf(to);\\r_ownedTokens[to][length]=tokenId;\\r_ownedTokensIndex[tokenId]=length;\\r}",
    "{uint256length=balanceOf(to);_ownedTokens[to][length]=tokenId;_ownedTokensIndex[tokenId]=length;}",
    "{_ownedTokensIndex[tokenId]=_ownedTokens[to].length;_ownedTokens[to].push(tokenId);}",
    "{}",
    "{uint256length=ERC721.balanceOf(to);_ownedTokens[to][length]=tokenId;_ownedTokensIndex[tokenId]=length;}"
  ],
  "_approve": [
    "{kittyIndexToApproved[_tokenId]=_approved;}",
    "{_tokenApprovals[tokenId]=to;emitApproval(BRC721.ownerOf(tokenId),to,tokenId);}",
    "{\\r_tokenApprovals[tokenId]=to;\\remitApproval(ERC721.ownerOf(tokenId),to,tokenId);\\r}_checkOnERC721Received {\\rif(to.isContract()){\\rtryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){\\rreturnretval==IERC721Receiver.onERC721Received.selector;\\r}catch(bytesmemoryreason){\\rif(reason.length==0){\\rrevert(\"ERC721:transfertononERC721Receiverimplementer\");\\r}else{\\rassembly{\\rrevert(add(32,reason),mload(reason))\\r}\\r}\\r}\\r}else{\\rreturntrue;\\r}\\r}",
    "{addressowner=ownerOf(tokenId);if(approvalCheck&&_msgSenderERC721A()!=owner)if(!isApprovedForAll(owner,_msgSenderERC721A())){_revert(ApprovalCallerNotOwnerNorApproved.selector);}_tokenApprovals[tokenId].value=to;emitApproval(owner,to,tokenId);}",
    "{\\r_tokenApprovals[tokenId]=to;\\remitApproval(ERC721.ownerOf(tokenId),to,tokenId);\\r}",
    "{_tokenApprovals[tokenId]=to;emitApproval(owner,to,tokenId);}",
    "{_tokenApprovals[tokenId]=to;emitApproval(ownerOf(tokenId),to,tokenId);}",
    "{_tokenApprovals[tokenId]=to;emitApproval(ERC721.ownerOf(tokenId),to,tokenId);}",
    "{require(owner!=address(0),\"ERC20:approvefromthezeroaddress\");require(spender!=address(0),\"ERC20:approvetothezeroaddress\");_allowances[owner][spender]=amount;emitApproval(owner,spender,amount);}",
    "{_tokenApprovals[tokenId]=to;emitApproval(ERC721.ownerOf(tokenId),to,tokenId);//internalowner}"
  ],
  "msgSender": [
    "{if(msg.sender==address(this)){bytesmemoryarray=msg.data;uint256index=msg.data.length;assembly{sender:=and(mload(add(array,index)),0xffffffffffffffffffffffffffffffffffffffff)}}else{sender=payable(msg.sender);}returnsender;}",
    "{assembly{sender:=shr(96,calldataload(sub(calldatasize(),20)))}}"
  ],
  "_msgSender": [
    "{returnBaseRelayRecipient._msgSender();}",
    "{\\rreturnpayable(msg.sender);\\r}",
    "{returnERC2771Context._msgSender();}",
    "{\\rreturnmsg.sender;\\r}",
    "{\\rreturnGameRegistryConsumer._msgSender();\\r}",
    "{returnContextMixin.msgSender();}",
    "{returnmsg.sender;}",
    "{returnmsgSender();}",
    "{returnpayable(msg.sender);}",
    "{returnForwarderRegistryContextBase._msgSender();}",
    "{returnGameRegistryConsumer._msgSender();}"
  ],
  "emitPoolAdded": [],
  "emitPoolUpdated": [],
  "PoolAdded": [],
  "PoolUpdated": [],
  "PoolRemoved": [],
  "TransferToNonERC721ReceiverImplementer": [],
  "min": ["{returna<b?a:b;}"],
  "div": [
    "{//Solidityonlyautomaticallyassertswhendividingby0require(b>0);uint256c=a/b;//assert(a==b*c+a%b);//Thereisnocaseinwhichthisdoesn'tholdreturnc;}",
    "{require(b>0,errorMessage);returna/b;}",
    "{require(b>0,errorMessage);uint256c=a/b;returnc;}",
    "{require(b>0,\"\");returna/b;}",
    "{require(_divisor>0,\"\");quotient=_dividend/_divisor;}"
  ],
  "getDistribution": [
    "{uint256from=Math.max(startTime,_from);uint256to=Math.min(_to,contractDisabledAt==0?endTime:contractDisabledAt);if(from>to)returnuint256(0);from=from.sub(startTime);to=to.sub(startTime);//d(t1,t2)=(t2-t1)*(2*ds-(-m)*(t2+t1))/2returnto.sub(from).mul(startDistribution.mul(2).sub(distributionSlope.mul(from.add(to))))/2;}"
  ],
  "mul": [
    "{if(a==0){return0;}uint256c=a*b;require(c/a==b,\"SafeMath:multiplicationoverflow\");returnc;}",
    "{//Gasoptimization:thisischeaperthanrequiring'a'notbeingzero,butthe//benefitislostif'b'isalsotested.//See:https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522if(a==0){return0;}uint256c=a*b;require(c/a==b);returnc;}",
    "{if(a==0)return0;uint256c=a*b;require(c/a==b,\"SafeMath:multiplicationoverflow\");returnc;}",
    "{if(a==0)return0;uint256c=a*b;require(c/a==b,\"\");returnc;}",
    "{if(_factor1==0){return0;}product=_factor1*_factor2;require(product/_factor1==_factor2,\"\");}"
  ],
  "at": [
    "{returnuint256(_at(set._inner,index));}",
    "{(bytes32key,bytes32value)=_at(map._inner,index);return(uint256(key),address(uint160(uint256(value))));}"
  ],
  "_at": [
    "{require(map._entries.length>index,\"EnumerableMap:indexoutofbounds\");MapEntrystorageentry=map._entries[index];return(entry._key,entry._value);}",
    "{require(set._values.length>index,\"EnumerableSet:indexoutofbounds\");returnset._values[index];}",
    "{returnuint256(_at(set._inner,index));}",
    "{(bytes32key,bytes32value)=_at(map._inner,index);return(uint256(key),address(uint160(uint256(value))));}",
    "{require(map._entries.length>index,\"\");MapEntrystorageentry=map._entries[index];return(entry._key,entry._value);}"
  ],
  "updatePool": [
    "{PoolInfostoragepool=poolInfo[_poolToken];if(block.timestamp<=pool.lastRewardTimestamp){return;}uint256totalShares=pool.totalShares;if(totalShares==0){pool.lastRewardTimestamp=block.timestamp;return;}uint256dist=getDistribution(pool.lastRewardTimestamp,block.timestamp);uint256hsfReward=dist.mul(pool.allocation).div(totalAllocationPoints);uint256poolScaledRewards=hsfReward.div(totalShares);pool.accHsfPerShare=pool.accHsfPerShare.add(poolScaledRewards);pool.lastRewardTimestamp=block.timestamp;}"
  ],
  "massUpdatePools": [
    "{uint256length=pools.length();for(uint256pid=0;pid<length;pid++){updatePool(IERC20(pools.at(pid)));}}"
  ],
  "max": ["{returna>b?a:b;}", "{returna>=b?a:b;}"],
  "add": [
    "{uint256c=a+b;require(c>=a);returnc;}",
    "{require(address(rewardManager)!=address(0),\"HF:RewardManagernotsetupyet\");require(_allocation>0,\"HF:Toolowallocation\");massUpdatePools();require(pools.add(address(_lpToken)),\"HF:LPpoolalreadyexists\");uint256lastRewardTimestamp=Math.max(block.timestamp,startTime);totalAllocationPoints=totalAllocationPoints.add(_allocation);poolInfo[_lpToken]=PoolInfo({allocation:_allocation,lastRewardTimestamp:lastRewardTimestamp,accHsfPerShare:0,totalShares:0});emitPoolAdded(_lpToken,_allocation);}",
    "{if(account==address(0)){revertUnauthorized();}elseif(has(role,_type,account)){revertMaxSplaining({reason:string(abi.encodePacked(\"LibRoles:\",Strings.toHexString(uint160(account),20),\"alreadyhasrole\",Strings.toHexString(uint32(_type),4)))});}role.bearer[account][_type]=true;emitRoleChanged(_type,account,true);}",
    "{}",
    "{\\rreturn_add(set._inner,bytes32(value));\\r}",
    "{c=a+b;require(c>=a);returnc;}",
    "{minters[_minter]=true;emitMinterRoleGranted(_minter);}",
    "{require(value<type(uint240).max,\"Outofrange\");uint256amountPos=BalanceAmount.unwrap(b);uint240amount=uint240(amountPos>>16);uint16position=uint16(amountPos&0xffff);amount+=uint240(value);amountPos=(uint256(amount)<<16)|position;returnBalanceAmount.wrap(amountPos);}",
    "",
    "{uintc=a+b;require(c>=a,\"SafeMath:additionoverflow\");returnc;}",
    "{c=a+b;assert(c\\u003e=a);returnc;}",
    "{returna+b;}",
    "{uint256c=a+b;require(c>=a,\"SafeMath:additionoverflow\");returnc;}",
    "{return_add(set._inner,bytes32(value));}",
    "{require(!has(role,account),\"Roles:accountalreadyhasrole\");role.bearer[account]=true;}",
    "{sum=_addend1+_addend2;require(sum>=_addend1,\"\");}"
  ],
  "_exists": [
    "{returntokenId<_currentIndex&&!_ownerships[tokenId].burned;}",
    "{\\rreturn_tokenOwners.contains(tokenId);\\r}",
    "{return_ownerOf(tokenId)!=address(0);}",
    "{return_startTokenId()\\u003c=tokenId\\u0026\\u0026tokenId\\u003c_currentIndex\\u0026\\u0026_packedOwnerships[tokenId]\\u0026_BITMASK_BURNED==0;}",
    "{\\rreturn_owners[tokenId]!=address(0);\\r}",
    "{return_startTokenId()<=tokenId&&tokenId<currentIndex;}",
    "{return_owners[tokenId]!=address(0);}",
    "{addressowner=_tokenOwner[tokenId];returnowner!=address(0);}",
    "{return_startTokenId()<=tokenId&&tokenId<_currentIndex&&_packedOwnerships[tokenId]&_BITMASK_BURNED==0;}",
    "{returntokenId<_owners.length;}",
    "{return_startTokenId()<=tokenId&&tokenId<_currentIndex&&//Ifwithinbounds,_packedOwnerships[tokenId]&_BITMASK_BURNED==0;//andnotburned.}",
    "{return_startTokenId()<=tokenId&&tokenId<_currentIndex&&!_ownerships[tokenId].burned;}",
    "{returntokenId>0&&tokenId<=getNumMinted()&&_tokens[tokenId].owner!=0x0;}",
    "{return_tokenOwners.contains(tokenId);}",
    "{returntokenId<currentIndex;}"
  ],
  "ownerOf": [
    "{owner=kittyIndexToOwner[_tokenId];require(owner!=address(0));}",
    "{addressowner=_owners[tokenId];if(owner==address(0)){return_admin;}returnowner;}",
    "{addressowner=idToOwner[_tokenId];require(owner!=address(0),\"VENFT:ownerqueryfornonexistenttoken\");returnowner;}",
    "{\\rreturn_tokenOwners.get(tokenId,\"ERC721:ownerqueryfornonexistenttoken\");\\r}",
    "{addressowner=_owners[tokenId];require(owner!=address(0),'ERC721:ownerqueryfornonexistenttoken');returnowner;}",
    "{addressowner=erc721Storage().owners[tokenId];require(owner!=address(0),\"ERC721:ownerqueryfornonexistenttoken\");returnowner;}",
    "{addressowner=_tokenOwner[tokenId];require(owner!=address(0),\"ERC721:ownerqueryfornonexistenttoken\");returnowner;}",
    "{\\raddressowner=_owners[tokenId];\\rrequire(owner!=address(0),\"ERC721:ownerqueryfornonexistenttoken\");\\rreturnowner;\\r}",
    "{require(idToOwner[_tokenId]!=address(0));_owner=idToOwner[_tokenId];}",
    "{return_ownershipOf(tokenId).addr;}",
    "{returnownershipOf(tokenId).addr;}",
    "{return_ownerOf(tokenId)!=address(0);}",
    "{addressowner=_ownerOf(tokenId);require(owner!=address(0),\"ERC721:invalidtokenID\");returnowner;}",
    "{addressowner=_owners[tokenId];require(owner!=address(0),\"ERC721:ownerqueryfornonexistenttoken\");returnowner;}",
    "{require(_exists(tokenId),\"ERC721:ownerqueryfornonexistenttoken\");returnaddress(_tokens[tokenId].owner);}",
    "{addressowner=_owners[tokenId];require(owner!=address(0),\"ERC721:invalidtokenID\");returnowner;}",
    "{require(_exists(tokenId),\"ERC721:ownerqueryfornonexistenttoken\");returnaddress(_tokens[tokenId].owner);}",
    "{returnaddress(uint160(_packedOwnershipOf(tokenId)));}",
    "{require(expiries[tokenId]>now);returnsuper.ownerOf(tokenId);}",
    "{uint256owner=s.owners[tokenId];require(_tokenExists(owner),\"ERC721:non-existingtoken\");return_tokenOwner(owner);}",
    "{return_tokenOwners.get(tokenId,\"ERC721:ownerqueryfornonexistenttoken\");}",
    "{returnnfOwners[_id];}",
    "{return_owners[_id];}",
    "{if(!_exists(tokenId))revertOwnerQueryForNonexistentToken();//Cannotrealisticallyoverflow,sinceweareusinguint256unchecked{for(tokenId;;tokenId++){if(_owners[tokenId]!=address(0)){return_owners[tokenId];}}}revertUnableDetermineTokenOwner();}",
    "{addressowner=_owners[tokenId];require(owner!=address(0),\"\");returnowner;}",
    "{_owner=idToOwner[_tokenId];require(_owner!=address(0),\"\");}"
  ],
  "_checkOnERC721Received": [
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revertTransferToNonERC721ReceiverImplementer();}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{\\rif(!to.isContract()){\\rreturntrue;\\r}\\rbytesmemoryreturndata=to.functionCall(abi.encodeWithSelector(\\rIERC721Receiver(to).onERC721Received.selector,\\r_msgSender(),\\rfrom,\\rtokenId,\\r_data\\r),\"ERC721:transfertononERC721Receiverimplementer\");\\rbytes4retval=abi.decode(returndata,(bytes4));\\rreturn(retval==_ERC721_RECEIVED);\\r}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert('ERC721:transfertononERC721Receiverimplementer');}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{\\rif(to.isContract()){\\rtryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){\\rreturnretval==IERC721Receiver.onERC721Received.selector;\\r}catch(bytesmemoryreason){\\rif(reason.length==0){\\rrevert(\"ERC721:transfertononERC721Receiverimplementer\");\\r}else{\\rassembly{\\rrevert(add(32,reason),mload(reason))\\r}\\r}\\r}\\r}else{\\rreturntrue;\\r}\\r}",
    "{\\rif(to.isContract()){\\rtryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){\\rreturnretval==IERC721Receiver(to).onERC721Received.selector;\\r}catch(bytesmemoryreason){\\rif(reason.length==0){\\rrevert(\"ERC721:transfertononERC721Receiverimplementer\");\\r}else{\\rassembly{\\rrevert(add(32,reason),mload(reason))\\r}\\r}\\r}\\r}else{\\rreturntrue;\\r}\\r}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721A:transfertononERC721Receiverimplementer\");}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{///@soliditymemory-safe-assemblyassembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(!to.isContract()){returntrue;}bytes4retval=IERC721Receiver(to).onERC721Received(msg.sender,from,tokenId,_data);return(retval==_ERC721_RECEIVED);}",
    "{if(to.code.length==0)returntrue;tryIERC721Receiver(to).onERC721Received(msg.sender,from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0)revertTransferToNonERC721ReceiverImplementer();assembly{revert(add(32,reason),mload(reason))}}}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver.onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{assembly{revert(add(32,reason),mload(reason))}}}}returntrue;}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{//solhint-disable-next-lineno-inline-assemblyassembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}",
    "{if(!to.isContract()){returntrue;}bytesmemoryreturndata=to.functionCall(abi.encodeWithSelector(IERC721Receiver(to).onERC721Received.selector,_msgSender(),from,tokenId,_data),\"ERC721:transfertononERC721Receiverimplementer\");bytes4retval=abi.decode(returndata,(bytes4));return(retval==_ERC721_RECEIVED);}",
    "{if(to.isContract()){tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revert(\"ERC721:transfertononERC721Receiverimplementer\");}else{assembly{revert(add(32,reason),mload(reason))}}}}else{returntrue;}}"
  ],
  "safeTransferFrom": [
    "{transferFrom(from,to,id);require(to.code.length==0||ERC721TokenReceiver(to).onERC721Received(msg.sender,from,id,data)==ERC721TokenReceiver.onERC721Received.selector,\"UNSAFE_RECIPIENT\");}",
    "{_transfer(from,to,tokenId);if(!_checkOnERC721Received(from,to,tokenId,_data)){revertTransferToNonERC721ReceiverImplementer();}}",
    " {_transfer(from,to,tokenId);if(!_checkOnERC721Received(from,to,tokenId,_data)){revertTransferToNonERC721ReceiverImplementer();}}",
    "{//Pretransferchecks.addressoperator=_msgSender();require(!paused(),\"Error:tokentransferwhilepaused\");_transfer(from,to,operator,id);//Posttransfer:checkIERC721Receiverwithdatainput.require(_checkOnERC721Received(from,to,id,data),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{_mintIfNotExist(tokenId);require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_safeTransfer(from,to,tokenId,_data);}",
    "{safeTransferFrom(_from,_to,_tokenId,'');}",
    "{\\r(boolsuccess,bytesmemorydata)=token.call(abi.encodeWithSelector(0x23b872dd,from,to,value));\\rrequire(success\\u0026\\u0026(data.length==0||abi.decode(data,(bool))),\\u0027TransferHelper:TRANSFER_FROM_FAILED\\u0027);\\r}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),'ERC721:transfercallerisnotownernorapproved');_safeTransfer(from,to,tokenId,_data);}",
    "{\\rrequire(to!=address(this),\"Recipientcannotbetheaddressofthecontract\");\\rsuper.safeTransferFrom(from,to,tokenId,_data);\\rrentedTokensLandlords[tokenId]=address(0);\\r}",
    "{require(from==_msgSender()||isApprovedForAll(from,_msgSender())||isApprovedForPool(id,_msgSender()),\"ERC1155WithTerminusStorage:callerisnotownernorapproved\");_safeTransferFrom(from,to,id,amount,data);}",
    "{require(to!=address(this),\"Recipientcannotbetheaddressofthecontract\");super.safeTransferFrom(from,to,tokenId,_data);rentedTokensLandlords[tokenId]=address(0);}",
    "{transferFrom(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,_data),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{\\rsuper.safeTransferFrom(from,to,tokenId,data);\\r}",
    "{\\rrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");\\r_safeTransfer(from,to,tokenId,_data);\\r}",
    "{_safeTransferFrom(_from,_to,_tokenId,\"\");}",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||getApproved(tokenId)==_msgSender()||isApprovedForAll(prevOwnership.addr,_msgSender()));require(isApprovedOrOwner,\"ERC721A:transfercallerisnotownernorapproved\");require(prevOwnership.addr==from,\"ERC721A:transferfromincorrectowner\");require(to!=address(0),\"ERC721A:transfertothezeroaddress\");_beforeTokenTransfers(from,to,tokenId,1);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId,prevOwnership.addr);_addressData[from].balance-=1;_addressData[to].balance+=1;_ownerships[tokenId]=TokenOwnership(to,uint64(block.timestamp));//IftheownershipslotoftokenId+1isnotexplicitlyset,thatmeansthetransferinitiatorownsit.//SettheslotoftokenId+1explicitlyinstoragetomaintaincorrectnessforownerOf(tokenId+1)calls.uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(_exists(nextTokenId)){_ownerships[nextTokenId]=TokenOwnership(prevOwnership.addr,prevOwnership.startTimestamp);}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{super.safeTransferFrom(from,to,tokenId,data);}",
    "{_transfer(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,_data),\"ERC721A:transfertononERC721Receiverimplementer\");}",
    "{\\rrequire(to!=address(0),\"ERC1155:transfertothezeroaddress\");\\rrequire(\\rfrom==_msgSender()||isApprovedForAll(from,_msgSender()),\\r\"ERC1155:callerisnotownernorapproved\"\\r);\\r\\raddressoperator=_msgSender();\\r\\ruint256fromBalance=_balances[id][from];\\rrequire(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");\\r_balances[id][from]=fromBalance-amount;\\r_balances[id][to]+=amount;\\r\\remitTransferSingle(operator,from,to,id,amount);\\r\\r_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);\\r}",
    "{//bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));(boolsuccess,bytesmemorydata)=token.call(abi.encodeWithSelector(0x23b872dd,from,to,value));require(success&&(data.length==0||abi.decode(data,(bool))),'Transferfailed');}",
    "{_pushBurn(from,nftId,amount);_pushMint(to,nftId,amount);super.safeTransferFrom(from,to,nftId,amount,data);}",
    "{require((msg.sender==_from)||isApprovedForAll(_from,msg.sender),\"INVALID_OPERATOR\");require(_to!=address(0),\"INVALID_RECIPIENT\");if(_id>RING&&_id<=RING+ttlRings){_updateIDUserTotalBalance(_to,RING_INDEX,_amount,Operations.Add);_updateIDUserTotalBalance(_from,RING_INDEX,_amount,Operations.Sub);}if(_id>AMULET&&_id<=AMULET+ttlAmulets){_updateIDUserTotalBalance(_to,AMULET_INDEX,_amount,Operations.Add);_updateIDUserTotalBalance(_from,AMULET_INDEX,_amount,Operations.Sub);}if(_id>FIGHTER&&_id<=FIGHTER+ttlFYakuzas){_updateIDUserTotalBalance(_to,FIGHTER_INDEX,_amount,Operations.Add);//Addamounttorecipient_updateIDUserTotalBalance(_from,FIGHTER_INDEX,_amount,Operations.Sub);//Addamounttorecipient}if(_id>FIGHT_CLUB&&_id<=FIGHT_CLUB+ttlFightClubs){_updateIDUserTotalBalance(_to,FIGHT_CLUB_INDEX,_amount,Operations.Add);//Addamounttorecipient_updateIDUserTotalBalance(_from,FIGHT_CLUB_INDEX,_amount,Operations.Sub);//AddamounttorecipientidToForgeFightClub[_id].owner=_to;}if(_id>FORGE&&_id<=FORGE+ttlForges){_updateIDUserTotalBalance(_to,FORGE_INDEX,_amount,Operations.Add);//Addamounttorecipient_updateIDUserTotalBalance(_from,FORGE_INDEX,_amount,Operations.Sub);//AddamounttorecipientidToForgeFightClub[_id].owner=_to;}_safeTransferFrom(_from,_to,_id,_amount);_callonERC1155Received(_from,_to,_id,_amount,gasleft(),_data);}",
    "{super.safeTransferFrom(from,to,id,amount,data);}",
    "{//bytes4(keccak256(bytes(transferFrom(address,address,uint256))));(boolsuccess,bytesmemorydata)=token.call(abi.encodeWithSelector(0x23b872dd,from,to,value));require(success&&(data.length==0||abi.decode(data,(bool))),Transferfailed);}",
    "{//bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));(boolsuccess,bytesmemorydata)=token.call(abi.encodeWithSelector(0x23b872dd,from,to,value));require(success&&(data.length==0||abi.decode(data,(bool))),\"Transferfailed\");}",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:callerisnotownernorapproved\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);_balances[id][from]=_balances[id][from].sub(amount,\"ERC1155:insufficientbalancefortransfer\");_balances[id][to]=_balances[id][to].add(amount);emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:callerisnotownernorapproved\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");_balances[id][from]=fromBalance-amount;_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{\rrequire(to!=address(0),\"ERC1155:transfertothezeroaddress\");\rrequire(\rfrom==_msgSender()||isApprovedForAll(from,_msgSender()),\r\"ERC1155:callerisnotownernorapproved\"\r);\r\raddressoperator=_msgSender();\r\ruint256fromBalance=_balances[id][from];\rrequire(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");\r_balances[id][from]=fromBalance-amount;\r_balances[id][to]+=amount;\r\remitTransferSingle(operator,from,to,id,amount);\r\r_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);\r}",
    "{\\rrequire(to!=address(0),\"ERC1155:transfertothezeroaddress\");\\rrequire(\\rfrom==_msgSender()||isApprovedForAll(from,_msgSender()),\\r\"ERC1155:callerisnotownernorapproved\"\\r);\\r\\raddressoperator=_msgSender();\\r\\ruint256fromBalance=_balances[id][from];\\rrequire(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");\\r_balances[id][from]=fromBalance-amount;\\r_balances[id][to]+=amount;\\r\\remitTransferSingle(operator,from,to,id,amount);\\r\\r_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);\\r},",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{_transfer(from,to,tokenId);if(to.isContract()&&!_checkContractOnERC721Received(from,to,tokenId,_data)){revertTransferToNonERC721ReceiverImplementer();}}",
    "{require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:callerisnotownernorapproved\");_safeTransferFrom(from,to,id,amount,data);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownernorapproved\");_safeTransfer(from,to,tokenId,data);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownerorapproved\");_safeTransfer(from,to,tokenId,data);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_safeTransfer(from,to,tokenId,_data);}",
    "{transferFrom(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,_data));}",
    "{transferFrom(from,to,tokenId);if(to.code.length!=0)if(!_checkContractOnERC721Received(from,to,tokenId,_data)){revertTransferToNonERC721ReceiverImplementer();}}",
    "{transferFrom(from,to,id);if(!_checkOnERC721Received(from,to,id,data))revertTransferToNonERC721ReceiverImplementer();}",
    "{_callOptionalReturn(token,abi.encodeWithSelector(token.transferFrom.selector,from,to,value));}",
    "{\\rrequire(\\rfrom==_msgSender()||isApprovedForAll(from,_msgSender()),\\r\"ERC1155:callerisnottokenownernorapproved\"\\r);\\r_safeTransferFrom(from,to,id,amount,data);\\r}",
    "{require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:callerisnottokenownerorapproved\");_safeTransferFrom(from,to,id,amount,data);}",
    "{require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:callerisnottokenownernorapproved\");_safeTransferFrom(from,to,id,amount,data);}",
    "{require(_to!=address(0x0),\"cannotsendtozeroaddress\");require(_from==msg.sender||operatorApproval[_from][msg.sender]==true,\"Needoperatorapprovalfor3rdpartytransfers.\");if(isNonFungible(_id)){require(nfOwners[_id]==_from);nfOwners[_id]=_to;uint256baseType=getNonFungibleBaseType(_id);balances[baseType][_from]=balances[baseType][_from].sub(_value);balances[baseType][_to]=balances[baseType][_to].add(_value);}else{balances[_id][_from]=balances[_id][_from].sub(_value);balances[_id][_to]=balances[_id][_to].add(_value);}emitTransferSingle(msg.sender,_from,_to,_id,_value);if(_to.isContract()){_doSafeTransferAcceptanceCheck(msg.sender,_from,_to,_id,_value,_data);}}",
    "{require(_isApprovedOrOwner(_msgSender(),\"\"),\"ERC721:transfercallerisnotownernorapproved\");_safeTransfer(from,to,tokenId,_data);}"
  ],
  "isApprovedOperatorRole": [
    "",
    "returnhasRole(APPROVED_OPERATOR_ROLE,account);}",
    "{returnhasRole(APPROVED_OPERATOR_ROLE,account);}"
  ],
  "_isApprovedOrOwner": [
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||isApprovedForAll(prevOwnership.addr,_msgSender())||getApproved(tokenId)==_msgSender());returnisApprovedOrOwner;}",
    "{require(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");addressowner=BRC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{addressowner=idToOwner[_tokenId];boolspenderIsOwner=owner==_spender;boolspenderIsApproved=_spender==idToApprovals[_tokenId];boolspenderIsApprovedForAll=(ownerToOperators[owner])[_spender];returnspenderIsOwner||spenderIsApproved||spenderIsApprovedForAll;}",
    "{\\rrequire(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");\\raddressowner=ERC721.ownerOf(tokenId);\\rreturn(spender==owner||getApproved(tokenId)==spender||ERC721.isApprovedForAll(owner,spender));\\r}",
    "{require(_exists(tokenId),'ERC721:operatorqueryfornonexistenttoken');addressowner=ERC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{returnsuper._isApprovedOrOwner(spender,tokenId)||super.isApprovedOperatorRole(spender);}",
    "{\\rrequire(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");\\raddressowner=ERC721.ownerOf(tokenId);\\rreturn(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));\\r}",
    "{\\rrequire(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");\\raddressowner=ERC721.ownerOf(tokenId);\\rreturn(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));\\r}",
    "{addressowner=ERC721.ownerOf(tokenId);return(spender==owner||isApprovedForAll(owner,spender)||getApproved(tokenId)==spender);}",
    "{require(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||ERC721.isApprovedForAll(owner,spender));}",
    "{require(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{addressowner=ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{require(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||isApprovedForAll(owner,spender)||getApproved(tokenId)==spender);}",
    "{require(_exists(tokenId),\"ERC721:operatorqueryfornonexistenttoken\");addressowner=ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{\\rreturnsuper._isApprovedOrOwner(spender,tokenId)||super.isApprovedOperatorRole(spender);\\r}",
    "{require(_exists(tokenId),\"\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||isApprovedForAll(owner,spender));}",
    "{require(_exists(tokenId),\"\");addressowner=ERC721.ownerOf(tokenId);return(spender==owner||getApproved(tokenId)==spender||ERC721.isApprovedForAll(owner,spender));}"
  ],
  "isApprovedForAll": [
    "{return_operatorApprovals[owner][operator];}\n      transferFrom {//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownerorapproved\");_transfer(from,to,tokenId);}",
    "{return_operatorApprovals[owner][operator];}transferFrom {//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownerorapproved\");_transfer(from,to,tokenId);}",
    "{return(ownerToOperators[_owner])[_operator];}",
    "{return_operatorApprovals[owner][operator];}transferFrom {//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),'ERC721:transfercallerisnotownernorapproved');_transfer(from,to,tokenId);}",
    "{returnLibTerminus.terminusStorage().globalOperatorApprovals[account][operator];}",
    "{\\rreturn_operatorApprovals[owner][operator];\\r}",
    "{returnownerToOperators[_owner][_operator];}",
    "{returnoperators[_owner][_operator];}",
    "{\\rreturn_operatorApprovals[account][operator];\\r}",
    "{return_operatorApprovals[account][operator];}",
    "{return_operatorApprovals[owner][operator];}",
    "{returns.operators[owner][operator];}",
    "{returnoperatorApproval[_owner][_operator];}",
    "{returnERC721.isApprovedForAll(account,operator)&&ERC1155.isApprovedForAll(account,operator);}"
  ],
  "getApproved": [
    "{require(exists(tokenId),\"ERC721:approvedqueryfornonexistenttoken\");return_tokenApprovals[tokenId];}",
    "{returnidToApprovals[_tokenId];}",
    "{require(_exists(tokenId),'ERC721:approvedqueryfornonexistenttoken');return_tokenApprovals[tokenId];}",
    "{require(exists(tokenId),\"ERC721:approvedqueryfornonexistenttoken\");returnerc721Storage().tokenApprovals[tokenId];}",
    "{if(!_exists(tokenId))_revert(ApprovalQueryForNonexistentToken.selector);return_tokenApprovals[tokenId].value;}",
    "{\\rrequire(_exists(tokenId),\"ERC721:approvedqueryfornonexistenttoken\");\\r\\rreturn_tokenApprovals[tokenId];\\r}",
    "{returnidToApproval[_tokenId];}",
    "{require(_exists(tokenId),\"ERC721A:approvedqueryfornonexistenttoken\");return_tokenApprovals[tokenId];}",
    "{_requireMinted(tokenId);return_tokenApprovals[tokenId];}",
    "{require(_exists(tokenId),\"ERC721:approvedqueryfornonexistenttoken\");return_tokenApprovals[tokenId];}",
    "{require(_exists(tokenId));return_tokenApprovals[tokenId];}",
    "{if(!_exists(tokenId))revertApprovalQueryForNonexistentToken();return_tokenApprovals[tokenId].value;}",
    "{if(!_exists(tokenId))revertApprovalQueryForNonexistentToken();return_tokenApprovals[tokenId];}",
    "{if(!_exists(tokenId))revertApprovalQueryForNonexistentToken();return_tokenApprovals[tokenId].value;}",
    "{if(!_exists(tokenId))revertApprovalQueryForNonexistentToken();return_tokenApprovals[tokenId];}",
    "{uint256owner=s.owners[tokenId];require(_tokenExists(owner),\"ERC721:non-existingtoken\");if(_tokenHasApproval(owner)){returns.approvals[tokenId];}else{returnaddress(0);}}",
    "{require(_exists(tokenId),\"\");return_tokenApprovals[tokenId];}"
  ],
  "_safeTransfer": [
    "",
    "{_transfer(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,_data),'ERC721:transfertononERC721Receiverimplementer');}",
    "{\\r_transfer(from,to,tokenId);\\rrequire(_checkOnERC721Received(from,to,tokenId,_data),\"ERC721:transfertononERC721Receiverimplementer\");\\r}",
    "{_transfer(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,data),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{_transfer(from,to,tokenId);require(_checkOnERC721Received(from,to,tokenId,_data),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{addresstokenOwner=idToOwner[_tokenId];require(tokenOwner==_from,\"Incorrectowner.\");require(_to!=address(0));_transfer(_to,_tokenId);if(isContract(_to)){bytes4retval=ERC721TokenReceiver(_to).onERC721Received(msg.sender,_from,_tokenId,_data);require(retval==MAGIC_ON_ERC721_RECEIVED);}}",
    "{_transfer(from,to,tokenId);require(_checkOnERC721Received(from,\"\"),\"ERC721:transfertononERC721Receiverimplementer\");}"
  ],
  "TokenOwnership": [""],
  "_clearApproval": [
    "{//Throwsif`_owner`isnotthecurrentownerassert(idToOwner[_tokenId]==_owner);if(idToApprovals[_tokenId]!=address(0)){//ResetapprovalsidToApprovals[_tokenId]=address(0);}}",
    "{if(idToApproval[_tokenId]!=address(0)){deleteidToApproval[_tokenId];}}",
    "{if(_tokenApprovals[tokenId]!=address(0)){_tokenApprovals[tokenId]=address(0);}}"
  ],
  "_removeNFToken": [
    "{require(idToOwner[_tokenId]==_from,\"Incorrectowner.\");deleteidToOwner[_tokenId];uint256tokenToRemoveIndex=idToOwnerIndex[_tokenId];uint256lastTokenIndex=ownerToIds[_from].length.sub(1);if(lastTokenIndex!=tokenToRemoveIndex){uint256lastToken=ownerToIds[_from][lastTokenIndex];ownerToIds[_from][tokenToRemoveIndex]=lastToken;idToOwnerIndex[lastToken]=tokenToRemoveIndex;}ownerToIds[_from].pop();}",
    "{require(idToOwner[_tokenId]==_from,\"\");deleteidToOwner[_tokenId];uint256tokenToRemoveIndex=idToOwnerIndex[_tokenId];uint256lastTokenIndex=ownerToIds[_from].length-1;if(lastTokenIndex!=tokenToRemoveIndex){uint256lastToken=ownerToIds[_from][lastTokenIndex];ownerToIds[_from][tokenToRemoveIndex]=lastToken;idToOwnerIndex[lastToken]=tokenToRemoveIndex;}ownerToIds[_from].pop();}"
  ],
  "_addNFToken": [
    "{require(idToOwner[_tokenId]==address(0),\"Cannotadd,alreadyowned.\");idToOwner[_tokenId]=_to;ownerToIds[_to].push(_tokenId);idToOwnerIndex[_tokenId]=ownerToIds[_to].length.sub(1);}",
    "{require(idToOwner[_tokenId]==address(0),\"\");idToOwner[_tokenId]=_to;ownerToIds[_to].push(_tokenId);idToOwnerIndex[_tokenId]=ownerToIds[_to].length-1;}"
  ],
  "_afterTokenTransfers": ["{}", ""],
  "_transfer": [
    "{//Sincethenumberofkittensiscappedto2^32wecan'toverflowthisownershipTokenCount[_to]++;//transferownershipkittyIndexToOwner[_tokenId]=_to;//Whencreatingnewkittens_fromis0x0,butwecan'taccountthataddress.if(_from!=address(0)){ownershipTokenCount[_from]--;//oncethekittenistransferredalsoclearsireallowancesdeletesireAllowedToAddress[_tokenId];//clearanypreviouslyapprovedownershipexchangedeletekittyIndexToApproved[_tokenId];}//Emitthetransferevent.Transfer(_from,_to,_tokenId);}",
    "{require(ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);}",
    "{require(_owners[id]==from);require(from==operator||getApproved(id)==operator||isApprovedForAll(from,operator),\"Error:callerisneitherownernorapproved\");_beforeTokenTransfer(from,to,id);//Transfer._balances[from]-=1;_balances[to]+=1;_owners[id]=to;emitTransfer(from,to,id);_tokenApprovals[id]=address(0);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId,1);//CheckthattokenIdwasnottransferredby`_beforeTokenTransfer`hookrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");//Clearapprovalsfromthepreviousownerdelete_tokenApprovals[tokenId];unchecked{//`_balances[from]`cannotoverflowforthesamereasonasdescribedin`_burn`://`from`'sbalanceisthenumberoftokenheld,whichisatleastonebeforethecurrent//transfer.//`_balances[to]`couldoverflowintheconditionsdescribedin`_mint`.Thatwouldrequire//all2**256tokenidstobeminted,whichinpracticeisimpossible._balances[from]-=1;_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId,1);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId,1);//CheckthattokenIdwasnottransferredby_beforeTokenTransferhookrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");//Clearapprovalsfromthepreviousownerdelete_tokenApprovals[tokenId];unchecked{//_balances[from]cannotoverflowforthesamereasonasdescribedin_burn://from'sbalanceisthenumberoftokenheld,whichisatleastonebeforethecurrent//transfer.//_balances[to]couldoverflowintheconditionsdescribedin_mint.Thatwouldrequire//all2**256tokenidstobeminted,whichinpracticeisimpossible._balances[from]-=1;_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId,1);}",
    "{require(BRC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);}",
    "{\\rrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");\\rrequire(to!=address(0),\"ERC721:transfertothezeroaddress\");\\r\\r_beforeTokenTransfer(from,to,tokenId);\\r\\r_approve(address(0),tokenId);\\r\\r_holderTokens[from].remove(tokenId);\\r_holderTokens[to].add(tokenId);\\r\\r_tokenOwners.set(tokenId,to);\\r\\remitTransfer(from,to,tokenId);\\r}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");delete_tokenApprovals[tokenId];_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId);}",
    "{\\rrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");\\rrequire(to!=address(0),\"ERC721:transfertothezeroaddress\");\\r\\r_beforeTokenTransfer(from,to,tokenId);\\r\\r_approve(address(0),tokenId);\\r\\r_balances[from]-=1;\\r_balances[to]+=1;\\r_owners[tokenId]=to;\\r\\remitTransfer(from,to,tokenId);\\r\\r_afterTokenTransfer(from,to,tokenId);\\r}",
    "{require(ERC721.ownerOf(tokenId)==from,'ERC721:transferoftokenthatisnotown');require(to!=address(0),'ERC721:transfertothezeroaddress');_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId,1);//CheckthattokenIdwasnottransferredby_beforeTokenTransferhookrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");//Clearapprovalsfromthepreviousownerdelete_tokenApprovals[tokenId];unchecked{//_balances[from]cannotoverflowforthesamereasonasdescribedin_burn://from'sbalanceisthenumberoftokenheld,whichisatleastonebeforethecurrent//transfer.//_balances[to]couldoverflowintheconditionsdescribedin_mint.Thatwouldrequire//all2**256tokenidstobeminted,whichinpracticeisimpossible._balances[from]-=1;_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId,1);}",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||isApprovedForAll(prevOwnership.addr,_msgSender())||getApproved(tokenId)==_msgSender());if(!isApprovedOrOwner)revertTransferCallerNotOwnerNorApproved();if(prevOwnership.addr!=from)revertTransferFromIncorrectOwner();if(to==address(0))revertTransferToZeroAddress();_beforeTokenTransfers(from,to,tokenId,1);_approve(address(0),tokenId,prevOwnership.addr);unchecked{_addressData[from].balance-=1;_addressData[to].balance+=1;_ownerships[tokenId].addr=to;_ownerships[tokenId].startTimestamp=uint64(block.timestamp);uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(nextTokenId<_currentIndex){_ownerships[nextTokenId].addr=prevOwnership.addr;_ownerships[nextTokenId].startTimestamp=prevOwnership.startTimestamp;}}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);}",
    "{\\rrequire(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");\\rrequire(to!=address(0),\"ERC721:transfertothezeroaddress\");\\r\\r_beforeTokenTransfer(from,to,tokenId);\\r\\r_approve(address(0),tokenId);\\r\\r_balances[from]-=1;\\r_balances[to]+=1;\\r_owners[tokenId]=to;\\r\\remitTransfer(from,to,tokenId);\\r}",
    "{addressfrom=idToOwner[_tokenId];_clearApproval(_tokenId);_removeNFToken(from,_tokenId);_addNFToken(_to,_tokenId);emitTransfer(from,_to,_tokenId);}",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||getApproved(tokenId)==_msgSender()||isApprovedForAll(prevOwnership.addr,_msgSender()));require(isApprovedOrOwner,\"ERC721A:transfercallerisnotownernorapproved\");require(prevOwnership.addr==from,\"ERC721A:transferfromincorrectowner\");require(to!=address(0),\"ERC721A:transfertothezeroaddress\");_beforeTokenTransfers(from,to,tokenId,1);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId,prevOwnership.addr);_addressData[from].balance-=1;_addressData[to].balance+=1;_ownerships[tokenId]=TokenOwnership(to,uint64(block.timestamp));//IftheownershipslotoftokenId+1isnotexplicitlyset,thatmeansthetransferinitiatorownsit.//SettheslotoftokenId+1explicitlyinstoragetomaintaincorrectnessforownerOf(tokenId+1)calls.uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(_exists(nextTokenId)){_ownerships[nextTokenId]=TokenOwnership(prevOwnership.addr,prevOwnership.startTimestamp);}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{TokenOwnershipmemoryprevOwnership=_ownershipOf(tokenId);if(prevOwnership.addr!=from)revertTransferFromIncorrectOwner();boolisApprovedOrOwner=(_msgSender()==from||isApprovedForAll(from,_msgSender())||getApproved(tokenId)==_msgSender());if(!isApprovedOrOwner)revertTransferCallerNotOwnerNorApproved();if(to==address(0))revertTransferToZeroAddress();_beforeTokenTransfers(from,to,tokenId,1);_approve(address(0),tokenId,from);unchecked{_addressData[from].balance-=1;_addressData[to].balance+=1;TokenOwnershipstoragecurrSlot=_ownerships[tokenId];currSlot.addr=to;currSlot.startTimestamp=uint64(block.timestamp);uint256nextTokenId=tokenId+1;TokenOwnershipstoragenextSlot=_ownerships[nextTokenId];if(nextSlot.addr==address(0)){if(nextTokenId!=_currentIndex){nextSlot.addr=from;nextSlot.startTimestamp=prevOwnership.startTimestamp;}}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||getApproved(tokenId)==_msgSender()||isApprovedForAll(prevOwnership.addr,_msgSender()));require(isApprovedOrOwner,\"ERC721A:transfercallerisnotownernorapproved\");require(prevOwnership.addr==from,\"ERC721A:transferfromincorrectowner\");require(to!=address(0),\"ERC721A:transfertothezeroaddress\");_beforeTokenTransfers(from,to,tokenId,1);_approve(address(0),tokenId,prevOwnership.addr);_addressData[from].balance-=1;_addressData[to].balance+=1;_ownerships[tokenId]=TokenOwnership(to,uint64(block.timestamp));uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(_exists(nextTokenId)){_ownerships[nextTokenId]=TokenOwnership(prevOwnership.addr,prevOwnership.startTimestamp);}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);boolisApprovedOrOwner=(_msgSender()==prevOwnership.addr||getApproved(tokenId)==_msgSender()||isApprovedForAll(prevOwnership.addr,_msgSender()));require(isApprovedOrOwner,\"ERC721A:transfercallerisnotownernorapproved\");require(prevOwnership.addr==from,\"ERC721A:transferfromincorrectowner\");require(to!=address(0),\"ERC721A:transfertothezeroaddress\");_beforeTokenTransfers(from,to,tokenId,1);_approve(address(0),tokenId,prevOwnership.addr);_addressData[from].balance-=1;_addressData[to].balance+=1;_ownerships[tokenId]=TokenOwnership(to,uint64(block.timestamp));uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(_exists(nextTokenId)){_ownerships[nextTokenId]=TokenOwnership(prevOwnership.addr,prevOwnership.startTimestamp);}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{}",
    "{require(sender!=address(0),\"ERC20:transferfromthezeroaddress\");require(recipient!=address(0),\"ERC20:transfertothezeroaddress\");_beforeTokenTransfer(sender,recipient,amount);uint256senderBalance=_balances[sender];require(senderBalance>=amount,\"ERC20:transferamountexceedsbalance\");unchecked{_balances[sender]=senderBalance-amount;}_balances[recipient]+=amount;emitTransfer(sender,recipient,amount);_afterTokenTransfer(sender,recipient,amount);}",
    "{require(from!=address(0),\"ERC20:transferfromthezeroaddress\");require(to!=address(0),\"ERC20:transfertothezeroaddress\");_beforeTokenTransfer(from,to,amount);uint256fromBalance=_balances[from];require(fromBalance>=amount,\"ERC20:transferamountexceedsbalance\");unchecked{_balances[from]=fromBalance-amount;//Overflownotpossible:thesumofallbalancesiscappedbytotalSupply,andthesumispreservedby//decrementingthenincrementing._balances[to]+=amount;}emitTransfer(from,to,amount);_afterTokenTransfer(from,to,amount);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId,1);require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferfromincorrectowner\");delete_tokenApprovals[tokenId];unchecked{_balances[from]-=1;_balances[to]+=1;}_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId,1);}",
    "{require(isOwnerOf(from,tokenId),\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_tokens[tokenId].owner=uint160(to);emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);}",
    "{require(from!=address(0),\"ERC20:transferfromthezeroaddress\");require(to!=address(0),\"ERC20:transfertothezeroaddress\");_beforeTokenTransfer(from,to,amount);uint256fromBalance=_balances[from];require(fromBalance>=amount,\"ERC20:transferamountexceedsbalance\");unchecked{_balances[from]=fromBalance-amount;}_balances[to]+=amount;emitTransfer(from,to,amount);_afterTokenTransfer(from,to,amount);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");//internalownerrequire(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);",
    "{require(ERC721.ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");//internalownerrequire(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);}",
    "{require(ownerOf(tokenId)==from,\"ERC721:transferoftokenthatisnotown\");require(to!=address(0),\"ERC721:transfertothezeroaddress\");_beforeTokenTransfer(from,to,tokenId);//Clearapprovalsfromthepreviousowner_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"\");require(to!=address(0),\"\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"\");require(to!=address(0),\"\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_holderTokens[from].remove(tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(from,to,tokenId);}",
    "{require(ERC721.ownerOf(tokenId)==from,\"\");require(to!=address(0),\"\");_beforeTokenTransfer(from,to,tokenId);_approve(address(0),tokenId);_balances[from]-=1;_balances[to]+=1;_owners[tokenId]=to;emitTransfer(from,to,tokenId);_afterTokenTransfer(from,to,tokenId);}"
  ],
  "_beforeTokenTransfer": [
    "{if(from==address(0)){_addTokenToAllTokensEnumeration(tokenId);}elseif(from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to==address(0)){_removeTokenFromAllTokensEnumeration(tokenId);}elseif(to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{}",
    "{\\rsuper._beforeTokenTransfer(from,to,tokenId);\\r\\rif(from==address(0)){\\r_addTokenToAllTokensEnumeration(tokenId);\\r}elseif(from!=to){\\r_removeTokenFromOwnerEnumeration(from,tokenId);\\r}\\rif(to==address(0)){\\r_removeTokenFromAllTokensEnumeration(tokenId);\\r}elseif(to!=from){\\r_addTokenToOwnerEnumeration(to,tokenId);\\r}\\r}",
    "{super._beforeTokenTransfer(_from,_to,_tokenId);}",
    "{\\rif(beforeTokenTransferHandler!=address(0)){\\rIERC721BeforeTokenTransferHandlerhandlerRef=IERC721BeforeTokenTransferHandler(\\rbeforeTokenTransferHandler\\r);\\rhandlerRef.beforeTokenTransfer(\\raddress(this),\\r_msgSender(),\\rfrom,\\rto,\\rfirstTokenId,\\rbatchSize\\r);\\r}\\r\\rfor(uint256idx=0;idx<batchSize;idx++){\\ruint256tokenId=firstTokenId+idx;\\ruint32lastTransferTime=lastTransfer[tokenId];\\ruint32currentTime=SafeCast.toUint32(block.timestamp);\\rif(lastTransferTime>0){\\r_timeHeld[tokenId][from]+=(currentTime-lastTransferTime);\\r}\\rlastTransfer[tokenId]=currentTime;\\r}\\r\\rsuper._beforeTokenTransfer(from,to,firstTokenId,batchSize);\\r}",
    "{super._beforeTokenTransfer(from,to,tokenId);if(tradingPaused)require(from==address(0),\"Thetradingofthistokenispausedatthemoment\");}",
    "{\rif(isTokenRented(tokenId)){\rrequire(super.isApprovedOperatorRole(_msgSender()),\"Transferofrentedtokenallowedonlybytheapprovedoperatorrole\");\r}\rsuper._beforeTokenTransfer(from,to,tokenId);\r}",
    " {\\rif(beforeTokenTransferHandler!=address(0)){\\rIERC1155BeforeTokenTransferHandlerhandlerRef=IERC1155BeforeTokenTransferHandler(\\rbeforeTokenTransferHandler\\r);\\rhandlerRef.beforeTokenTransfer(\\raddress(this),\\roperator,\\rfrom,\\rto,\\rids,\\ramounts,\\rdata\\r);\\r}\\r\\rsuper._beforeTokenTransfer(operator,from,to,ids,amounts,data);\\r}",
    "{if(rentedTokensLandlords[tokenId]!=address(0)){require(super.isApprovedOperatorRole(_msgSender()),\"Transferofrentedtokenallowedonlybytheapprovedoperatorrole\");}super._beforeTokenTransfer(from,to,tokenId);}",
    "{uint256[]storagesenderTokenList=allTokens[from];for(uint256i;i<ids.length;i++){//addtransferredtokento'to'usertokenlistallTokens[to].push(ids[i]);//findandremovethetransferredtokenfromthe'from'usertokenlist//thecodebelowfindsthetokenid,movesthelasttokentofoundindex//anddecreasesthearraylength.So,theallTokensisanunorderedarrayoftokens.for(uint256j;j<senderTokenList.length;j++){if(senderTokenList[j]==ids[i]){senderTokenList[j]=senderTokenList[senderTokenList.length-1];senderTokenList.pop();}}}}",
    "{if(beforeTokenTransferHandler!=address(0)){IERC721BeforeTokenTransferHandlerhandlerRef=IERC721BeforeTokenTransferHandler(beforeTokenTransferHandler);handlerRef.beforeTokenTransfer(address(this),_msgSender(),from,to,firstTokenId,batchSize);}for(uint256idx=0;idx<batchSize;idx++){uint256tokenId=firstTokenId+idx;uint32lastTransferTime=lastTransfer[tokenId];uint32currentTime=SafeCast.toUint32(block.timestamp);if(lastTransferTime>0){_timeHeld[tokenId][from]+=(currentTime-lastTransferTime);}lastTransfer[tokenId]=currentTime;}super._beforeTokenTransfer(from,to,firstTokenId,batchSize);}",
    "{super._beforeTokenTransfer(from,to,firstTokenId,batchSize);if(batchSize>1){revert(\"ERC721Enumerable:consecutivetransfersnotsupported\");}uint256tokenId=firstTokenId;if(from==address(0)){_addTokenToAllTokensEnumeration(tokenId);}elseif(from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to==address(0)){_removeTokenFromAllTokensEnumeration(tokenId);}elseif(to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{require(!frozenAccount[from],\"frozenaccount\");require(!frozenToken[tokenId],\"frozentoken\");super._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,amount);}",
    "{super._beforeTokenTransfer(from,to,tokenId);if(from!=address(0)&&from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to!=address(0)&&to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{super._beforeTokenTransfer(operator,from,to,nftIds,amounts,data);}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);for(uint256i=0;i<ids.length;i++){if(from!=address(0)&&balanceOf(from,ids[i])<=amounts[i])_ownedTokens[from].remove(ids[i]);if(to!=address(0)&&balanceOf(to,ids[i])==0)_ownedTokens[to].add(ids[i]);}_players.add(from);_players.add(to);}",
    "{require(whitelisted[from],\"!fromnotwhitelisted\");require(whitelisted[to],\"!tonotwhitelisted\");super._beforeTokenTransfer(operator,from,to,ids,amounts,data);}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);if(from==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]+=amounts[i];}}if(to==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]-=amounts[i];}}}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);if(from==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]+=amounts[i];}}if(to==address(0)){for(uint256i=0;i<ids.length;++i){uint256id=ids[i];uint256amount=amounts[i];uint256supply=_totalSupply[id];require(supply>=amount,\"ERC1155:burnamountexceedstotalSupply\");unchecked{_totalSupply[id]=supply-amount;}}}}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);}",
    "{\\rsuper._beforeTokenTransfer(operator,from,to,ids,amounts,data);\\r}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);require(!paused(),\"ERC1155Pausable:tokentransferwhilepaused\");}",
    "{}",
    "{super._beforeTokenTransfer(from,to,tokenId);}",
    "{if(batchSize>1){if(from!=address(0)){_balances[from]-=batchSize;}if(to!=address(0)){_balances[to]+=batchSize;}}}",
    "{ERC721Enumerable._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,tokenId);if(from==address(0)){_addTokenToAllTokensEnumeration(tokenId);}elseif(from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to==address(0)){_removeTokenFromAllTokensEnumeration(tokenId);}elseif(to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{super._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,tokenId);require(!paused(),\"ERC721Pausable:tokentransferwhilepaused\");}"
  ],
  "_beforeTokenTransfers": [
    "{}",
    "{\\rif(isTokenRented(tokenId)){\\rrequire(super.isApprovedOperatorRole(_msgSender()),\"Transferofrentedtokenallowedonlybytheapprovedoperatorrole\");\\r}\\rsuper._beforeTokenTransfer(from,to,tokenId);\\r}",
    "{\\rif(isTokenRented(tokenId)){\\rrequire(super.isApprovedOperatorRole(_msgSender()),\"Transferofrentedtokenallowedonlybytheapprovedoperatorrole\");\\r}\\rsuper._beforeTokenTransfer(from,to,tokenId);\\r}",
    "{require(!frozenAccount[from],\"frozenaccount\");require(!frozenToken[tokenId],\"frozentoken\");super._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,amount);}",
    "{super._beforeTokenTransfer(from,to,tokenId);if(from!=address(0)&&from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to!=address(0)&&to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{super._beforeTokenTransfer(operator,from,to,nftIds,amounts,data);}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);for(uint256i=0;i<ids.length;i++){if(from!=address(0)&&balanceOf(from,ids[i])<=amounts[i])_ownedTokens[from].remove(ids[i]);if(to!=address(0)&&balanceOf(to,ids[i])==0)_ownedTokens[to].add(ids[i]);}_players.add(from);_players.add(to);}",
    "{require(whitelisted[from],\"!fromnotwhitelisted\");require(whitelisted[to],\"!tonotwhitelisted\");super._beforeTokenTransfer(operator,from,to,ids,amounts,data);}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);if(from==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]+=amounts[i];}}if(to==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]-=amounts[i];}}}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);if(from==address(0)){for(uint256i=0;i<ids.length;++i){_totalSupply[ids[i]]+=amounts[i];}}if(to==address(0)){for(uint256i=0;i<ids.length;++i){uint256id=ids[i];uint256amount=amounts[i];uint256supply=_totalSupply[id];require(supply>=amount,\"ERC1155:burnamountexceedstotalSupply\");unchecked{_totalSupply[id]=supply-amount;}}}}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);}",
    "{\\rsuper._beforeTokenTransfer(operator,from,to,ids,amounts,data);\\r}",
    "{super._beforeTokenTransfer(operator,from,to,ids,amounts,data);require(!paused(),\"ERC1155Pausable:tokentransferwhilepaused\");}",
    "{}",
    "{super._beforeTokenTransfer(from,to,tokenId);}",
    "{if(batchSize>1){if(from!=address(0)){_balances[from]-=batchSize;}if(to!=address(0)){_balances[to]+=batchSize;}}}",
    "{ERC721Enumerable._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,tokenId);if(from==address(0)){_addTokenToAllTokensEnumeration(tokenId);}elseif(from!=to){_removeTokenFromOwnerEnumeration(from,tokenId);}if(to==address(0)){_removeTokenFromAllTokensEnumeration(tokenId);}elseif(to!=from){_addTokenToOwnerEnumeration(to,tokenId);}}",
    "{super._beforeTokenTransfer(from,to,tokenId);}",
    "{super._beforeTokenTransfer(from,to,tokenId);require(!paused(),\"ERC721Pausable:tokentransferwhilepaused\");}"
  ],
  "_nextExtraData": [
    "{uint24extraData=uint24(prevOwnershipPacked\\u003e\\u003e_BITPOS_EXTRA_DATA);returnuint256(_extraData(from,to,extraData))\\u003c\\u003c_BITPOS_EXTRA_DATA;}",
    "{uint24extraData=uint24(prevOwnershipPacked>>_BITPOS_EXTRA_DATA);returnuint256(_extraData(from,to,extraData))<<_BITPOS_EXTRA_DATA;}"
  ],
  "_getApprovedSlotAndAddress": [
    "{TokenApprovalRefstoragetokenApproval=_tokenApprovals[tokenId];assembly{approvedAddressSlot:=tokenApproval.slotapprovedAddress:=sload(approvedAddressSlot)}}"
  ],
  "_packOwnershipData": [
    "{assembly{owner:=and(owner,_BITMASK_ADDRESS)result:=or(owner,or(shl(_BITPOS_START_TIMESTAMP,timestamp()),flags))}}",
    "{}"
  ],
  "_mintIfNotExist": [
    "{if(msg.sender==_admin){if(!_exists(tokenId)){_mint(_admin,tokenId);}}}",
    "{}"
  ],
  "hookrequire": ["{}"],
  "_baseURI": [
    "{returnbaseURI;}",
    "{}",
    "{_pause();}",
    "{return\"\";}",
    "{return'';}"
  ],
  "unsetPause": ["{}", "{_unpause();}"],
  "setPause": ["{}", "{return\"\";}", "{_pause();}"],
  "tokenURI": [
    "{}",
    "{string[17]memoryparts;parts[0]='<svgxmlns=\"http:parts[1]=getWeapon(tokenId);parts[2]='</text><textx=\"10\"y=\"40\"class=\"base\">';parts[3]=getChest(tokenId);parts[4]='</text><textx=\"10\"y=\"60\"class=\"base\">';parts[5]=getHead(tokenId);parts[6]='</text><textx=\"10\"y=\"80\"class=\"base\">';parts[7]=getWaist(tokenId);parts[8]='</text><textx=\"10\"y=\"100\"class=\"base\">';parts[9]=getFoot(tokenId);parts[10]='</text><textx=\"10\"y=\"120\"class=\"base\">';parts[11]=getHand(tokenId);parts[12]='</text><textx=\"10\"y=\"140\"class=\"base\">';parts[13]=getNeck(tokenId);parts[14]='</text><textx=\"10\"y=\"160\"class=\"base\">';parts[15]=getRing(tokenId);parts[16]='</text></svg>';stringmemoryoutput=string(abi.encodePacked(parts[0],parts[1],parts[2],parts[3],parts[4],parts[5],parts[6],parts[7],parts[8]));output=string(abi.encodePacked(output,parts[9],parts[10],parts[11],parts[12],parts[13],parts[14],parts[15],parts[16]));stringmemoryjson=Base64.encode(bytes(string(abi.encodePacked('{\"name\":\"Bag#',toString(tokenId),'\",\"description\":\"MoreLootisadditionalrandomizedadventurergeargeneratedandstoredonchain.Maximumsupplyisdynamic,increasingat1/10thofEthereum\\'sblockrate.Stats,images,andotherfunctionalityareintentionallyomittedforotherstointerpret.FeelfreetouseMoreLootinanywayyouwant.\",\"image\":\"data:image/svg+xml;base64,',Base64.encode(bytes(output)),'\"}'))));output=string(abi.encodePacked('data:application/json;base64,',json));returnoutput;}",
    "{require(_exists(tokenId),\"ERC721Metadata:URIqueryfornonexistenttoken\");stringmemorycurrentBaseURI=_baseURI();returnbytes(currentBaseURI).length>0?string(abi.encodePacked(currentBaseURI,tokenId.toString(),baseExtension)):\"\";}",
    "{require(_exists(tokenId),\"ERC721Metadata:URIqueryfornonexistenttoken\");stringmemorybaseURI=_baseURI();returnbytes(baseURI).length>0?string(abi.encodePacked(baseURI,tokenId.toString())):'';}",
    "{if(!_exists(tokenId))revertURIQueryForNonexistentToken();stringmemorybaseURI=_baseURI();returnbytes(baseURI).length!=0?string(abi.encodePacked(baseURI,tokenId.toString())):'';}",
    "{require(_exists(tokenId),\"\");stringmemory_tokenURI=_tokenURIs[tokenId];stringmemorybase=baseURI();if(bytes(base).length==0){return_tokenURI;}if(bytes(_tokenURI).length>0){returnstring(abi.encodePacked(base,_tokenURI));}returnstring(abi.encodePacked(base,tokenId.toString()));}",
    "{returnidToUri[_tokenId];}",
    "{require(_exists(tokenId),\"\");stringmemorybaseURI=_baseURI();returnbytes(baseURI).length>0?string(abi.encodePacked(baseURI,tokenId.toString())):\"\";}"
  ],
  "MintToZeroAddress": ["{}"],
  "MintZeroQuantity": ["{}"],
  "_mint": [
    "{require(to!=address(0),\"ERC1155:minttothezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,address(0),to,_asSingletonArray(id),_asSingletonArray(amount),data);_balances[id][to]+=amount;emitTransferSingle(operator,address(0),to,id,amount);_doSafeTransferAcceptanceCheck(operator,address(0),to,id,amount,data);}",
    "{require(to!=address(0),\"INVALID_RECIPIENT\");require(ownerOf[id]==address(0),\"ALREADY_MINTED\");//Counteroverflowisincrediblyunrealistic.unchecked{balanceOf[to]++;}ownerOf[id]=to;emitTransfer(address(0),to,id);}",
    "{require(to!=address(0));require(!_exists(tokenId));_tokenOwner[tokenId]=to;_ownedTokensCount[to]=_ownedTokensCount[to].add(1);emitTransfer(address(0),to,tokenId);}",
    "{uint256startTokenId=_currentIndex;if(to==address(0))revertMintToZeroAddress();if(quantity==0)revertMintZeroQuantity();_beforeTokenTransfers(address(0),to,startTokenId,quantity);unchecked{_addressData[to].balance+=uint64(quantity);_addressData[to].numberMinted+=uint64(quantity);_ownerships[startTokenId].addr=to;_ownerships[startTokenId].startTimestamp=uint64(block.timestamp);uint256updatedIndex=startTokenId;for(uint256i;i<quantity;i++){emitTransfer(address(0),to,updatedIndex);if(safe&&!_checkOnERC721Received(address(0),to,updatedIndex,_data)){revertTransferToNonERC721ReceiverImplementer();}updatedIndex++;}_currentIndex=updatedIndex;}_afterTokenTransfers(address(0),to,startTokenId,quantity);}",
    "{require(to!=address(0),\"ERC721:minttothezeroaddress\");require(!_exists(tokenId),\"ERC721:tokenalreadyminted\");_beforeTokenTransfer(address(0),to,tokenId,1);//CheckthattokenIdwasnotmintedby`_beforeTokenTransfer`hookrequire(!_exists(tokenId),\"ERC721:tokenalreadyminted\");unchecked{//Willnotoverflowunlessall2**256tokenidsaremintedtothesameowner.//Giventhattokensaremintedonebyone,itisimpossibleinpracticethat//thiseverhappens.Mightchangeifweallowbatchminting.//TheERCfailstodescribethiscase._balances[to]+=1;}_owners[tokenId]=to;emitTransfer(address(0),to,tokenId);_afterTokenTransfer(address(0),to,tokenId,1);}",
    "{require(to!=address(0),\"ERC721:minttothezeroaddress\");require(!_exists(tokenId),\"ERC721:tokenalreadyminted\");_beforeTokenTransfer(address(0),to,tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(address(0),to,tokenId);}",
    "{require(to!=address(0),\"ERC721:minttothezeroaddress\");require(!_exists(tokenId),\"ERC721:tokenalreadyminted\");_beforeTokenTransfer(address(0),to,tokenId);_balances[to]+=1;_owners[tokenId]=to;emitTransfer(address(0),to,tokenId);}",
    "{require(to!=address(0),\"\");require(!_exists(tokenId),\"\");_beforeTokenTransfer(address(0),to,tokenId);_balances[to]+=1;_owners[tokenId]=to;emitTransfer(address(0),to,tokenId);}",
    "{require(to!=address(0),\"\");require(!_exists(tokenId),\"\");_beforeTokenTransfer(address(0),to,tokenId);_holderTokens[to].add(tokenId);_tokenOwners.set(tokenId,to);emitTransfer(address(0),to,tokenId);}",
    "{super._mint(_to,_tokenId);tokens.push(_tokenId);idToIndex[_tokenId]=tokens.length-1;}",
    "{require(to!=address(0),\"\");require(!_exists(tokenId),\"\");_beforeTokenTransfer(address(0),to,tokenId);_balances[to]+=1;_owners[tokenId]=to;emitTransfer(address(0),to,tokenId);_afterTokenTransfer(address(0),to,tokenId);}"
  ],
  "transferFrom": [
    "{require(from==ownerOf[id],\"WRONG_FROM\");require(to!=address(0),\"INVALID_RECIPIENT\");require(msg.sender==from||msg.sender==getApproved[id]||isApprovedForAll[from][msg.sender],\"NOT_AUTHORIZED\");//Underflowofthesender'sbalanceisimpossiblebecausewecheckfor//ownershipaboveandtherecipient'sbalancecan'trealisticallyoverflow.unchecked{balanceOf[from]--;balanceOf[to]++;}ownerOf[id]=to;deletegetApproved[id];emitTransfer(from,to,id);}",
    "{if(_msgSender()!=address(barn))require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_transfer(from,to,tokenId);}",
    "{require(_isApprovedOrOwner(msg.sender,tokenId));_transferFrom(from,to,tokenId);}",
    "{//Safetychecktopreventagainstanunexpected0x0default.require(_to!=address(0));//Disallowtransferstothiscontracttopreventaccidentalmisuse.//Thecontractshouldneverownanykitties(exceptverybriefly//afteragen0catiscreatedandbeforeitgoesonauction).require(_to!=address(this));//Checkforapprovalandvalidownershiprequire(_approvedFor(msg.sender,_tokenId));require(_owns(_from,_tokenId));//Reassignownership(alsoclearspendingapprovalsandemitsTransferevent)._transfer(_from,_to,_tokenId);}",
    "{//Pretransferchecks.addressoperator=_msgSender();require(!paused(),\"Error:tokentransferwhilepaused\");_transfer(from,to,operator,id);}",
    "{//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownerorapproved\");_transfer(from,to,tokenId);}",
    "{_mintIfNotExist(tokenId);require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_transfer(from,to,tokenId);}",
    "{_transferFrom(_from,_to,_tokenId,msg.sender);}",
    "{ERC721.transferFrom(from,to,tokenId);}",
    "{//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),'ERC721:transfercallerisnotownernorapproved');_transfer(from,to,tokenId);}",
    "{require(to!=address(this),\"Recipientcannotbetheaddressofthecontract\");super.transferFrom(from,to,tokenId);rentedTokensLandlords[tokenId]=address(0);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownerorapproved\");_transfer(from,to,tokenId);}",
    "{//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(msg.sender,tokenId),\"ERC721:transfercallerisnotownernorapproved\");_transferFrom(from,to,tokenId);}",
    "{uint256prevOwnershipPacked=_packedOwnershipOf(tokenId);if(address(uint160(prevOwnershipPacked))!=from)revertTransferFromIncorrectOwner();(uint256approvedAddressSlot,addressapprovedAddress)=_getApprovedSlotAndAddress(tokenId);if(!_isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A()))if(!isApprovedForAll(from,_msgSenderERC721A()))revertTransferCallerNotOwnerNorApproved();if(to==address(0))revertTransferToZeroAddress();_beforeTokenTransfers(from,to,tokenId,1);assembly{ifapprovedAddress{sstore(approvedAddressSlot,0)}}unchecked{--_packedAddressData[from];++_packedAddressData[to];_packedOwnerships[tokenId]=_packOwnershipData(to,_BITMASK_NEXT_INITIALIZED|_nextExtraData(from,to,prevOwnershipPacked));if(prevOwnershipPacked\\u0026_BITMASK_NEXT_INITIALIZED==0){uint256nextTokenId=tokenId+1;if(_packedOwnerships[nextTokenId]==0){if(nextTokenId!=_currentIndex){_packedOwnerships[nextTokenId]=prevOwnershipPacked;}}}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{\\rsuper.transferFrom(from,to,tokenId);\\r}",
    "{\\rrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");\\r\\r_transfer(from,to,tokenId);\\r}",
    "{addresstokenOwner=idToOwner[_tokenId];require(tokenOwner==_from,\"Wrongfromaddress.\");require(_to!=address(0),\"Cannotsendto0x0.\");_transfer(_to,_tokenId);}",
    "{_transfer(from,to,tokenId);}",
    "{uint256prevOwnershipPacked=_packedOwnershipOf(tokenId);if(address(uint160(prevOwnershipPacked))!=from)revertTransferFromIncorrectOwner();(uint256approvedAddressSlot,addressapprovedAddress)=_getApprovedSlotAndAddress(tokenId);if(!_isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A()))if(!isApprovedForAll(from,_msgSenderERC721A()))revertTransferCallerNotOwnerNorApproved();if(to==address(0))revertTransferToZeroAddress();_beforeTokenTransfers(from,to,tokenId,1);assembly{ifapprovedAddress{sstore(approvedAddressSlot,0)}}unchecked{--_packedAddressData[from];++_packedAddressData[to];_packedOwnerships[tokenId]=_packOwnershipData(to,_BITMASK_NEXT_INITIALIZED|_nextExtraData(from,to,prevOwnershipPacked));if(prevOwnershipPacked&_BITMASK_NEXT_INITIALIZED==0){uint256nextTokenId=tokenId+1;if(_packedOwnerships[nextTokenId]==0){if(nextTokenId!=_currentIndex){_packedOwnerships[nextTokenId]=prevOwnershipPacked;}}}}emitTransfer(from,to,tokenId);_afterTokenTransfers(from,to,tokenId,1);}",
    "{super.transferFrom(from,to,tokenId);}",
    "{require(CanTransfer,\"YouneedTransferToken\");if(!_exists(tokenId))revertOwnerQueryForNonexistentToken();if(ownerOf(tokenId)!=from)revertTransferFromIncorrectOwner();if(to==address(0))revertTransferToZeroAddress();boolisApprovedOrOwner=(msg.sender==from||msg.sender==getApproved(tokenId)||isApprovedForAll(from,msg.sender));if(!isApprovedOrOwner)revertTransferCallerNotOwnerNorApproved();//deletetokenapprovalsfrompreviousownerdelete_tokenApprovals[tokenId];_owners[tokenId]=to;//iftokenIDbelowtransferredoneisntset,setittopreviousowner//iftokenidiszero,skipthistopreventunderflowif(tokenId>0&&_owners[tokenId-1]==address(0)){_owners[tokenId-1]=from;}emitTransfer(from,to,tokenId);}",
    "{_transfer(sender,recipient,amount);uint256currentAllowance=_allowances[sender][_msgSender()];require(currentAllowance>=amount,\"ERC20:transferamountexceedsallowance\");unchecked{_approve(sender,_msgSender(),currentAllowance-amount);}returntrue;}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_transfer(from,to,tokenId);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownernorapproved\");_transfer(from,to,tokenId);}",
    "{require(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownernorapproved\");_transfer(from,to,tokenId);}",
    "{//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:callerisnottokenownernorapproved\");_transfer(from,to,tokenId);}",
    "{//solhint-disable-next-linemax-line-lengthrequire(_isApprovedOrOwner(_msgSender(),tokenId),\"ERC721:transfercallerisnotownernorapproved\");_transfer(from,to,tokenId);}",
    "{addressspender=_msgSender();_spendAllowance(from,spender,amount);_transfer(from,to,amount);returntrue;}",
    "{\\rrequire(to!=address(this),\"Recipientcannotbetheaddressofthecontract\");\\rsuper.transferFrom(from,to,tokenId);\\rrentedTokensLandlords[tokenId]=address(0);\\r}",
    "{require(to!=address(0),\"ERC721:transfertoaddress(0)\");uint256owner=s.owners[tokenId];require(_tokenExists(owner),\"ERC721:non-existingtoken\");require(_tokenOwner(owner)==from,\"ERC721:non-ownedtoken\");if(!_isOperatable(s,from,sender)){require(_tokenHasApproval(owner)&&sender==s.approvals[tokenId],\"ERC721:non-approvedsender\");}s.owners[tokenId]=uint256(uint160(to));if(from!=to){unchecked{--s.balances[from];++s.balances[to];}}emitTransfer(from,to,tokenId);}",
    "{require(_isApprovedOrOwner(_msgSender(),\"\"),\"ERC721:transfercallerisnotownernorapproved\");_transfer(from,to,tokenId);}",
    "{addresstokenOwner=idToOwner[_tokenId];require(tokenOwner==_from,\"\");require(_to!=address(0),\"\");_transfer(_to,_tokenId);}"
  ],
  "_packedOwnershipOf": [
    "{uint256curr=tokenId;unchecked{if(_startTokenId()<=curr)if(curr<_currentIndex){uint256packed=_packedOwnerships[curr];//Ifnotburned.if(packed&_BITMASK_BURNED==0){//Invariant://Therewillalwaysbeaninitializedownershipslot//(i.e.`ownership.addr!=address(0)&&ownership.burned==false`)//beforeanunintializedownershipslot//(i.e.`ownership.addr==address(0)&&ownership.burned==false`)//Hence,`curr`willnotunderflow.////Wecandirectlycomparethepackedvalue.//Iftheaddressiszero,packedwillbezero.while(packed==0){packed=_packedOwnerships[--curr];}returnpacked;}}}revertOwnerQueryForNonexistentToken();}",
    "{}",
    "{uint256curr=tokenId;unchecked{if(_startTokenId()\\u003c=curr)if(curr\\u003c_currentIndex){uint256packed=_packedOwnerships[curr];if(packed\\u0026_BITMASK_BURNED==0){while(packed==0){packed=_packedOwnerships[--curr];}returnpacked;}}}revertOwnerQueryForNonexistentToken();}",
    "{if(_startTokenId()<=tokenId){packed=_packedOwnerships[tokenId];if(packed&_BITMASK_BURNED==0){if(packed==0){if(tokenId>=_currentIndex)_revert(OwnerQueryForNonexistentToken.selector);for(;;){unchecked{packed=_packedOwnerships[--tokenId];}if(packed==0)continue;returnpacked;}}returnpacked;}}_revert(OwnerQueryForNonexistentToken.selector);}",
    "{uint256curr=tokenId;unchecked{if(_startTokenId()<=curr)if(curr<_currentIndex){uint256packed=_packedOwnerships[curr];if(packed&_BITMASK_BURNED==0){while(packed==0){packed=_packedOwnerships[--curr];}returnpacked;}}}revertOwnerQueryForNonexistentToken();}"
  ],
  "OwnerQueryForNonexistentToken": ["{}", ""],
  "skipthistopreventunderflowif": ["{}", ""],
  "_ownershipOf": [
    "{return_unpackedOwnership(_packedOwnershipOf(tokenId));}",
    "{}",
    "",
    "{uint256curr=tokenId;unchecked{if(_startTokenId()<=curr&&curr<_currentIndex){TokenOwnershipmemoryownership=_ownerships[curr];if(!ownership.burned){if(ownership.addr!=address(0)){returnownership;}while(true){curr--;ownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}}}}revertOwnerQueryForNonexistentToken();}"
  ],
  "TransferFromIncorrectOwner": ["{}", ""],
  "TransferToZeroAddress": ["{}", ""],
  "isContract": [
    "{uint256size;//XXXCurrentlythereisnobetterwaytocheckifthereisacontractinanaddress//thantocheckthesizeofthecodeatthataddress.//Seehttps://ethereum.stackexchange.com/a/14016/36603//formoredetailsabouthowthisworks.//TODOCheckthisagainbeforetheSerenityrelease,becausealladdresseswillbe//contractsthen.//solhint-disable-next-lineno-inline-assemblyassembly{size:=extcodesize(account)}returnsize>0;}",
    "{\\r\\ruint256size;\\rassembly{size:=extcodesize(account)}\\rreturnsize>0;\\r}",
    "{\\r\\rreturnaccount.code.length\\u003e0;\\r}",
    "{\\r\\ruint256size;\\rassembly{\\rsize:=extcodesize(account)\\r}\\rreturnsize>0;\\r}",
    "{//Thismethodreliesinextcodesize,whichreturns0forcontractsin//construction,sincethecodeisonlystoredattheendofthe//constructorexecution.uint256size;//solhint-disable-next-lineno-inline-assemblyassembly{size:=extcodesize(account)}returnsize>0;}",
    "{uint256size;assembly{size:=extcodesize(_addr)}//solhint-disable-lineaddressCheck=size>0;}",
    "{bytes32codehash;//Currentlythereisnobetterwaytocheckifthereisacontractinanaddress//thantocheckthesizeofthecodeatthataddressorifithasanon-zerocodehashoraccounthashassembly{codehash:=extcodehash(_address)}return(codehash!=0x0&&codehash!=ACCOUNT_HASH);}",
    "{uint256size;assembly{size:=extcodesize(account)}returnsize>0;}",
    "{returnaccount.code.length>0;}",
    "{//Thismethodreliesonextcodesize/address.code.length,whichreturns0//forcontractsinconstruction,sincethecodeisonlystoredattheend//oftheconstructorexecution.returnaccount.code.length>0;}",
    "{//Thismethodreliesonextcodesize,whichreturns0forcontractsin//construction,sincethecodeisonlystoredattheendofthe//constructorexecution.uint256size;assembly{size:=extcodesize(account)}returnsize>0;}",
    "{//Thismethodreliesonextcodesize,whichreturns0forcontractsin//construction,sincethecodeisonlystoredattheendofthe//constructorexecution.uint256size;//solhint-disable-next-lineno-inline-assemblyassembly{size:=extcodesize(account)}returnsize>0;}",
    "{\\t\\t\\t\\tuint256size=0;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tassembly{\\t\\t\\t\\t\\t\\tsize:=extcodesize(addr)\\t\\t}\\t\\t\\t\\treturnsize>0;\\t}",
    "{uint256size;assembly{size:=extcodesize(account)}returnsize\\u003e0;}",
    "{bytes32codehash;bytes32accountHash=0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;assembly{codehash:=extcodehash(_addr)}addressCheck=(codehash!=0x0&&codehash!=accountHash);}"
  ],
  "_requireMinted": ["{require(_exists(tokenId),\"ERC721:invalidtokenID\");}"],
  "getNumMinted": ["{return_tokens.length-1;}", "{return_starCount;}"],
  "isOwnerOf": ["", "{}", "{addressowner=ownerOf(id);returnowner==account;}"],
  "paused": [
    "{\\rreturn_paused||_gameRegistry.paused();\\r}",
    "{return_paused||_gameRegistry.paused();}",
    "{}",
    "{return_paused;}",
    "{\\rfor(uint256id;id<items.length;id++){\\ritems[id].isPaused=_isPaused;\\r}\\r}"
  ],
  "_addTokenToAllTokensEnumeration": [
    "{\\r_allTokensIndex[tokenId]=_allTokens.length;\\r_allTokens.push(tokenId);\\r}",
    "{_allTokensIndex[tokenId]=_allTokens.length;_allTokens.push(tokenId);}",
    "{}"
  ],
  "_removeTokenFromOwnerEnumeration": [
    "{//Topreventagapinfrom'stokensarray,westorethelasttokenintheindexofthetokentodelete,and//thendeletethelastslot(swapandpop).uint256lastTokenIndex=balanceOf(from)-1;uint256tokenIndex=_ownedTokensIndex[tokenId];//Whenthetokentodeleteisthelasttoken,theswapoperationisunnecessaryif(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;//Movethelasttokentotheslotoftheto-deletetoken_ownedTokensIndex[lastTokenId]=tokenIndex;//Updatethemovedtoken'sindex}//Thisalsodeletesthecontentsatthelastpositionofthearraydelete_ownedTokensIndex[tokenId];delete_ownedTokens[from][lastTokenIndex];}",
    "{uint256lastTokenIndex=BRC721.balanceOf(from)-1;uint256tokenIndex=_ownedTokensIndex[tokenId];if(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}delete_ownedTokensIndex[tokenId];delete_ownedTokens[from][lastTokenIndex];}",
    "{\\r\\ruint256lastTokenIndex=ERC721.balanceOf(from)-1;\\ruint256tokenIndex=_ownedTokensIndex[tokenId];\\r\\rif(tokenIndex!=lastTokenIndex){\\ruint256lastTokenId=_ownedTokens[from][lastTokenIndex];\\r\\r_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}\\r\\rdelete_ownedTokensIndex[tokenId];\\rdelete_ownedTokens[from][lastTokenIndex];\\r}",
    "{\\r\\ruint256lastTokenIndex=ERC721.balanceOf(from)-1;\\ruint256tokenIndex=_ownedTokensIndex[tokenId];\\r\\rif(tokenIndex!=lastTokenIndex){\\ruint256lastTokenId=_ownedTokens[from][lastTokenIndex];\\r\\r_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}\\r\\rdelete_ownedTokensIndex[tokenId];\\rdelete_ownedTokens[from][lastTokenIndex];\r}",
    "{//Topreventagapinfrom'stokensarray,westorethelasttokenintheindexofthetokentodelete,and//thendeletethelastslot(swapandpop).uint256lastTokenIndex=_ownedTokens[from].length.sub(1);uint256tokenIndex=_ownedTokensIndex[tokenId];//Whenthetokentodeleteisthelasttoken,theswapoperationisunnecessaryif(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;//Movethelasttokentotheslotoftheto-deletetoken_ownedTokensIndex[lastTokenId]=tokenIndex;//Updatethemovedtoken'sindex}//Thisalsodeletesthecontentsatthelastpositionofthearray_ownedTokens[from].length--;//Notethat_ownedTokensIndex[tokenId]hasn'tbeencleared:itstillpointstotheoldslot(nowoccupiedby//lastTokenId,orjustovertheendofthearrayifthetokenwasthelastone).}",
    "{//Topreventagapinfrom'stokensarray,westorethelasttokenintheindexofthetokentodelete,and//thendeletethelastslot(swapandpop).uint256lastTokenIndex=ERC721.balanceOf(from)-1;uint256tokenIndex=_ownedTokensIndex[tokenId];//Whenthetokentodeleteisthelasttoken,theswapoperationisunnecessaryif(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;//Movethelasttokentotheslotoftheto-deletetoken_ownedTokensIndex[lastTokenId]=tokenIndex;//Updatethemovedtoken'sindex}//Thisalsodeletesthecontentsatthelastpositionofthearraydelete_ownedTokensIndex[tokenId];delete_ownedTokens[from][lastTokenIndex];}",
    "{uint256lastTokenIndex=balanceOf(from)-1;uint256tokenIndex=_ownedTokensIndex[tokenId];if(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}delete_ownedTokensIndex[tokenId];delete_ownedTokens[from][lastTokenIndex];}",
    "{uint256lastTokenIndex=ERC721.balanceOf(from)-1;uint256tokenIndex=_ownedTokensIndex[tokenId];if(tokenIndex!=lastTokenIndex){uint256lastTokenId=_ownedTokens[from][lastTokenIndex];_ownedTokens[from][tokenIndex]=lastTokenId;_ownedTokensIndex[lastTokenId]=tokenIndex;}delete_ownedTokensIndex[tokenId];delete_ownedTokens[from][lastTokenIndex];}",
    "{}"
  ],
  "addMinter": ["{_minters[minter]=true;emiteAddMinter(minter,block.number);}"],
  "removeMinter": [
    "{_minters[minter]=false;emiteRemoveMinter(minter,block.number);}"
  ],
  "setMetaType": ["{_metatype=metatype;}"],
  "setBaseURI": [
    "{baseURI=_newBaseURI;}",
    "{_baseUri=uri;}",
    "{_setBaseURI(baseURI);}",
    "{baseURI=uri;}"
  ],
  "mintedNumber": ["{return_numberMinted(addr);}"],
  "safeBatchTransferFrom": [
    "{for(uint256i=0;i<ids.length;++i){safeTransferFrom(from,to,ids[i],data);}emitTransferBatch(from,to,ids);}",
    "{require(from==_msgSender()||isApprovedForAll(from,_msgSender()),\"ERC1155:transfercallerisnotownernorapproved\");_safeBatchTransferFrom(from,to,ids,amounts,data);}"
  ],
  "getOwnershipOf": ["{return_ownerships[tokenId];}"],
  "mint": [
    "{uint256supply=totalSupply();require(!paused);require(_mintAmount>0);require(_mintAmount<=maxMintAmount);require(supply+_mintAmount<=maxSupply);if(msg.sender!=owner()){if(whitelisted[msg.sender]!=true){if(presaleWallets[msg.sender]!=true){//generalpublicrequire(msg.value>=cost*_mintAmount);}else{//presalerequire(msg.value>=presaleCost*_mintAmount);}}}for(uint256i=1;i<=_mintAmount;i++){_safeMint(_to,supply+i);}}",
    "{_mint(_to,_id,_amount,\"\");}",
    "{uint256tokenId=_currentIndex;ICartoon721.ExtraInfostoragesInfo=_extraInfo[_currentIndex];sInfo.mintRule=mintRule;sInfo.stakeErc20=stakeErc20;sInfo.stakeAmount=stakeAmount;sInfo.id=_currentIndex;_safeMint(to,1,\"\");returntokenId;}",
    "{super._mint(_to,_tokenId);super._setTokenUri(_tokenId,_uri);super._setTokenPayload(_tokenId,_payload);}"
  ],
  "burn": [
    "{_burn(msg.sender,_id,_amount);}",
    "{require(_isApprovedOrOwner(tokenId),\"callerisnotownernorapproved\");_burn(tokenId);}",
    "{super._burn(_tokenId);}"
  ],
  "tokensInfoByPage": [
    "{require(pageMax>0,\"invalidpagesize!\");uint256balance=_currentIndex;uint256maxCount=0;if(balance<=pageMax){maxCount=balance;}else{maxCount=pageMax;uint256pages=balance/pageMax;require(pages>=offset,\"invalidpagesize!\");if(pages==offset){maxCount=balance%pageMax;require(maxCount>0,\"invalidpagesize!\");}}infos=newICartoon721.ExtraInfo[](maxCount);uint256tokenId=0;for(uinti=0;i<maxCount;i++){tokenId=offset*pageMax+i;infos[i]=_extraInfo[tokenId];}}"
  ],
  "getExtraInfo": ["{return_extraInfo[tokenId];}"],
  "_numberMinted": [
    "{if(owner==address(0))revertMintedQueryForZeroAddress();returnuint256(_addressData[owner].numberMinted);}"
  ],
  "_numberBurned": [
    "{if(owner==address(0))revertBurnedQueryForZeroAddress();returnuint256(_addressData[owner].numberBurned);}"
  ],
  "_getAux": [
    "{if(owner==address(0))revertAuxQueryForZeroAddress();return_addressData[owner].aux;}"
  ],
  "_setAux": [
    "{if(owner==address(0))revertAuxQueryForZeroAddress();_addressData[owner].aux=aux;}"
  ],
  "owner": ["{return_owner;}"],
  "_checkOwner": [
    "{require(owner()==_msgSender(),\"Ownable:callerisnottheowner\");}"
  ],
  "renounceOwnership": [
    "{_setOwner(address(0));}",
    "{_transferOwnership(address(0));}",
    "{emitOwnershipTransferred(_owner,address(0));_owner=address(0);}"
  ],
  "transferOwnership": [
    "{require(newOwner!=address(0),\"Ownable:newowneristhezeroaddress\");_setOwner(newOwner);}",
    "{require(newOwner!=address(0),\"Ownable:newowneristhezeroaddress\");_transferOwnership(newOwner);}",
    "{require(newOwner!=address(0),\"\");_setOwner(newOwner);}",
    "{require(newOwner!=address(0),\"\");emitOwnershipTransferred(_owner,newOwner);_owner=newOwner;}",
    "{require(_newOwner!=address(0),\"\");emitOwnershipTransferred(owner,_newOwner);owner=_newOwner;}",
    "{require(newOwner!=address(0),\"\");_transferOwnership(newOwner);}"
  ],
  "_transferOwnership": [
    "{addressoldOwner=_owner;_owner=newOwner;emitOwnershipTransferred(oldOwner,newOwner);}"
  ],
  "_ownerOf": ["{return_owners[tokenId];}"],
  "AddBalance": [
    "",
    "{}",
    "{require(tokenId<type(uint96).max,\"Outofrange\");BalanceKeykey=toBalanceKey(account,tokenId);BalanceAmountcurrentBalance=_balanceOf[key];if(currentBalance.getPosition()>0){//Simpleadd_balanceOf[key]=currentBalance.add(amount);}else{uint96[]storagerefTokenIds=tokensHeld[account];uint256length=refTokenIds.length;if(length==0){//AddemptyzeroitemrefTokenIds.push();refTokenIds.push(uint96(tokenId));_balanceOf[key]=BalanceAmount.wrap((uint256(amount)<<16)|1);}else{require(length<type(uint16).max,\"Toomanytypes\");uint16position=uint16(length);refTokenIds.push(uint96(tokenId));_balanceOf[key]=BalanceAmount.wrap((uint256(amount)<<16)|position);}}totalSupply+=amount;}"
  ],
  "get": [
    "{returnaddress(uint256(_get(map._inner,bytes32(key),errorMessage)));}",
    "{\\rreturnaddress(uint160(uint256(_get(map._inner,bytes32(key),errorMessage))));\\r}",
    "{}",
    "{returnaddress(uint160(uint256(_get(map._inner,bytes32(key),errorMessage))));}"
  ],
  "_get": [
    "{uint256keyIndex=map._indexes[key];require(keyIndex!=0,errorMessage);returnmap._entries[keyIndex-1]._value;}",
    "{}",
    "{\\ruint256keyIndex=map._indexes[key];\\rrequire(keyIndex!=0,errorMessage);\\rreturnmap._entries[keyIndex-1]._value;\\r}",
    "{uint256keyIndex=map._indexes[key];require(keyIndex!=0,errorMessage);//Equivalenttocontains(map,key)returnmap._entries[keyIndex-1]._value;//Allindexesare1-based}",
    "{uint256keyIndex=map._indexes[key];require(keyIndex!=0,\"\");returnmap._entries[keyIndex-1]._value;}"
  ],
  "remove": [
    "{require(account!=address(0));require(has(role,account));role.bearer[account]=false;}",
    "{if(account==address(0)){revertUnauthorized();}elseif(!has(role,_type,account)){revertMaxSplaining({reason:string(abi.encodePacked(\"LibRoles:\",Strings.toHexString(uint160(account),20),\"doesnothaverole\",Strings.toHexString(uint32(_type),4)))});}role.bearer[account][_type]=false;emitRoleChanged(_type,account,false);}",
    "{\\rreturn_remove(map._inner,bytes32(key));\\r}",
    "{}",
    "{return_remove(set._inner,bytes32(value));}",
    "{deleteminters[_minter];emitMinterRoleRevoked(_minter);}",
    "{return_remove(map._inner,bytes32(key));}"
  ],
  "set": [
    "{return_set(map._inner,bytes32(key),bytes32(uint256(value)));}",
    "{require(pools.contains(address(_poolToken)),\"HF:Non-existantpool\");massUpdatePools();totalAllocationPoints=totalAllocationPoints.sub(poolInfo[_poolToken].allocation).add(_allocation);poolInfo[_poolToken].allocation=_allocation;emitPoolUpdated(_poolToken,_allocation);if(_allocation==0){pools.remove(address(_poolToken));emitPoolRemoved(_poolToken);}}",
    "{counter._value=number;emitCounterNumberChangedTo(counter._value);}",
    "{\\rreturn_set(map._inner,bytes32(key),bytes32(uint256(uint160(value))));\\r}",
    "{}",
    "{return_set(map._inner,bytes32(key),bytes32(uint256(uint160(value))));}"
  ],
  "andthenremovethelastelement": [
    "",
    "{}",
    "{return_set(map._inner,bytes32(key),bytes32(uint256(uint160(value))));}"
  ],
  "_set": [
    "{\\ruint256keyIndex=map._indexes[key];\\r\\rif(keyIndex==0){map._entries.push(MapEntry({_key:key,_value:value}));\\rmap._indexes[key]=map._entries.length;\\rreturntrue;\\r}else{\\rmap._entries[keyIndex-1]._value=value;\\rreturnfalse;\\r}\\r}",
    "{uint256keyIndex=map._indexes[key];if(keyIndex==0){map._entries.push(MapEntry({_key:key,_value:value}));map._indexes[key]=map._entries.length;returntrue;}else{map._entries[keyIndex-1]._value=value;returnfalse;}}",
    "{}",
    "{return_set(map._inner,bytes32(key),bytes32(uint256(uint160(value))));}",
    "{//Wereadandstorethekey'sindextopreventmultiplereadsfromthesamestorageslotuint256keyIndex=map._indexes[key];if(keyIndex==0){//Equivalentto!contains(map,key)map._entries.push(MapEntry({_key:key,_value:value}));//Theentryisstoredatlength-1,butweadd1toallindexes//anduse0asasentinelvaluemap._indexes[key]=map._entries.length;returntrue;}else{map._entries[keyIndex-1]._value=value;returnfalse;}}"
  ],
  "_pushBurn": [
    "",
    "{}",
    "{require(amount>0,\"non-positiveamount\");_burns[account][nftId]+=amount*block.timestamp;_burnsTotal[nftId]+=amount*block.timestamp;}"
  ],
  "_pushMint": [
    "",
    "{}",
    "{require(amount>0,\"non-positiveamount\");_mints[account][nftId]+=amount*block.timestamp;_mintsTotal[nftId]+=amount*block.timestamp;}"
  ],
  "_callonERC1155Received": [
    "",
    "{}",
    "{//Checkifrecipientiscontractif(_to.isContract()){bytes4retval=IERC1155TokenReceiver(_to).onERC1155Received{gas:_gasLimit}(msg.sender,_from,_id,_amount,_data);if(retval!=ERC1155_RECEIVED_VALUE)revertInvalidOnReceiveMsg();}}"
  ],
  "sub": [
    "{require(b<=a);uint256c=a-b;returnc;}",
    "{\\rrequire(b<=a,errorMessage);\\rreturna-b;\\r}",
    "{require(b<=a,errorMessage);uint256c=a-b;returnc;}",
    "{require(b<=a);returna-b;}",
    "{require(b<=a,\"SafeMath:subtractionoverflow\");uint256c=a-b;returnc;}",
    "{require(b<=a,errorMessage);returna-b;}",
    "{}",
    "{require(b<=a,errorMessage);uintc=a-b;returnc;}",
    "{assert(b\\u003c=a);returna-b;}",
    "{assert(b<=a);returna-b;}",
    "{unchecked{require(b<=a,errorMessage);returna-b;}}",
    "{require(b<=a,\"\");returna-b;}",
    "{require(_subtrahend<=_minuend,\"\");difference=_minuend-_subtrahend;}"
  ],
  "ownershipOf": [
    "{uint256curr=tokenId;unchecked{if(curr<_currentIndex){TokenOwnershipmemoryownership=_ownerships[curr];if(!ownership.burned){if(ownership.addr!=address(0)){returnownership;}while(true){curr--;ownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}}}}revertOwnerQueryForNonexistentToken();}",
    "{if(!_exists(tokenId))revertOwnerQueryForNonexistentToken();unchecked{for(uint256curr=tokenId;;curr--){TokenOwnershipmemoryownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}}}",
    "{}",
    "{uint256curr=tokenId;unchecked{if(_startTokenId()<=curr&&curr<_currentIndex){TokenOwnershipmemoryownership=_ownerships[curr];if(!ownership.burned){if(ownership.addr!=address(0)){returnownership;}while(true){curr--;ownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}}}}revertOwnerQueryForNonexistentToken();}",
    "{uint256curr=tokenId;unchecked{if(_startTokenId()<=curr&&curr<currentIndex){TokenOwnershipmemoryownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}//Invariant://Therewillalwaysbeanownershipthathasanaddressandisnotburned//beforeanownershipthatdoesnothaveanaddressandisnotburned.//Hence,currwillnotunderflow.while(true){curr--;ownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}}}revert(\"ERC721A:unabletodeterminetheowneroftoken\");}",
    "{require(_exists(tokenId),\"ERC721A:ownerqueryfornonexistenttoken\");uint256lowestTokenToCheck;if(tokenId>=maxBatchSize){lowestTokenToCheck=tokenId-maxBatchSize+1;}for(uint256curr=tokenId;curr>=lowestTokenToCheck;curr--){TokenOwnershipmemoryownership=_ownerships[curr];if(ownership.addr!=address(0)){returnownership;}}revert(\"ERC721A:unabletodeterminetheowneroftoken\");}"
  ],
  "functionCall": [
    "{return_functionCallWithValue(target,data,0,errorMessage);}",
    "{}",
    "{\\rreturnfunctionCallWithValue(target,data,0,errorMessage);\\r}",
    "{returnfunctionCallWithValue(target,data,0,errorMessage);}"
  ],
  "_functionCallWithValue": [
    "{require(isContract(target),\"Address:calltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.call{value:weiValue}(data);if(success){returnreturndata;}else{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");return_functionCallWithValue(target,data,value,errorMessage);}",
    "{}"
  ],
  "functionCallWithValue": [
    "{require(address(this).balance\\u003e=value,\"Address:insufficientbalanceforcall\");require(isContract(target),\"Address:calltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{\\rrequire(address(this).balance>=value,\"Address:insufficientbalanceforcall\");\\rrequire(isContract(target),\"Address:calltonon-contract\");\\r\\r(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);\\rreturn_verifyCallResult(success,returndata,errorMessage);\\r}_verifyCallResult {\\rif(success){\\rreturnreturndata;\\r}else{\\rif(returndata.length>0){\\r\\rassembly{\\rletreturndata_size:=mload(returndata)\\rrevert(add(32,returndata),returndata_size)\\r}\\r}else{\\rrevert(errorMessage);\\r}\\r}\\r}",
    "{\\rrequire(address(this).balance>=value,\"Address:insufficientbalanceforcall\");\\rrequire(isContract(target),\"Address:calltonon-contract\");\\r\\r(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);\\rreturn_verifyCallResult(success,returndata,errorMessage);\\r}",
    "{\\rrequire(address(this).balance\\u003e=value,\"Address:insufficientbalanceforcall\");\\rrequire(isContract(target),\"Address:calltonon-contract\");\\r\\r(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);\\rreturnverifyCallResult(success,returndata,errorMessage);\\r}",
    "{require(address(this).balance\\u003e=value,\"Address:insufficientbalanceforcall\");require(isContract(target),\"Address:calltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,'Address:insufficientbalanceforcall');require(isContract(target),'Address:calltonon-contract');(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{\\rrequire(address(this).balance>=value,\"Address:insufficientbalanceforcall\");\\rrequire(isContract(target),\"Address:calltonon-contract\");\\r\\r(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);\\rreturnverifyCallResult(success,returndata,errorMessage);\\r}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");return_functionCallWithValue(target,data,value,errorMessage);}",
    "{}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");require(isContract(target),\"Address:calltonon-contract\");//solhint-disable-next-lineavoid-low-level-calls(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");require(isContract(target),\"Address:calltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResultFromTarget(target,success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"Address:insufficientbalanceforcall\");require(isContract(target),\"Address:calltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"\");require(isContract(target),\"\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(address(this).balance>=value,\"\");require(isContract(target),\"\");(boolsuccess,bytesmemoryreturndata)=target.call{value:value}(data);returnverifyCallResult(success,returndata,errorMessage);}"
  ],
  "verifyCallResultFromTarget": [
    "",
    "{if(success){if(returndata.length==0){//onlycheckisContractifthecallwassuccessfulandthereturndataisempty//otherwisewealreadyknowthatitwasacontractrequire(isContract(target),\"Address:calltonon-contract\");}returnreturndata;}else{_revert(returndata,errorMessage);}}",
    "{}",
    "{if(success){if(returndata.length==0){require(isContract(target),\"Address:calltonon-contract\");}returnreturndata;}else{_revert(returndata,errorMessage);}}"
  ],
  "_revert": [
    "",
    "{assembly{mstore(0x00,errorSelector)revert(0x00,0x04)}}",
    "{//Lookforrevertreasonandbubbleitupifpresentif(returndata.length>0){//Theeasiestwaytobubbletherevertreasonisusingmemoryviaassembly///@soliditymemory-safe-assemblyassembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}",
    "{}",
    "{if(returndata.length>0){assembly{letreturndata_size:=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}"
  ],
  "_callOptionalReturn": [
    "{//Weneedtoperformalowlevelcallhere,tobypassSolidity'sreturndatasizecheckingmechanism,since//we'reimplementingitourselves.Weuse{Address.functionCall}toperformthiscall,whichverifiesthat//thetargetaddresscontainscontractcodeandalsoassertsforsuccessinthelow-levelcall.bytesmemoryreturndata=address(token).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){//Returndataisoptional//solhint-disable-next-linemax-line-lengthrequire(abi.decode(returndata,(bool)),\"SafeERC20:ERC20operationdidnotsucceed\");}}",
    "{//Weneedtoperformalowlevelcallhere,tobypassSolidity'sreturndatasizecheckingmechanism,since//we'reimplementingitourselves.Weuse{Address.functionCall}toperformthiscall,whichverifiesthat//thetargetaddresscontainscontractcodeandalsoassertsforsuccessinthelow-levelcall.bytesmemoryreturndata=address(token).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){//Returndataisoptionalrequire(abi.decode(returndata,(bool)),\"SafeERC20:ERC20operationdidnotsucceed\");}}",
    "{//Weneedtoperformalowlevelcallhere,tobypassSolidity'sreturndatasizecheckingmechanism,since//we'reimplementingitourselves.Weuse{Address-functionCall}toperformthiscall,whichverifiesthat//thetargetaddresscontainscontractcodeandalsoassertsforsuccessinthelow-levelcall.bytesmemoryreturndata=address(token).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){//Returndataisoptionalrequire(abi.decode(returndata,(bool)),\"SafeERC20:ERC20operationdidnotsucceed\");}}",
    "{bytesmemoryreturndata=address(token).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){require(abi.decode(returndata,(bool)),\"SafeERC20:ERC20operationdidnotsucceed\");}}",
    "",
    "{}",
    "{bytesmemoryreturndata=address(token).functionCall(data,\"SafeERC20:low-levelcallfailed\");if(returndata.length>0){require(abi.decode(returndata,\"\")),\"SafeERC20:ERC20operationdidnotsucceed\");}}"
  ],
  "_safeTransferFrom": [
    "{require(to!=address(0),\"ERC1155WithTerminusStorage:transfertothezeroaddress\");LibTerminus.TerminusStoragestoragets=LibTerminus.terminusStorage();require(!ts.poolNotTransferable[id],\"ERC1155WithTerminusStorage:_safeTransferFrom--poolisnottransferable\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);uint256fromBalance=ts.poolBalances[id][from];require(fromBalance>=amount,\"ERC1155WithTerminusStorage:insufficientbalancefortransfer\");unchecked{ts.poolBalances[id][from]=fromBalance-amount;}ts.poolBalances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{addresstokenOwner=idToOwner[_tokenId];require(tokenOwner==_from,\"Incorrectowner.\");require(_to!=address(0));_transfer(_to,_tokenId);if(isContract(_to)){bytes4retval=ERC721TokenReceiver(_to).onERC721Received(msg.sender,_from,_tokenId,_data);require(retval==MAGIC_ON_ERC721_RECEIVED);}}",
    "{//Updatebalances_updateIDBalance(_from,_id,_amount,Operations.Sub);//Subtractamountfromsender_updateIDBalance(_to,_id,_amount,Operations.Add);//Addamounttorecipient//EmiteventemitTransferSingle(msg.sender,_from,_to,_id,_amount);}",
    "{require(from!=address(0),\"ERC1155:transferfromthezeroaddress\");require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();SubtractBalance(from,id,amount);AddBalance(to,id,amount);emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{//require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();uint256[]memoryids=_asSingletonArray(id);uint256[]memoryamounts=_asSingletonArray(amount);_beforeTokenTransfer(operator,from,to,ids,amounts,data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_afterTokenTransfer(operator,from,to,ids,amounts,data);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,_asSingletonArray(id),_asSingletonArray(amount),data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "",
    "{\\rrequire(to!=address(0),\"ERC1155:transfertothezeroaddress\");\\r\\raddressoperator=_msgSender();\\ruint256[]memoryids=_asSingletonArray(id);\\ruint256[]memoryamounts=_asSingletonArray(amount);\\r\\r_beforeTokenTransfer(operator,from,to,ids,amounts,data);\\r\\ruint256fromBalance=_balances[id][from];\\rrequire(\\rfromBalance>=amount,\\r\"ERC1155:insufficientbalancefortransfer\"\\r);\\runchecked{\\r_balances[id][from]=fromBalance-amount;\\r}\\r_balances[id][to]+=amount;\\r\\remitTransferSingle(operator,from,to,id,amount);\\r\\r_afterTokenTransfer(operator,from,to,ids,amounts,data);\\r\\r_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);\\r}",
    "{}",
    "{require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();uint256[]memoryids=_asSingletonArray(id);uint256[]memoryamounts=_asSingletonArray(amount);_beforeTokenTransfer(operator,from,to,ids,amounts,data);uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;emitTransferSingle(operator,from,to,id,amount);_afterTokenTransfer(operator,from,to,ids,amounts,data);_doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);}",
    "{addresstokenOwner=idToOwner[_tokenId];require(tokenOwner==_from,\"\");require(_to!=address(0),\"\");_transfer(_to,_tokenId);if(_to.isContract()){bytes4retval=ERC721TokenReceiver(_to).onERC721Received(msg.sender,_from,_tokenId,_data);require(retval==MAGIC_ON_ERC721_RECEIVED,\"\");}}"
  ],
  "_asSingletonArray": [
    "",
    "{\\ruint256[]memoryarray=newuint256[](1);\\rarray[0]=element;\\r\\rreturnarray;\\r}",
    "{}",
    "{uint256[]memoryarray=newuint256[](1);array[0]=element;returnarray;}"
  ],
  "_doSafeTransferAcceptanceCheck": [
    "{if(to.isContract()){tryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){if(response!=IERC1155Receiver.onERC1155Received.selector){revert(\"ERC1155WithTerminusStorage:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155WithTerminusStorage:transfertononERC1155Receiverimplementer\");}}}",
    "{\\rif(to.isContract()){\\rtryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){\\rif(response!=IERC1155Receiver(to).onERC1155Received.selector){\\rrevert(\"ERC1155:ERC1155Receiverrejectedtokens\");\\r}\\r}catchError(stringmemoryreason){\\rrevert(reason);\\r}catch{\\rrevert(\"ERC1155:transfertononERC1155Receiverimplementer\");\\r}\\r}\\r}",
    "{if(isContract(to)){tryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){if(response!=IERC1155Receiver.onERC1155Received.selector){revert(\"ERC1155:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155:transfertononERC1155Receiverimplementer\");}}}",
    "{if(to.isContract()){tryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){if(response!=IERC1155Receiver(to).onERC1155Received.selector){revert(\"ERC1155:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155:transfertononERC1155Receiverimplementer\");}}}",
    "{}",
    "{\\rif(to.isContract()){\\rtry\\rIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)\\rreturns(bytes4response){\\rif(response!=IERC1155Receiver.onERC1155Received.selector){\\rrevert(\"ERC1155:ERC1155Receiverrejectedtokens\");\\r}\\r}catchError(stringmemoryreason){\\rrevert(reason);\\r}catch{\\rrevert(\"ERC1155:transfertononERC1155Receiverimplementer\");\\r}\\r}\\r}",
    "{require(ERC1155TokenReceiver(_to).onERC1155Received(_operator,_from,_id,_value,_data)==ERC1155_ACCEPTED,\"contractreturnedanunknownvaluefromonERC1155Received\");}",
    "{if(to.isContract()){tryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){if(response!=IERC1155Receiver.onERC1155Received.selector){revert(\"ERC1155:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155:transfertonon-ERC1155Receiverimplementer\");}}}",
    "{if(to.isContract()){tryIERC1155Receiver(to).onERC1155Received(operator,from,id,amount,data)returns(bytes4response){if(response!=IERC1155Receiver.onERC1155Received.selector){revert(\"ERC1155:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155:transfertononERC1155Receiverimplementer\");}}}"
  ],
  "_startTokenId": ["{}", "{returnstartTokenId;}", "{return0;}", "{return1;}"],
  "_msgSenderERC721A": [
    "{}",
    "",
    "{return0;}",
    "{returnmsg.sender;}",
    "{returnmsg.sender;}"
  ],
  "onERC1155Received": ["", "{returnthis.onERC1155Received.selector;}", "{}"],
  "onERC721Received": [
    "{}",
    "{returnthis.onERC721Received.selector;}",
    "{require(from==address(0x0),\"CannotsendtokenstoBarndirectly\");returnIERC721Receiver.onERC721Received.selector;}"
  ],
  "_spendAllowance": [
    "{uint256currentAllowance=allowance(owner,spender);if(currentAllowance!=type(uint256).max){require(currentAllowance>=amount,\"ERC20:insufficientallowance\");unchecked{_approve(owner,spender,currentAllowance-amount);}}}",
    "",
    "{}"
  ],
  "_checkContractOnERC721Received": [
    "{tryERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)returns(bytes4retval){returnretval==ERC721A__IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){_revert(TransferToNonERC721ReceiverImplementer.selector);}assembly{revert(add(32,reason),mload(reason))}}}",
    "",
    "{tryERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)returns(bytes4retval){returnretval==ERC721A__IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revertTransferToNonERC721ReceiverImplementer();}else{assembly{revert(add(32,reason),mload(reason))}}}}",
    "{tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval){returnretval==IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revertTransferToNonERC721ReceiverImplementer();}else{assembly{revert(add(32,reason),mload(reason))}}}}",
    "{tryERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)returns(bytes4retval){returnretval==ERC721A__IERC721Receiver(to).onERC721Received.selector;}catch(bytesmemoryreason){if(reason.length==0){revertTransferToNonERC721ReceiverImplementer();}else{assembly{revert(add(32,reason),mload(reason))}}}}",
    "{}"
  ],
  "_add": [
    "{\\rif(!_contains(set,value)){\\rset._values.push(value);\\rset._indexes[value]=set._values.length;\\rreturntrue;\\r}else{\\rreturnfalse;\\r}\\r}",
    "{if(!_contains(set,value)){set._values.push(value);//Thevalueisstoredatlength-1,butweadd1toallindexes//anduse0asasentinelvalueset._indexes[value]=set._values.length;returntrue;}else{returnfalse;}}",
    "",
    "{}",
    "{if(!_contains(set,value)){set._values.push(value);set._indexes[value]=set._values.length;returntrue;}else{returnfalse;}}"
  ],
  "hasRole": [
    "{return_checkRole(role,account);}",
    "{return_roles[role].members[account];}",
    "{}",
    "{return_roles[role].members.contains(account);}"
  ],
  "erc721Storage": [
    "{}",
    "{bytes32position=ERC721_STORAGE_POSITION;assembly{es.slot:=position}}"
  ],
  "isApprovedForPool": [
    "{}",
    "{returnLibTerminus._isApprovedForPool(poolID,operator);}"
  ],
  "terminusStorage": [
    "{}",
    "{bytes32position=TERMINUS_STORAGE_POSITION;assembly{es.slot:=position}}"
  ],
  "emitRoleChanged": ["{}", ""],
  "_isApprovedForPool": ["{}", ""],
  "isTokenRented": ["{}", ""],
  "_checkRole": [
    "{}",
    "{\\rif(!_gameRegistry.hasAccessRole(role,account)){\\rrevertMissingRole(account,role);\\r}\\r}",
    "{returncontractRoles.has(role,account);}",
    "{if(!hasRole(role,account)){revert(string(abi.encodePacked(\"AccessControl:account\",Strings.toHexString(uint160(account),20),\"ismissingrole\",Strings.toHexString(uint256(role),32))));}}"
  ],
  "toHexString": [
    "{bytesmemorybuffer=newbytes(2*length+2);buffer[0]=\"0\";buffer[1]=\"x\";for(uint256i=2*length+1;i>1;--i){buffer[i]=_HEX_SYMBOLS[value&0xf];value>>=4;}require(value==0,\"\");returnstring(buffer);}",
    "{bytesmemorybuffer=newbytes(2*length+2);buffer[0]=\"0\";buffer[1]=\"x\";for(uint256i=2*length+1;i>1;--i){buffer[i]=alphabet[value&0xf];value>>=4;}require(value==0,\"Strings:hexlengthinsufficient\");returnstring(buffer);}",
    "{bytesmemorybuffer=newbytes(2*length+2);buffer[0]='0';buffer[1]='x';for(uint256i=2*length+1;i>1;--i){buffer[i]=_HEX_SYMBOLS[value&0xf];value>>=4;}require(value==0,'Strings:hexlengthinsufficient');returnstring(buffer);}",
    "{bytesmemorybuffer=newbytes(2*length+2);buffer[0]=\"0\";buffer[1]=\"x\";for(uint256i=2*length+1;i\\u003e1;--i){buffer[i]=_HEX_SYMBOLS[value\\u00260xf];value\\u003e\\u003e=4;}require(value==0,\"Strings:hexlengthinsufficient\");returnstring(buffer);}",
    "{returntoHexString(uint256(uint160(addr)),_ADDRESS_LENGTH);}",
    "{\\rbytesmemorybuffer=newbytes(2*length+2);\\rbuffer[0]=\"0\";\\rbuffer[1]=\"x\";\\rfor(uint256i=2*length+1;i\\u003e1;--i){\\rbuffer[i]=_HEX_SYMBOLS[value\\u00260xf];\\rvalue\\u003e\\u003e=4;\\r}\\rrequire(value==0,\"Strings:hexlengthinsufficient\");\\rreturnstring(buffer);\\r}",
    "{}",
    "{bytesmemorybuffer=newbytes(2*length+2);buffer[0]=\"0\";buffer[1]=\"x\";for(uint256i=2*length+1;i>1;--i){buffer[i]=_HEX_SYMBOLS[value&0xf];value>>=4;}require(value==0,\"Strings:hexlengthinsufficient\");returnstring(buffer);}"
  ],
  "supportsInterface": [
    "{return_supportedInterfaces[interfaceId];}",
    "{returninterfaceId==type(IERC721Enumerable).interfaceId||super.supportsInterface(interfaceId);}",
    "{returninterfaceId==type(IERC165).interfaceId;}",
    "{returninterfaceId==type(IERC1155).interfaceId||interfaceId==type(IERC1155MetadataURI).interfaceId||super.supportsInterface(interfaceId);}",
    "{returnsupportedInterfaces[_interfaceID];}",
    "{returninterfaceId==type(IERC721).interfaceId||interfaceId==type(IERC721Metadata).interfaceId||super.supportsInterface(interfaceId);}"
  ],
  "balanceOf": [
    "{require(owner!=address(0),\"ERC721:balancequeryforthezeroaddress\");return_balances[owner];}",
    "{if(owner==address(0))revertBalanceQueryForZeroAddress();returnuint256(_addressData[owner].balance);}",
    "{require(account!=address(0),\"ERC1155:balancequeryforthezeroaddress\");return_balances[id][account];}",
    "{require(owner!=address(0),\"\");return_balances[owner];}",
    "{require(owner!=address(0),\"\");return_holderTokens[owner].length();}",
    "{require(_owner!=address(0),\"\");return_getOwnerNFTCount(_owner);}"
  ],
  "name": ["{return_name;}", "{_name=nftName;}"],
  "symbol": ["{return_symbol;}", "{_symbol=nftSymbol;}"],
  "admin": ["{return_admin;}", "{admin_=_getAdmin();}"],
  "approve": [
    "{addressowner=ERC721.ownerOf(tokenId);require(to!=owner,\"ERC721:approvaltocurrentowner\");require(_msgSender()==owner||isApprovedForAll(owner,_msgSender()),\"ERC721:approvecallerisnotownernorapprovedforall\");_approve(to,tokenId);}",
    "{addressowner=ERC721A.ownerOf(tokenId);if(to==owner)revertApprovalToCurrentOwner();if(_msgSender()!=owner&&!isApprovedForAll(owner,_msgSender())){revertApprovalCallerNotOwnerNorApproved();}_approve(to,tokenId,owner);}",
    "{addressowner=BRC721.ownerOf(tokenId);require(to!=owner,\"ERC721:approvaltocurrentowner\");require(_msgSender()==owner||isApprovedForAll(owner,_msgSender()),\"ERC721:approvecallerisnotownernorapprovedforall\");_approve(to,tokenId);}",
    "{addressowner=ERC721.ownerOf(tokenId);require(to!=owner,\"\");require(_msgSender()==owner||isApprovedForAll(owner,\"\")),\"ERC721:approvecallerisnotownernorapprovedforall\");_approve(to,tokenId);}",
    "{addressowner=ERC721.ownerOf(tokenId);require(to!=owner,\"\");require(_msgSender()==owner||ERC721.isApprovedForAll(owner,\"\")),\"ERC721:approvecallerisnotownernorapprovedforall\");_approve(to,tokenId);}",
    "{addresstokenOwner=idToOwner[_tokenId];require(_approved!=tokenOwner,\"\");idToApproval[_tokenId]=_approved;emitApproval(tokenOwner,_approved,_tokenId);}"
  ],
  "setApprovalForAll": [
    "{require(operator!=_msgSender(),\"ERC721:approvetocaller\");_operatorApprovals[_msgSender()][operator]=approved;emitApprovalForAll(_msgSender(),operator,approved);}",
    "{if(operator==_msgSender())revertApproveToCaller();_operatorApprovals[_msgSender()][operator]=approved;emitApprovalForAll(_msgSender(),operator,approved);}",
    "{_setApprovalForAll(_msgSender(),operator,approved);}",
    "{require(operator!=_msgSender(),\"\");_operatorApprovals[_msgSender()][operator]=approved;emitApprovalForAll(_msgSender(),operator,approved);}",
    "{ownerToOperators[msg.sender][_operator]=_approved;emitApprovalForAll(msg.sender,_operator,_approved);}"
  ],
  "_safeMint": [
    "{_mint(to,tokenId);require(_checkOnERC721Received(address(0),to,tokenId,_data),\"ERC721:transfertononERC721Receiverimplementer\");}",
    "{_mint(to,quantity,_data,true);}",
    "{_mint(to,tokenId);require(_checkOnERC721Received(address(0),\"\"),\"ERC721:transfertononERC721Receiverimplementer\");}"
  ],
  "_burn": [
    "{addressowner=ERC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId);//Clearapprovals_approve(address(0),tokenId);_balances[owner]-=1;delete_owners[tokenId];emitTransfer(owner,address(0),tokenId);}",
    "{require(from!=address(0),\"ERC1155:burnfromthezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,address(0),_asSingletonArray(id),_asSingletonArray(amount),\"\");uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:burnamountexceedsbalance\");unchecked{_balances[id][from]=fromBalance-amount;}emitTransferSingle(operator,from,address(0),id,amount);}",
    "{require(_exists(tokenId),\"ERC721:burnnonexistenttoken\");addressowner=BRC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId);_approve(address(0),tokenId);_balances[owner]-=1;delete_owners[tokenId];emitTransfer(owner,address(0),tokenId);}",
    "{TokenOwnershipmemoryprevOwnership=ownershipOf(tokenId);_beforeTokenTransfers(prevOwnership.addr,address(0),tokenId,1);_approve(address(0),tokenId,prevOwnership.addr);unchecked{_addressData[prevOwnership.addr].balance-=1;_addressData[prevOwnership.addr].numberBurned+=1;_ownerships[tokenId].addr=prevOwnership.addr;_ownerships[tokenId].startTimestamp=uint64(block.timestamp);_ownerships[tokenId].burned=true;uint256nextTokenId=tokenId+1;if(_ownerships[nextTokenId].addr==address(0)){if(nextTokenId<_currentIndex){_ownerships[nextTokenId].addr=prevOwnership.addr;_ownerships[nextTokenId].startTimestamp=prevOwnership.startTimestamp;}}}emitTransfer(prevOwnership.addr,address(0),tokenId);_afterTokenTransfers(prevOwnership.addr,address(0),tokenId,1);unchecked{_burnCounter++;}}",
    "{addressowner=ERC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId);_approve(address(0),tokenId);_balances[owner]-=1;delete_owners[tokenId];emitTransfer(owner,address(0),tokenId);}",
    "{addressowner=ERC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId);_approve(address(0),tokenId);if(bytes(_tokenURIs[tokenId]).length!=0){delete_tokenURIs[tokenId];}_holderTokens[owner].remove(tokenId);_tokenOwners.remove(tokenId);emitTransfer(owner,address(0),tokenId);}",
    "{super._burn(_tokenId);if(bytes(idToUri[_tokenId]).length!=0){deleteidToUri[_tokenId];}if(bytes(idToPayload[_tokenId]).length!=0){deleteidToPayload[_tokenId];}uint256tokenIndex=idToIndex[_tokenId];uint256lastTokenIndex=tokens.length-1;uint256lastToken=tokens[lastTokenIndex];tokens[tokenIndex]=lastToken;tokens.pop();idToIndex[lastToken]=tokenIndex;idToIndex[_tokenId]=0;}",
    "{addressowner=ERC721.ownerOf(tokenId);_beforeTokenTransfer(owner,address(0),tokenId);_approve(address(0),tokenId);_balances[owner]-=1;delete_owners[tokenId];emitTransfer(owner,address(0),tokenId);_afterTokenTransfer(owner,address(0),tokenId);}"
  ],
  "tokenOfOwnerByIndex": [
    "{require(index<ERC721.balanceOf(owner),\"ERC721Enumerable:ownerindexoutofbounds\");return_ownedTokens[owner][index];}",
    "{require(index<BRC721.balanceOf(owner),\"ERC721Enumerable:ownerindexoutofbounds\");return_ownedTokens[owner][index];}",
    "{require(index<ERC721.balanceOf(owner),\"\");return_ownedTokens[owner][index];}",
    "{return_holderTokens[owner].at(index);}",
    "{require(_index<ownerToIds[_owner].length,\"\");returnownerToIds[_owner][_index];}"
  ],
  "totalSupply": [
    "{return_allTokens.length;}",
    "{unchecked{return_currentIndex-_burnCounter;}}",
    "{return_totalSupply[id];}",
    "{return_tokenOwners.length();}",
    "{returntokens.length;}"
  ],
  "tokenByIndex": [
    "{require(index<ERC721Enumerable.totalSupply(),\"ERC721Enumerable:globalindexoutofbounds\");return_allTokens[index];}",
    "{require(index<BRC721Enumerable.totalSupply(),\"ERC721Enumerable:globalindexoutofbounds\");return_allTokens[index];}",
    "{require(index<ERC721Enumerable.totalSupply(),\"\");return_allTokens[index];}",
    "{(uint256tokenId,)=_tokenOwners.at(index);returntokenId;}",
    "{require(_index<tokens.length,\"\");returntokens[_index];}"
  ],
  "_pause": ["{_paused=true;emitPaused(_msgSender());}"],
  "_unpause": ["{_paused=false;emitUnpaused(_msgSender());}"],
  "sendValue": [
    "{require(address(this).balance>=amount,\"Address:insufficientbalance\");(boolsuccess,)=recipient.call{value:amount}(\"\");require(success,\"Address:unabletosendvalue,recipientmayhavereverted\");}",
    "{require(address(this).balance>=amount,\"\");(boolsuccess,)=recipient.call{value:amount}(\"\");require(success,\"\");}"
  ],
  "functionStaticCall": [
    "{require(isContract(target),\"Address:staticcalltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.staticcall(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(isContract(target),\"Address:staticcalltonon-contract\");(boolsuccess,bytesmemoryreturndata)=target.staticcall(data);returnverifyCallResult(success,returndata,errorMessage);}",
    "{require(isContract(target),\"\");(boolsuccess,bytesmemoryreturndata)=target.staticcall(data);return_verifyCallResult(success,returndata,errorMessage);}",
    "{require(isContract(target),\"\");(boolsuccess,bytesmemoryreturndata)=target.staticcall(data);returnverifyCallResult(success,returndata,errorMessage);}"
  ],
  "random": ["{returnuint256(keccak256(abi.encodePacked(input)));}"],
  "getWeapon": ["{returnpluck(tokenId,\"WEAPON\",weapons);}"],
  "getChest": ["{returnpluck(tokenId,\"CHEST\",chestArmor);}"],
  "getHead": ["{returnpluck(tokenId,\"HEAD\",headArmor);}"],
  "getWaist": ["{returnpluck(tokenId,\"WAIST\",waistArmor);}"],
  "getFoot": ["{returnpluck(tokenId,\"FOOT\",footArmor);}"],
  "getHand": ["{returnpluck(tokenId,\"HAND\",handArmor);}"],
  "getNeck": ["{returnpluck(tokenId,\"NECK\",necklaces);}"],
  "getRing": ["{returnpluck(tokenId,\"RING\",rings);}"],
  "claim": [
    "{require(tokenId>8000&&tokenId<(block.number/10)+1,\"\");_safeMint(_msgSender(),tokenId);}"
  ],
  "encode": [
    "{uint256len=data.length;if(len==0)return\"\";uint256encodedLen=4*((len+2)/3);bytesmemoryresult=newbytes(encodedLen+32);bytesmemorytable=TABLE;assembly{lettablePtr:=add(table,1)letresultPtr:=add(result,32)for{leti:=0}lt(i,len){}{i:=add(i,3)letinput:=and(mload(add(data,i)),0xffffff)letout:=mload(add(tablePtr,and(shr(18,input),0x3F)))out:=shl(8,out)out:=add(out,and(mload(add(tablePtr,and(shr(12,input),0x3F))),0xFF))out:=shl(8,out)out:=add(out,and(mload(add(tablePtr,and(shr(6,input),0x3F))),0xFF))out:=shl(8,out)out:=add(out,and(mload(add(tablePtr,and(input,0x3F))),0xFF))out:=shl(224,out)mstore(resultPtr,out)resultPtr:=add(resultPtr,4)}switchmod(len,3)case1{mstore(sub(resultPtr,2),shl(240,0x3d3d))}case2{mstore(sub(resultPtr,1),shl(248,0x3d))}mstore(result,encodedLen)}returnstring(result);}"
  ],
  "_msgData": ["{this;returnmsg.data;}", "{returnmsg.data;}"],
  "pluck": [
    "{uint256rand=random(string(abi.encodePacked(keyPrefix,toString(tokenId))));stringmemoryoutput=sourceArray[rand%sourceArray.length];uint256greatness=rand%21;if(greatness>14){output=string(abi.encodePacked(output,\"\",suffixes[rand%suffixes.length]));}if(greatness>=19){string[2]memoryname;name[0]=namePrefixes[rand%namePrefixes.length];name[1]=nameSuffixes[rand%nameSuffixes.length];if(greatness==19){output=string(abi.encodePacked('\"',name[0],'',name[1],'\"',output));}else{output=string(abi.encodePacked('\"',name[0],'',name[1],'\"',output,\"+1\"));}}returnoutput;}"
  ],
  "revertMaxSplaining": ["{}", ""],
  "mload": ["{}", ""],
  "emitCounterNumberChangedTo": ["{}", ""],
  "revert": ["{}", ""],
  "revertApprovalQueryForNonexistentToken": ["{}", ""],
  "startTokenId": ["", "{}"],
  "return_startTokenId": ["", "{}"],
  "returntokenId": ["", "{}"],
  "require": ["", "{}"],
  "uint16": ["", "{}"],
  "revertUnauthorized": ["", "{}"],
  "calldataload": ["", "{}"],
  "calldatasize": ["", "{}"],
  "shr": ["", "{}"],
  "emitApproval": ["", "{}"],
  "return_ownerOf": ["", "{}"],
  "revertTransferToNonERC721ReceiverImplementer": ["{}", ""],
  "IERC721Receiver": ["{}", ""],
  "tryERC721A__IERC721Receiver": ["{}", ""],
  "returnpayable": ["", "{}"],
  "returnownershipOf": ["", "{}"],
  "returnaddress": ["", "{}"],
  "returns": ["", "{}"],
  "decode": ["", "{}"],
  "emitTransfer": ["", "{}"],
  "unwrap": ["", "{}"],
  "uint160": ["", "{}"],
  "revertOwnerQueryForNonexistentToken": [""],
  "revertUnableDetermineTokenOwner": [""],
  "_tokenOwner": ["", "{}"],
  "uint240": ["", "{}"],
  "thendeletethelastslot": ["", "{}"],
  "_isOperatable": ["", "{}"],
  "transfertoaddress": ["", "{}"],
  "return_add": ["", "{}"],
  "payable": ["", "{}"],
  "ForwarderRegistryContextBase": ["", "{}"],
  "uint256": ["", "{}"],
  "MapEntry": ["", "{}"],
  "_afterTokenTransfer": ["", "{}"],
  "return_tokenOwner": ["", "{}"],
  "Clearapprovalsfromthepreviousowner_approve": ["", "{}"],
  "approvalsfromthepreviousowner_approve": ["", "{}"],
  "internalownerrequire": ["", "{}"],
  "ownerrequire": ["", "{}"],
  "elseif": ["", "{}"],
  "lengthrequire": ["", "{}"],
  "encodeWithSelector": ["", "{}"],
  "Approval": ["", "{}"],
  "shl": [""],
  "address": ["", "{}"],
  "has": [
    "{if(account==address(0)){revertUnauthorized();}returnrole.bearer[account][_type];}",
    "{}",
    "{require(account!=address(0));returnrole.bearer[account];}"
  ],
  "_updateIDUserTotalBalance": ["", "{}"],
  "gasleft": ["", "{}"],
  "revertInvalidOnReceiveMsg": ["", "{}"],
  "IERC1155TokenReceiver": ["", "{}"],
  "Checkifrecipientiscontractif": ["", "{}"],
  "emitTransferSingle": ["", "{}"],
  "pop": ["", "{}"],
  "SubtractBalance": ["", "{}"],
  "wrap": ["", "{}"],
  "push": ["", "{}"],
  "type": ["", "{}"],
  "uint96": ["", "{}"],
  "string": ["", "{}"],
  "returnhasRole": ["", "{}"],
  "getPosition": ["", "{}"],
  "toBalanceKey": ["", "{}"],
  "tryIERC1155Receiver": ["", "{}"],
  "ERC1155TokenReceiver": ["", "{}"],
  "keccak256": ["", "{}"],
  "assert": ["", "{}"],
  "extcodehash": ["", "{}"],
  "TransferSingle": ["", "{}"],
  "IERC1155Receiver": ["", "{}"],
  "MinterRoleGranted": ["", "{}"],
  "or": [""],
  "timestamp": [""],
  "sload": [""],
  "_extraData": ["{}"],
  "catchError": ["", "{}"],
  "_tokenExists": ["", "{}"],
  "_tokenHasApproval": ["", "{}"],
  "extcodesize": ["", "{}"],
  "tryIERC721Receiver": ["{}", ""],
  "ERC721A__IERC721Receiver": ["{}", ""],
  "changeBaseURI": [
    "{}",
    "{stringmemorysymbol_=symbol();baseURI=string(abi.encodePacked(newBaseURI,symbol_,\"/\"));}"
  ],
  "addController": ["{_controllers[_controller]=true;}"],
  "delController": ["{delete_controllers[_controller];}"],
  "disableController": ["{_controllers[_controller]=false;}"],
  "isController": ["{allowed=_controllers[_address];}"],
  "relinquishControl": ["{delete_controllers[msg.sender];}"],
  "uri": ["{returntokenURI[_id];}"],
  "balanceOfBatch": [
    "{require(accounts.length==ids.length,\"ERC1155:accountsandidslengthmismatch\");uint256[]memorybatchBalances=newuint256[](accounts.length);for(uint256i=0;i<accounts.length;++i){batchBalances[i]=balanceOf(accounts[i],ids[i]);}returnbatchBalances;}"
  ],
  "_safeBatchTransferFrom": [
    "{require(ids.length==amounts.length,\"ERC1155:idsandamountslengthmismatch\");require(to!=address(0),\"ERC1155:transfertothezeroaddress\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,to,ids,amounts,data);for(uint256i=0;i<ids.length;++i){uint256id=ids[i];uint256amount=amounts[i];uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:insufficientbalancefortransfer\");unchecked{_balances[id][from]=fromBalance-amount;}_balances[id][to]+=amount;}emitTransferBatch(operator,from,to,ids,amounts);_doSafeBatchTransferAcceptanceCheck(operator,from,to,ids,amounts,data);}"
  ],
  "_setURI": ["{_uri=newuri;}"],
  "_mintBatch": [
    "{require(to!=address(0),\"ERC1155:minttothezeroaddress\");require(ids.length==amounts.length,\"ERC1155:idsandamountslengthmismatch\");addressoperator=_msgSender();_beforeTokenTransfer(operator,address(0),to,ids,amounts,data);for(uint256i=0;i<ids.length;i++){_balances[ids[i]][to]+=amounts[i];}emitTransferBatch(operator,address(0),to,ids,amounts);_doSafeBatchTransferAcceptanceCheck(operator,address(0),to,ids,amounts,data);}"
  ],
  "_burnBatch": [
    "{require(from!=address(0),\"ERC1155:burnfromthezeroaddress\");require(ids.length==amounts.length,\"ERC1155:idsandamountslengthmismatch\");addressoperator=_msgSender();_beforeTokenTransfer(operator,from,address(0),ids,amounts,\"\");for(uint256i=0;i<ids.length;i++){uint256id=ids[i];uint256amount=amounts[i];uint256fromBalance=_balances[id][from];require(fromBalance>=amount,\"ERC1155:burnamountexceedsbalance\");unchecked{_balances[id][from]=fromBalance-amount;}}emitTransferBatch(operator,from,address(0),ids,amounts);}"
  ],
  "_setApprovalForAll": [
    "{require(owner!=operator,\"ERC1155:settingapprovalstatusforself\");_operatorApprovals[owner][operator]=approved;emitApprovalForAll(owner,operator,approved);}",
    "{require(owner!=operator,\"\");_operatorApprovals[owner][operator]=approved;emitApprovalForAll(owner,operator,approved);}"
  ],
  "_doSafeBatchTransferAcceptanceCheck": [
    "{if(to.isContract()){tryIERC1155Receiver(to).onERC1155BatchReceived(operator,from,ids,amounts,data)returns(bytes4response){if(response!=IERC1155Receiver.onERC1155BatchReceived.selector){revert(\"ERC1155:ERC1155Receiverrejectedtokens\");}}catchError(stringmemoryreason){revert(reason);}catch{revert(\"ERC1155:transfertononERC1155Receiverimplementer\");}}}"
  ],
  "exists": ["{returnERC1155Supply.totalSupply(id)>0;}"],
  "mintBatch": ["{_mintBatch(_to,_ids,_amounts,\"\");}"],
  "burnBatch": ["{_burnBatch(msg.sender,_ids,_amounts);}"],
  "burnForMint": [
    "{_burnBatch(_from,_burnIds,_burnAmounts);_mintBatch(_from,_mintIds,_mintAmounts,\"\");}"
  ],
  "setURI": ["{tokenURI[_id]=_uri;emitURI(_uri,_id);}"],
  "_setOwner": [
    "{addressoldOwner=_owner;_owner=newOwner;emitOwnershipTransferred(oldOwner,newOwner);}"
  ],
  "walletOfOwner": [
    "{uint256ownerTokenCount=balanceOf(_owner);uint256[]memorytokenIds=newuint256[](ownerTokenCount);for(uint256i;i<ownerTokenCount;i++){tokenIds[i]=tokenOfOwnerByIndex(_owner,i);}returntokenIds;}"
  ],
  "setCost": ["{cost=_newCost;}"],
  "setPresaleCost": ["{presaleCost=_newCost;}"],
  "setmaxMintAmount": ["{maxMintAmount=_newmaxMintAmount;}"],
  "setBaseExtension": ["{baseExtension=_newBaseExtension;}"],
  "pause": ["{paused=_state;}"],
  "whitelistUser": ["{whitelisted[_user]=true;}"],
  "removeWhitelistUser": ["{whitelisted[_user]=false;}"],
  "addPresaleUser": ["{presaleWallets[_user]=true;}"],
  "add100PresaleUsers": [
    "{for(uint256i=0;i<2;i++){presaleWallets[_users[i]]=true;}}"
  ],
  "removePresaleUser": ["{presaleWallets[_user]=false;}"],
  "withdraw": [
    "{(boolsuccess,)=payable(msg.sender).call{value:address(this).balance}(\"\");require(success);}",
    "{uintbalance=address(this).balance;msg.sender.transfer(balance);}",
    "{uint256balance=address(this).balance;if(balance>0){Address.sendValue(payable(owner()),balance);}balance=IERC20(tokenContract).balanceOf(address(this));if(balance>0){IERC20(tokenContract).safeTransfer(owner(),balance);}}"
  ],
  "_registerInterface": [
    "{require(interfaceId!=0xffffffff,\"ERC165:invalidinterfaceid\");_supportedInterfaces[interfaceId]=true;}",
    "{require(interfaceId!=0xffffffff,\"\");_supportedInterfaces[interfaceId]=true;}"
  ],
  "tokenNameByIndex": ["{return_tokenName[index];}"],
  "isNameReserved": ["{return_nameReserved[toLower(nameString)];}"],
  "isMintedBeforeReveal": ["{return_mintedBeforeReveal[index];}"],
  "getNFTPrice": [
    "{require(block.timestamp>=SALE_START_TIMESTAMP,\"Salehasnotstarted\");require(totalSupply()<MAX_NFT_SUPPLY,\"Salehasalreadyended\");uintcurrentSupply=totalSupply();if(currentSupply>=16381){return100000000000000000000;}elseif(currentSupply>=16000){return3000000000000000000;}elseif(currentSupply>=15000){return1700000000000000000;}elseif(currentSupply>=11000){return900000000000000000;}elseif(currentSupply>=7000){return500000000000000000;}elseif(currentSupply>=3000){return300000000000000000;}else{return100000000000000000;}}"
  ],
  "mintNFT": [
    "{require(totalSupply()<MAX_NFT_SUPPLY,\"Salehasalreadyended\");require(numberOfNfts>0,\"numberOfNftscannotbe0\");require(numberOfNfts<=20,\"Youmaynotbuymorethan20NFTsatonce\");require(totalSupply().add(numberOfNfts)<=MAX_NFT_SUPPLY,\"ExceedsMAX_NFT_SUPPLY\");require(getNFTPrice().mul(numberOfNfts)==msg.value,\"Ethervaluesentisnotcorrect\");for(uinti=0;i<numberOfNfts;i++){uintmintIndex=totalSupply();if(block.timestamp<REVEAL_TIMESTAMP){_mintedBeforeReveal[mintIndex]=true;}_safeMint(msg.sender,mintIndex);}if(startingIndexBlock==0&&(totalSupply()==MAX_NFT_SUPPLY||block.timestamp>=REVEAL_TIMESTAMP)){startingIndexBlock=block.number;}}"
  ],
  "finalizeStartingIndex": [
    "{require(startingIndex==0,\"Startingindexisalreadyset\");require(startingIndexBlock!=0,\"Startingindexblockmustbeset\");startingIndex=uint(blockhash(startingIndexBlock))%MAX_NFT_SUPPLY;if(block.number.sub(startingIndexBlock)>255){startingIndex=uint(blockhash(block.number-1))%MAX_NFT_SUPPLY;}if(startingIndex==0){startingIndex=startingIndex.add(1);}}"
  ],
  "changeName": [
    "{addressowner=ownerOf(tokenId);require(_msgSender()==owner,\"ERC721:callerisnottheowner\");require(validateName(newName)==true,\"Notavalidnewname\");require(sha256(bytes(newName))!=sha256(bytes(_tokenName[tokenId])),\"Newnameissameasthecurrentone\");require(isNameReserved(newName)==false,\"Namealreadyreserved\");IERC20(_nctAddress).transferFrom(msg.sender,address(this),NAME_CHANGE_PRICE);if(bytes(_tokenName[tokenId]).length>0){toggleReserveName(_tokenName[tokenId],false);}toggleReserveName(newName,true);_tokenName[tokenId]=newName;IERC20(_nctAddress).burn(NAME_CHANGE_PRICE);emitNameChange(tokenId,newName);}",
    "{nftName=name;nftSymbol=symbol;}"
  ],
  "toggleReserveName": ["{_nameReserved[toLower(str)]=isReserve;}"],
  "validateName": [
    "{bytesmemoryb=bytes(str);if(b.length<1)returnfalse;if(b.length>25)returnfalse;if(b[0]==0x20)returnfalse;if(b[b.length-1]==0x20)returnfalse;bytes1lastChar=b[0];for(uinti;i<b.length;i++){bytes1char=b[i];if(char==0x20&&lastChar==0x20)returnfalse;if(!(char>=0x30&&char<=0x39)&&!(char>=0x41&&char<=0x5A)&&!(char>=0x61&&char<=0x7A)&&!(char==0x20))returnfalse;lastChar=char;}returntrue;}"
  ],
  "toLower": [
    "{bytesmemorybStr=bytes(str);bytesmemorybLower=newbytes(bStr.length);for(uinti=0;i<bStr.length;i++){if((uint8(bStr[i])>=65)&&(uint8(bStr[i])<=90)){bLower[i]=bytes1(uint8(bStr[i])+32);}else{bLower[i]=bStr[i];}}returnstring(bLower);}"
  ],
  "_length": ["{returnset._values.length;}", "{returnmap._entries.length;}"],
  "length": ["{return_length(set._inner);}", "{return_length(map._inner);}"],
  "mod": [
    "{require(b!=0,errorMessage);returna%b;}",
    "{require(b>0,\"\");returna%b;}",
    "{require(_divisor!=0,\"\");remainder=_dividend%_divisor;}"
  ],
  "tryAdd": ["{uint256c=a+b;if(c<a)return(false,0);return(true,c);}"],
  "trySub": ["{if(b>a)return(false,0);return(true,a-b);}"],
  "tryMul": [
    "{if(a==0)return(true,0);uint256c=a*b;if(c/a!=b)return(false,0);return(true,c);}"
  ],
  "tryDiv": ["{if(b==0)return(false,0);return(true,a/b);}"],
  "tryMod": ["{if(b==0)return(false,0);return(true,a%b);}"],
  "_tryGet": [
    "{uint256keyIndex=map._indexes[key];if(keyIndex==0)return(false,0);return(true,map._entries[keyIndex-1]._value);}"
  ],
  "tryGet": [
    "{(boolsuccess,bytes32value)=_tryGet(map._inner,bytes32(key));return(success,address(uint160(uint256(value))));}"
  ],
  "baseURI": ["{return_baseURI;}"],
  "_setTokenURI": [
    "{require(_exists(tokenId),\"\");_tokenURIs[tokenId]=_tokenURI;}"
  ],
  "_setBaseURI": ["{_baseURI=baseURI_;}"],
  "reserveApes": [
    "{uintsupply=totalSupply();uinti;for(i=0;i<30;i++){_safeMint(msg.sender,supply+i);}}"
  ],
  "setRevealTimestamp": ["{REVEAL_TIMESTAMP=revealTimeStamp;}"],
  "setProvenanceHash": ["{BAYC_PROVENANCE=provenanceHash;}"],
  "flipSaleState": ["{saleIsActive=!saleIsActive;}"],
  "mintApe": [
    "{require(saleIsActive,\"\");require(numberOfTokens<=maxApePurchase,\"\");require(totalSupply().add(numberOfTokens)<=MAX_APES,\"\");require(apePrice.mul(numberOfTokens)<=msg.value,\"\");for(uinti=0;i<numberOfTokens;i++){uintmintIndex=totalSupply();if(totalSupply()<MAX_APES){_safeMint(msg.sender,mintIndex);}}if(startingIndexBlock==0&&(totalSupply()==MAX_APES||block.timestamp>=REVEAL_TIMESTAMP)){startingIndexBlock=block.number;}}"
  ],
  "setStartingIndex": [
    "{require(startingIndex==0,\"\");require(startingIndexBlock!=0,\"\");startingIndex=uint(blockhash(startingIndexBlock))%MAX_APES;if(block.number.sub(startingIndexBlock)>255){startingIndex=uint(blockhash(block.number-1))%MAX_APES;}if(startingIndex==0){startingIndex=startingIndex.add(1);}}"
  ],
  "emergencySetStartingIndexBlock": [
    "{require(startingIndex==0,\"\");startingIndexBlock=block.number;}"
  ],
  "implementation": ["{implementation_=_implementation();}"],
  "changeAdmin": ["{_changeAdmin(newAdmin);}"],
  "_admin": ["{return_getAdmin();}"],
  "_beforeFallback": ["{}"],
  "_fallback": [""],
  "_getImplementation": [
    "{returnStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;}"
  ],
  "_setImplementation": [
    "{require(Address.isContract(newImplementation),\"\");StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value=newImplementation;}"
  ],
  "_getAdmin": ["{returnStorageSlot.getAddressSlot(_ADMIN_SLOT).value;}"],
  "_setAdmin": [
    "{require(newAdmin!=address(0),\"\");StorageSlot.getAddressSlot(_ADMIN_SLOT).value=newAdmin;}"
  ],
  "_changeAdmin": [
    "{emitAdminChanged(_getAdmin(),newAdmin);_setAdmin(newAdmin);}"
  ],
  "getAddressSlot": ["{assembly{r.slot:=slot}}"],
  "getBooleanSlot": ["{assembly{r.slot:=slot}}"],
  "getBytes32Slot": ["{assembly{r.slot:=slot}}"],
  "getUint256Slot": ["{assembly{r.slot:=slot}}"],
  "_getOwnerNFTCount": ["{returnownerToIds[_owner].length;}"],
  "tokenPayload": ["{returnidToPayload[_tokenId];}"],
  "_setTokenUri": ["{idToUri[_tokenId]=_uri;}"],
  "_setTokenPayload": ["{idToPayload[_tokenId]=_uri;}"],
  "contractURI": ["{returnnftContractMetadataUri;}"],
  "updateContractURI": [
    "{emitUpdatedContractURI(nftContractMetadataUri,uri);nftContractMetadataUri=uri;}"
  ],
  "getOwnerNFTCount": [
    "{returnNFTokenEnumerableMetadata._getOwnerNFTCount(_owner);}"
  ],
  "updateTokenUri": ["{idToUri[_tokenId]=_uri;}"],
  "setOperator": ["{operator=_operator;}"],
  "setMaxMintPerTx": ["{maxMintPerTx=_maxMintPerTx;}"],
  "setMaxMintPerAddress": ["{maxMintPerAddress=_maxMintPerAddress;}"],
  "setKycCheckRequired": ["{isKycCheckRequired=_isKycCheckRequired;}"],
  "setKycMerkleRoot": ["{kycMerkleRoot=_kycMerkleRoot;}"],
  "startPublicSale": [
    "{require(!publicSaleActive,\"\");publicSalePriceLoweringDuration=_publicSalePriceLoweringDuration;publicSaleStartPrice=_publicSaleStartPrice;publicSaleEndingPrice=_publicSaleEndingPrice;publicSaleStartTime=block.timestamp;publicSaleActive=true;maxMintPerTx=_maxMintPerTx;maxMintPerAddress=_maxMintPerAddress;isKycCheckRequired=_isKycCheckRequired;emitLandPublicSaleStart(publicSalePriceLoweringDuration,publicSaleStartTime);}"
  ],
  "stopPublicSale": [
    "{emitLandPublicSaleStop(getMintPrice(),getElapsedSaleTime());publicSaleActive=false;}"
  ],
  "getElapsedSaleTime": [
    "{returnpublicSaleStartTime>0?block.timestamp-publicSaleStartTime:0;}"
  ],
  "getMintPrice": [
    "{uint256elapsed=getElapsedSaleTime();uint256price;if(elapsed<publicSalePriceLoweringDuration){price=publicSaleStartPrice-((publicSaleStartPrice-publicSaleEndingPrice)*elapsed)/publicSalePriceLoweringDuration;}else{price=publicSaleEndingPrice;}returnprice;}"
  ],
  "mintLands": [
    "{require(numLands>0,\"\");require(currentNumLandsMintedPublicSale+numLands<=MAX_PUBLIC_SALE_AMOUNT,\"\");require(numLands<=maxMintPerTx,\"\");require(numLands+mintedPerAddress[msg.sender]<=maxMintPerAddress,\"\");if(isKycCheckRequired){require(MerkleProof.verify(merkleProof,\"\"))),\"SenderaddressisnotinKYCallowlist\");}else{require(msg.sender==tx.origin,\"\");}uint256mintPrice=getMintPrice();IERC20(tokenContract).safeTransferFrom(msg.sender,address(this),mintPrice*numLands);currentNumLandsMintedPublicSale+=numLands;mintedPerAddress[msg.sender]+=numLands;emitPublicSaleMint(msg.sender,numLands,mintPrice);mintLandsCommon(numLands,msg.sender);}"
  ],
  "mintLandsCommon": [
    "{for(uint256i;i<numLands;++i){_safeMint(recipient,mintIndexPublicSaleAndContributors++);}}"
  ],
  "flipClaimableState": [
    "{claimableActive=!claimableActive;emitClaimableStateChanged(claimableActive);}"
  ],
  "nftOwnerClaimLand": [
    "{require(alphaTokenIds.length>0||betaTokenIds.length>0,\"\");require(alphaTokenIds.length+betaTokenIds.length<=MAX_MINT_PER_BLOCK,\"\");alphaClaimLand(alphaTokenIds);betaClaimLand(betaTokenIds);}"
  ],
  "alphaClaimLand": [
    "{for(uint256i;i<alphaTokenIds.length;++i){uint256alphaTokenId=alphaTokenIds[i];require(!alphaClaimed[alphaTokenId],\"\");require(ERC721(alphaContract).ownerOf(alphaTokenId)==msg.sender,\"\");alphaClaimLandByTokenId(alphaTokenId);}}"
  ],
  "alphaClaimLandByTokenId": [
    "{alphaClaimed[alphaTokenId]=true;++alphaClaimedAmount;_safeMint(msg.sender,alphaTokenId);}"
  ],
  "betaClaimLand": [
    "{for(uint256i;i<betaTokenIds.length;++i){uint256betaTokenId=betaTokenIds[i];require(!betaClaimed[betaTokenId],\"\");require(ERC721(betaContract).ownerOf(betaTokenId)==msg.sender,\"\");betaClaimLandByTokenId(betaTokenId);}}"
  ],
  "betaClaimLandByTokenId": [
    "{betaClaimed[betaTokenId]=true;++betaClaimedAmount;_safeMint(msg.sender,betaNftIdCurrent++);}"
  ],
  "startContributorsClaimPeriod": [
    "{require(!contributorsClaimActive,\"\");contributorsClaimActive=true;emitContributorsClaimStart(block.timestamp);}"
  ],
  "stopContributorsClaimPeriod": [
    "{contributorsClaimActive=false;emitContributorsClaimStop(block.timestamp);}"
  ],
  "contributorsClaimLand": [
    "{require(amount>0,\"\");require(amount<=MAX_MINT_PER_BLOCK,\"\");require(amount<=contributors[msg.sender],\"\");contributors[msg.sender]-=amount;mintLandsCommon(amount,recipient);}"
  ],
  "claimUnclaimedAndUnsoldLands": [
    "{claimUnclaimedAndUnsoldLandsWithAmount(recipient,MAX_MINT_PER_BLOCK);}"
  ],
  "claimUnclaimedAndUnsoldLandsWithAmount": [
    "{require(publicSaleStartTime>0&&!claimableActive&&!publicSaleActive&&!contributorsClaimActive,\"Cannotclaimtheunclaimedifclaimableorpublicsaleareactive\");require(maxAmount<=MAX_MINT_PER_BLOCK,\"\");require(alphaClaimedAmount<MAX_ALPHA_NFT_AMOUNT||betaClaimedAmount<MAX_BETA_NFT_AMOUNT||mintIndexPublicSaleAndContributors<MAX_LANDS,\"\");uint256totalMinted;adminClaimStarted=true;if(betaClaimedAmount<MAX_BETA_NFT_AMOUNT){uint256leftToBeMinted=MAX_BETA_NFT_AMOUNT-betaClaimedAmount;uint256toMint=leftToBeMinted<maxAmount?leftToBeMinted:maxAmount;uint256target=betaNftIdCurrent+toMint;for(;betaNftIdCurrent<target;++betaNftIdCurrent){++betaClaimedAmount;++totalMinted;_safeMint(recipient,betaNftIdCurrent);}}if(alphaClaimedAmount<MAX_ALPHA_NFT_AMOUNT){uint256leftToBeMinted=MAX_ALPHA_NFT_AMOUNT-alphaClaimedAmount;uint256toMint=maxAmount<leftToBeMinted+totalMinted?maxAmount:leftToBeMinted+totalMinted;uint256lastAlphaNft=MAX_ALPHA_NFT_AMOUNT-1;for(uint256i;i<=lastAlphaNft&&totalMinted<toMint;++i){if(!alphaClaimed[i]){++alphaClaimedAmount;++totalMinted;alphaClaimed[i]=true;_safeMint(recipient,i);}}}if(mintIndexPublicSaleAndContributors<MAX_LANDS){uint256leftToBeMinted=MAX_LANDS-mintIndexPublicSaleAndContributors;uint256toMint=maxAmount<leftToBeMinted+totalMinted?maxAmount:leftToBeMinted+totalMinted;for(;mintIndexPublicSaleAndContributors<MAX_LANDS&&totalMinted<toMint;++mintIndexPublicSaleAndContributors){++totalMinted;_safeMint(recipient,mintIndexPublicSaleAndContributors);}}}"
  ],
  "setFutureMinter": ["{futureMinter=_futureMinter;}"],
  "mintFutureLands": [
    "{mintFutureLandsWithAmount(recipient,MAX_MINT_PER_BLOCK);}"
  ],
  "mintFutureLandsWithAmount": [
    "{require(maxAmount<=MAX_MINT_PER_BLOCK,\"\");require(futureLandsNftIdCurrent<MAX_LANDS_WITH_FUTURE,\"\");for(uint256claimed;claimed<maxAmount&&futureLandsNftIdCurrent<MAX_LANDS_WITH_FUTURE;++claimed){_safeMint(recipient,futureLandsNftIdCurrent++);}}"
  ],
  "loadLandMetadata": ["{metadataHashes.push(_landMetadata);}"],
  "putLandMetadataAtIndex": ["{metadataHashes[index]=_landMetadata;}"],
  "requestRandomnessForPublicSaleAndContributors": [
    "{require(!publicSaleAndContributorsRandomnessRequested,\"\");publicSaleAndContributorsRandomnessRequested=true;requestId=requestRandomnessPrivate();isRandomRequestForPublicSaleAndContributors[requestId]=true;}"
  ],
  "requestRandomnessForOwnerClaim": [
    "{require(!ownerClaimRandomnessRequested,\"\");ownerClaimRandomnessRequested=true;requestId=requestRandomnessPrivate();isRandomRequestForPublicSaleAndContributors[requestId]=false;}"
  ],
  "requestRandomnessPrivate": [
    "{require(LINK.balanceOf(address(this))>=fee,\"\");returnrequestRandomness(keyHash,fee);}"
  ],
  "fulfillRandomness": [
    "{if(isRandomRequestForPublicSaleAndContributors[requestId]){publicSaleAndContributorsOffset=(randomness%(MAX_PUBLIC_SALE_AMOUNT+RESERVED_CONTRIBUTORS_AMOUNT));emitStartingIndexSetPublicSale(publicSaleAndContributorsOffset);}else{alphaOffset=(randomness%MAX_ALPHA_NFT_AMOUNT);betaOffset=(randomness%MAX_BETA_NFT_AMOUNT);emitStartingIndexSetAlphaBeta(alphaOffset,betaOffset);}}"
  ],
  "verify": ["{returnprocessProof(proof,leaf)==root;}"],
  "processProof": [
    "{bytes32computedHash=leaf;for(uint256i=0;i<proof.length;i++){bytes32proofElement=proof[i];if(computedHash<=proofElement){computedHash=_efficientHash(computedHash,proofElement);}else{computedHash=_efficientHash(proofElement,computedHash);}}returncomputedHash;}"
  ],
  "_efficientHash": [
    "{assembly{mstore(0x00,a)mstore(0x20,b)value:=keccak256(0x00,0x40)}}"
  ],
  "safeTransfer": [
    "{_callOptionalReturn(token,abi.encodeWithSelector(token.transfer.selector,to,value));}"
  ],
  "safeApprove": [
    "{require((value==0)||(token.allowance(address(this),\"\")==0),\"SafeERC20:approvefromnon-zerotonon-zeroallowance\");_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,value));}"
  ],
  "safeIncreaseAllowance": [
    "{uint256newAllowance=token.allowance(address(this),spender)+value;_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,newAllowance));}"
  ],
  "safeDecreaseAllowance": [
    "{unchecked{uint256oldAllowance=token.allowance(address(this),spender);require(oldAllowance>=value,\"\");uint256newAllowance=oldAllowance-value;_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,newAllowance));}}"
  ],
  "makeVRFInputSeed": [
    "{returnuint256(keccak256(abi.encode(_keyHash,_userSeed,_requester,_nonce)));}"
  ],
  "makeRequestId": [
    "{returnkeccak256(abi.encodePacked(_keyHash,_vRFInputSeed));}"
  ],
  "requestRandomness": [
    "{LINK.transferAndCall(vrfCoordinator,_fee,abi.encode(_keyHash,USER_SEED_PLACEHOLDER));uint256vRFSeed=makeVRFInputSeed(_keyHash,USER_SEED_PLACEHOLDER,address(this),nonces[_keyHash]);nonces[_keyHash]=nonces[_keyHash]+1;returnmakeRequestId(_keyHash,vRFSeed);}"
  ],
  "rawFulfillRandomness": [
    "{require(msg.sender==vrfCoordinator,\"\");fulfillRandomness(requestId,randomness);}"
  ],
  "recover": ["{}"],
  "toEthSignedMessageHash": [
    "{returnkeccak256(abi.encodePacked(\"\\x19EthereumSignedMessage:32\",hash));}"
  ],
  "toTypedDataHash": [
    "{returnkeccak256(abi.encodePacked(\"\\x19\\x01\",domainSeparator,structHash));}"
  ],
  "_nextTokenId": ["{return_currentIndex;}"],
  "_totalMinted": ["{unchecked{return_currentIndex-_startTokenId();}}"],
  "_totalBurned": ["{return_burnCounter;}"],
  "_ownershipAt": ["{return_unpackedOwnership(_packedOwnerships[index]);}"],
  "_initializeOwnershipAt": [
    "{if(_packedOwnerships[index]==0){_packedOwnerships[index]=_packedOwnershipOf(index);}}"
  ],
  "_unpackedOwnership": [
    "{ownership.addr=address(uint160(packed));ownership.startTimestamp=uint64(packed>>_BITPOS_START_TIMESTAMP);ownership.burned=packed&_BITMASK_BURNED!=0;ownership.extraData=uint24(packed>>_BITPOS_EXTRA_DATA);}"
  ],
  "_nextInitializedFlag": [
    "{assembly{result:=shl(_BITPOS_NEXT_INITIALIZED,eq(quantity,1))}}"
  ],
  "_isSenderApprovedOrOwner": [
    "{assembly{owner:=and(owner,_BITMASK_ADDRESS)msgSender:=and(msgSender,_BITMASK_ADDRESS)result:=or(eq(msgSender,owner),eq(msgSender,approvedAddress))}}"
  ],
  "_mintERC2309": [
    "{uint256startTokenId=_currentIndex;if(to==address(0))revertMintToZeroAddress();if(quantity==0)revertMintZeroQuantity();if(quantity>_MAX_MINT_ERC2309_QUANTITY_LIMIT)revertMintERC2309QuantityExceedsLimit();_beforeTokenTransfers(address(0),to,startTokenId,quantity);unchecked{_packedAddressData[to]+=quantity*((1<<_BITPOS_NUMBER_MINTED)|1);_packedOwnerships[startTokenId]=_packOwnershipData(to,_nextInitializedFlag(quantity)|_nextExtraData(address(0),to,0));emitConsecutiveTransfer(startTokenId,startTokenId+quantity-1,address(0),to);_currentIndex=startTokenId+quantity;}_afterTokenTransfers(address(0),to,startTokenId,quantity);}"
  ],
  "_setExtraDataAt": [
    "{uint256packed=_packedOwnerships[index];if(packed==0)revertOwnershipNotInitializedForExtraData();uint256extraDataCasted;assembly{extraDataCasted:=extraData}packed=(packed&_BITMASK_EXTRA_DATA_COMPLEMENT)|(extraDataCasted<<_BITPOS_EXTRA_DATA);_packedOwnerships[index]=packed;}"
  ],
  "_toString": [
    "{assembly{letm:=add(mload(0x40),0xa0)mstore(0x40,m)str:=sub(m,0x20)mstore(str,0)letend:=strfor{lettemp:=value}1{}{str:=sub(str,1)mstore8(str,add(48,mod(temp,10)))temp:=div(temp,10)ifiszero(temp){break}}letlength:=sub(end,str)str:=sub(str,0x20)mstore(str,length)}}"
  ],
  "setStage": [
    "{require(stageType>0&&stageType<5,\"\");require(startTime<endTime,\"\");require(endTime>block.timestamp,\"\");require(_maxQuantity!=0,\"\");uintstageNum=stageList.length;if(stageType>=stageNum){for(uinti;i<stageType.sub(stageNum);i++){stageList.push(Stage(0,0,0,0,0));}}uintindex=stageType.sub(1);Stagestoragestage=stageList[index];stage.startTime=startTime;stage.endTime=endTime;stage.maxQuantity=_maxQuantity;stage.price=price;stageList[index]=stage;emitStageEvent(stageType,startTime,endTime,_maxQuantity,stage.mintedNum,price);}"
  ],
  "getStage": [
    "{require(stageType>0,\"\");uintstageNum=stageList.length;if(stageType>stageNum){return(0,0,0,0,0,0);}Stagememorystage=stageList[stageType.sub(1)];return(stageType,stage.startTime,stage.endTime,stage.maxQuantity,stage.mintedNum,stage.price);}"
  ],
  "getTokenURI": [
    "{if(!_exists(tokenId))revertURIQueryForNonexistentToken();return_tokenURI[tokenId];}"
  ],
  "getExecutorAddress": [
    "{if(owner()!=_msgSender()){returnaddress(0);}returnexecutorAddress;}"
  ],
  "getWhitelistAddress": [
    "{if(owner()!=_msgSender()){returnaddress(0);}returnwhitelistAddress;}"
  ],
  "setTokenURI": ["{_tokenURI[tokenId]=uri;emitTokenURIEvent(tokenId,uri);}"],
  "setTokenURIBatch": [
    "{require(tokenIdList.length!=0,\"\");require(tokenIdList.length==uriList.length,\"\");require(tokenIdList.length<=15,\"\");for(uinti;i<tokenIdList.length;i++){uint256tokenId=tokenIdList[i];stringmemoryuri=uriList[i];_tokenURI[tokenId]=uri;}}"
  ],
  "setOpenBoxTime": [
    "{require(_openBoxTime>block.timestamp,\"\");openBoxTime=_openBoxTime;emitOpenBoxTimeEvent(_openBoxTime);}"
  ],
  "setMaxQuantity": [
    "{maxQuantity=_maxQuantity;emitMaxQuantityEvent(_maxQuantity);}"
  ],
  "setExecutorAddress": [
    "{executorAddress=_executorAddress;emitExecutorAddressEvent(_executorAddress);}"
  ],
  "setWhitelistAddress": [
    "{whitelistAddress=_whitelistAddress;emitWhitelistAddressEvent(_whitelistAddress);}"
  ],
  "executorMint": [
    "{require(msg.sender==tx.origin,\"\");require(to==msg.sender,\"\");require(executorAddress==msg.sender,\"\");require(maxTotalSupply==0||totalSupply().add(quantity)<maxTotalSupply,\"\");_mint(to,quantity);emitNFTMintEvent(0,_nextTokenId()-1,to,quantity,0);}"
  ],
  "currentStage": [
    "{uintstageNum=stageList.length;uint256currentTime=block.timestamp;for(uinti;i<stageNum;i++){Stagememorystage=stageList[i];uintstageType=i.add(1);uint256price=stage.price;if(currentTime>=stage.startTime&&currentTime<=stage.endTime){if(to==address(0)){return(stageType,false,price);}uint256stageMintedNum=stage.mintedNum;uint256stageMaxQuantity=stage.maxQuantity;if(stageMintedNum>=stageMaxQuantity){return(stageType,false,price);}return(stageType,!mintedNum[stageType][to],price);}}return(0,false,0);}"
  ],
  "updateStage": [
    "{require(stageType>0&&stageType<=stageList.length,\"\");uintindex=stageType.sub(1);Stagememorystage=stageList[index];uint256startTime=stage.startTime;uint256endTime=stage.endTime;require(startTime<block.timestamp&&block.timestamp<endTime,\"\");uint256stagePrice=stage.price;require(price!=0&&price>=stagePrice,\"\");uint256stageMintedNum=stage.mintedNum;uint256stageMaxQuantity=stage.maxQuantity;require(stageMintedNum.add(quantity)<=stageMaxQuantity,\"\");require(quantity.mul(price)<=msg.value,\"\");Stagestorage_stage=stageList[index];_stage.mintedNum=stageMintedNum.add(quantity);stageList[index]=_stage;emitUpdateStageEvent(stageType,to,_stage.mintedNum);}"
  ],
  "signatureMint": [
    "{returnECDSA.recover(keccak256(abi.encode(stageType,to,quantity,price,_timestamp)),_signature);}"
  ],
  "setBlackMarketplaces": ["{_blackMarketplaces[operator]=approved;}"],
  "isBlackMarketplaces": ["{return_blackMarketplaces[operator];}"],
  "withDrawAll": [
    "{(boolsuccess,)=to.call{gas:21000,value:address(this).balance}(\"\");require(success,\"\");"
  ]
}
